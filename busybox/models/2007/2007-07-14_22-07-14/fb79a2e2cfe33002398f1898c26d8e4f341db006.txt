2007-07-14 22:07:14 +0000
diff --git a/console-tools/chvt.c b/console-tools/chvt.c
index e8761d5..86d3f2d 100644
--- a/console-tools/chvt.c
+++ b/console-tools/chvt.c
@@ -26,9 +26,7 @@ int chvt_main(int argc, char **argv)
 
 	fd = get_console_fd();
 	num = xatoul_range(argv[1], 1, 63);
-	if ((-1 == ioctl(fd, VT_ACTIVATE, num))
-	|| (-1 == ioctl(fd, VT_WAITACTIVE, num))) {
-		bb_perror_msg_and_die("ioctl");
-	}
+	xioctl(fd, VT_ACTIVATE, (void *)num);
+	xioctl(fd, VT_WAITACTIVE, (void *)num);
 	return EXIT_SUCCESS;
 }
diff --git a/console-tools/deallocvt.c b/console-tools/deallocvt.c
index db52747..a690266 100644
--- a/console-tools/deallocvt.c
+++ b/console-tools/deallocvt.c
@@ -31,8 +31,6 @@ int deallocvt_main(int argc, char **argv)
 		bb_show_usage();
 	}
 
-	if (-1 == ioctl(get_console_fd(), VT_DISALLOCATE, num)) {
-		bb_perror_msg_and_die("VT_DISALLOCATE");
-	}
+	xioctl(get_console_fd(), VT_DISALLOCATE, (void *)num);
 	return EXIT_SUCCESS;
 }
diff --git a/console-tools/dumpkmap.c b/console-tools/dumpkmap.c
index f61795c..a606d56 100644
--- a/console-tools/dumpkmap.c
+++ b/console-tools/dumpkmap.c
@@ -50,12 +50,12 @@ int dumpkmap_main(int argc, char **argv)
 			for (j = 0; j < NR_KEYS; j++) {
 				ke.kb_index = j;
 				ke.kb_table = i;
-				if (ioctl(fd, KDGKBENT, &ke) < 0) {
-					bb_perror_msg("ioctl failed with %s, %s, %p",
+				if (!ioctl_or_perror(fd, KDGKBENT, &ke,
+						"ioctl failed with %s, %s, %p",
 						(char *)&ke.kb_index,
 						(char *)&ke.kb_table,
-						&ke.kb_value);
-				} else {
+						&ke.kb_value)
+				) {
 					write(1, (void*)&ke.kb_value, 2);
 				}
 			}
diff --git a/console-tools/loadfont.c b/console-tools/loadfont.c
index b046d40..6b4dcb4 100644
--- a/console-tools/loadfont.c
+++ b/console-tools/loadfont.c
@@ -49,13 +49,11 @@ static void do_loadfont(int fd, unsigned char *inbuf, int unit, int fontsize)
 		cfd.charheight = unit;
 		cfd.chardata = buf;
 
-		if (ioctl(fd, PIO_FONTX, &cfd) == 0)
+		if (!ioctl_or_perror(fd, PIO_FONTX, &cfd, "PIO_FONTX ioctl failed (will try PIO_FONT)"))
 			goto ret;			/* success */
-		bb_perror_msg("PIO_FONTX ioctl (will try PIO_FONT)");
 	}
 #endif
-	if (ioctl(fd, PIO_FONT, buf))
-		bb_perror_msg_and_die("PIO_FONT ioctl");
+	xioctl(fd, PIO_FONT, buf);
  ret:
 	free(buf);
 }
@@ -92,20 +90,10 @@ do_loadtable(int fd, unsigned char *inbuf, int tailsz, int fontsize)
 	advice.advised_hashsize = 0;
 	advice.advised_hashstep = 0;
 	advice.advised_hashlevel = 0;
-	if (ioctl(fd, PIO_UNIMAPCLR, &advice)) {
-#ifdef ENOIOCTLCMD
-		if (errno == ENOIOCTLCMD) {
-			bb_error_msg("it seems this kernel is older than 1.1.92");
-			bb_error_msg_and_die("no Unicode mapping table loaded");
-		} else
-#endif
-			bb_perror_msg_and_die("PIO_UNIMAPCLR");
-	}
+	xioctl(fd, PIO_UNIMAPCLR, &advice);
 	ud.entry_ct = ct;
 	ud.entries = up;
-	if (ioctl(fd, PIO_UNIMAP, &ud)) {
-		bb_perror_msg_and_die("PIO_UNIMAP");
-	}
+	xioctl(fd, PIO_UNIMAP, &ud);
 }
 
 static void loadnewfont(int fd)
diff --git a/console-tools/setconsole.c b/console-tools/setconsole.c
index f437415..8745b3b 100644
--- a/console-tools/setconsole.c
+++ b/console-tools/setconsole.c
@@ -42,8 +42,6 @@ int setconsole_main(int argc, char **argv)
 			device = DEV_CONSOLE;
 	}
 
-	if (-1 == ioctl(xopen(device, O_RDONLY), TIOCCONS)) {
-		bb_perror_msg_and_die("TIOCCONS");
-	}
+	xioctl(xopen(device, O_RDONLY), TIOCCONS, NULL);
 	return EXIT_SUCCESS;
 }
diff --git a/console-tools/setkeycodes.c b/console-tools/setkeycodes.c
index 0911ede..3de5f98 100644
--- a/console-tools/setkeycodes.c
+++ b/console-tools/setkeycodes.c
@@ -39,9 +39,9 @@ int setkeycodes_main(int argc, char** argv)
 			a.scancode -= 0xe000;
 			a.scancode += 128;
 		}
-		if (ioctl(fd, KDSETKEYCODE, &a)) {
-			bb_perror_msg_and_die("failed to set SCANCODE %x to KEYCODE %d", sc, a.keycode);
-		}
+		ioctl_or_perror_and_die(fd, KDSETKEYCODE, &a,
+			"failed to set SCANCODE %x to KEYCODE %d",
+			sc, a.keycode);
 		argc -= 2;
 		argv += 2;
 	}
diff --git a/console-tools/setlogcons.c b/console-tools/setlogcons.c
index f95a653..2e2a5a4 100644
--- a/console-tools/setlogcons.c
+++ b/console-tools/setlogcons.c
@@ -25,8 +25,7 @@ int setlogcons_main(int argc, char **argv)
 	if (argc == 2)
 		arg.subarg = xatoul_range(argv[1], 0, 63);
 
-	if (ioctl(xopen(VC_1, O_RDONLY), TIOCLINUX, &arg))
-		bb_perror_msg_and_die("TIOCLINUX");
+	xioctl(xopen(VC_1, O_RDONLY), TIOCLINUX, &arg);
 
 	return 0;
 }
diff --git a/coreutils/date.c b/coreutils/date.c
index cec8854..1b20cd4 100644
--- a/coreutils/date.c
+++ b/coreutils/date.c
@@ -32,16 +32,10 @@
 #define DATE_OPT_TIMESPEC	0x20
 #define DATE_OPT_HINT		0x40
 
-static void xputenv(char *s)
-{
-	if (putenv(s) != 0)
-		bb_error_msg_and_die(bb_msg_memory_exhausted);
-}
-
 static void maybe_set_utc(int opt)
 {
 	if (opt & DATE_OPT_UTC)
-		xputenv((char*)"TZ=UTC0");
+		putenv((char*)"TZ=UTC0");
 }
 
 int date_main(int argc, char **argv);
diff --git a/e2fsprogs/old_e2fsprogs/mke2fs.c b/e2fsprogs/old_e2fsprogs/mke2fs.c
index 4d5cce3..9ea5d5c 100644
--- a/e2fsprogs/old_e2fsprogs/mke2fs.c
+++ b/e2fsprogs/old_e2fsprogs/mke2fs.c
@@ -169,7 +169,7 @@ static void invalid_block(ext2_filsys fs EXT2FS_ATTR((unused)), blk_t blk)
 /*
  * Busybox stuff
  */
-static void mke2fs_error_msg_and_die(int retval, const char *fmt, ...)__attribute__ ((format (printf, 2, 3)));
+static void mke2fs_error_msg_and_die(int retval, const char *fmt, ...) __attribute__ ((format (printf, 2, 3)));
 static void mke2fs_error_msg_and_die(int retval, const char *fmt, ...)
 {
 	va_list ap;
@@ -184,7 +184,7 @@ static void mke2fs_error_msg_and_die(int retval, const char *fmt, ...)
 	}
 }
 
-static void mke2fs_verbose(const char *fmt, ...)__attribute__ ((format (printf, 1, 2)));
+static void mke2fs_verbose(const char *fmt, ...) __attribute__ ((format (printf, 1, 2)));
 static void mke2fs_verbose(const char *fmt, ...)
 {
 	va_list ap;
@@ -202,7 +202,7 @@ static void mke2fs_verbose_done(void)
 	mke2fs_verbose("done\n");
 }
 
-static void mke2fs_warning_msg(int retval, char *fmt, ... )__attribute__ ((format (printf, 2, 3)));
+static void mke2fs_warning_msg(int retval, char *fmt, ... ) __attribute__ ((format (printf, 2, 3)));
 static void mke2fs_warning_msg(int retval, char *fmt, ... )
 {
 	va_list ap;
diff --git a/include/libbb.h b/include/libbb.h
index bf6ae92..46860c6 100644
--- a/include/libbb.h
+++ b/include/libbb.h
@@ -780,6 +780,20 @@ extern void crypt_make_salt(char *p, int cnt);
 
 int get_terminal_width_height(const int fd, int *width, int *height);
 
+int ioctl_or_perror(int fd, int request, void *argp, const char *fmt,...) __attribute__ ((format (printf, 4, 5)));
+void ioctl_or_perror_and_die(int fd, int request, void *argp, const char *fmt,...) __attribute__ ((format (printf, 4, 5)));
+#if ENABLE_IOCTL_HEX2STR_ERROR
+int bb_ioctl_or_warn(int fd, int request, void *argp, const char *ioctl_name);
+void bb_xioctl(int fd, int request, void *argp, const char *ioctl_name);
+#define ioctl_or_warn(fd,request,argp) bb_ioctl_or_warn(fd,request,argp,#request)
+#define xioctl(fd,request,argp)        bb_xioctl(fd,request,argp,#request)
+#else
+int bb_ioctl_or_warn(int fd, int request, void *argp);
+void bb_xioctl(int fd, int request, void *argp);
+#define ioctl_or_warn(fd,request,argp) bb_ioctl_or_warn(fd,request,argp)
+#define xioctl(fd,request,argp)        bb_xioctl(fd,request,argp)
+#endif
+
 char *is_in_ino_dev_hashtable(const struct stat *statbuf);
 void add_to_ino_dev_hashtable(const struct stat *statbuf, const char *name);
 void reset_ino_dev_hashtable(void);
diff --git a/libbb/Config.in b/libbb/Config.in
index f82a2b1..5055015 100644
--- a/libbb/Config.in
+++ b/libbb/Config.in
@@ -120,4 +120,11 @@ config MONOTONIC_SYSCALL
 	  will be used instead (which gives wrong results if date/time
 	  is reset).
 
+config IOCTL_HEX2STR_ERROR
+	bool "Use ioctl names rather than hex values in error messages"
+	default y
+	help
+	  Use ioctl names rather than hex values in error messages
+	  (e.g. VT_DISALLOCATE rather than 0x5608). If disabled this
+	  saves about 1400 bytes.
 endmenu
diff --git a/libbb/xfuncs.c b/libbb/xfuncs.c
index d02ef9c..fad111a 100644
--- a/libbb/xfuncs.c
+++ b/libbb/xfuncs.c
@@ -639,3 +639,61 @@ int get_terminal_width_height(const int fd, int *width, int *height)
 
 	return ret;
 }
+
+void ioctl_or_perror_and_die(int fd, int request, void *argp, const char *fmt,...)
+{
+	va_list p;
+
+	if (ioctl(fd, request, argp) < 0) {
+		va_start(p, fmt);
+		bb_vperror_msg(fmt, p);
+		/* xfunc_die can actually longjmp, so be nice */
+		va_end(p);
+		xfunc_die();
+	}
+}
+
+int ioctl_or_perror(int fd, int request, void *argp, const char *fmt,...)
+{
+	va_list p;
+	int ret = ioctl(fd, request, argp);
+
+	if (ret < 0) {
+		va_start(p, fmt);
+		bb_vperror_msg(fmt, p);
+		va_end(p);
+	}
+	return ret;
+}
+
+#if ENABLE_IOCTL_HEX2STR_ERROR
+int bb_ioctl_or_warn(int fd, int request, void *argp, const char *ioctl_name)
+{
+	int ret;
+	
+	ret = ioctl(fd, request, argp);
+	if (ret < 0)
+		bb_perror_msg("%s", ioctl_name);
+	return ret;
+}
+void bb_xioctl(int fd, int request, void *argp, const char *ioctl_name)
+{
+	if (ioctl(fd, request, argp) < 0)
+		bb_perror_msg_and_die("%s", ioctl_name);
+}
+#else
+int bb_ioctl_or_warn(int fd, int request, void *argp)
+{
+	int ret;
+	
+	ret = ioctl(fd, request, argp);
+	if (ret < 0)
+		bb_perror_msg("ioctl %#x failed", request);
+	return ret;
+}
+void bb_xioctl(int fd, int request, void *argp)
+{
+	if (ioctl(fd, request, argp) < 0)
+		bb_perror_msg_and_die("ioctl %#x failed", request);
+}
+#endif
diff --git a/loginutils/getty.c b/loginutils/getty.c
index f969124..2fcb0d9 100644
--- a/loginutils/getty.c
+++ b/loginutils/getty.c
@@ -281,8 +281,7 @@ static void open_tty(const char *tty, struct termios *tp, int local)
 	 * 5 seconds seems to be a good value.
 	 */
 
-	if (ioctl(0, TCGETS, tp) < 0)
-		bb_perror_msg_and_die("%s: ioctl(TCGETS)", tty);
+	ioctl_or_perror_and_die(0, TCGETS, tp, "%s: TCGETS", tty);
 
 	/*
 	 * It seems to be a terminal. Set proper protections and ownership. Mode
@@ -647,8 +646,7 @@ static void termios_final(struct options *op, struct termios *tp, struct chardat
 
 	/* Finally, make the new settings effective */
 
-	if (ioctl(0, TCSETS, tp) < 0)
-		bb_perror_msg_and_die("%s: ioctl(TCSETS)", op->tty);
+	ioctl_or_perror_and_die(0, TCSETS, tp, "%s: TCSETS", op->tty);
 }
 
 
diff --git a/loginutils/vlock.c b/loginutils/vlock.c
index 7f614fc..665ebd8 100644
--- a/loginutils/vlock.c
+++ b/loginutils/vlock.c
@@ -62,9 +62,7 @@ int vlock_main(int argc, char **argv)
 
 	vfd = xopen(CURRENT_TTY, O_RDWR);
 
-	if (ioctl(vfd, VT_GETMODE, &vtm) < 0) {
-		bb_perror_msg_and_die("VT_GETMODE");
-	}
+	xioctl(vfd, VT_GETMODE, &vtm);
 
 	/* mask a bunch of signals */
 	sigprocmask(SIG_SETMASK, NULL, &sig);
diff --git a/miscutils/devfsd.c b/miscutils/devfsd.c
index 814fbd6..1dfbadf 100644
--- a/miscutils/devfsd.c
+++ b/miscutils/devfsd.c
@@ -234,7 +234,6 @@ static char get_old_ide_name(unsigned , unsigned);
 static char *write_old_sd_name(char *, unsigned, unsigned, const char *);
 
 /* busybox functions */
-static void do_ioctl_or_die(int fd, int request, unsigned long event_mask_flag);
 static int get_uid_gid(int flag, const char *string);
 static void safe_memcpy(char * dest, const char * src, int len);
 static unsigned int scan_dev_name_common(const char *d, unsigned int n, int addendum, const char *ptr);
@@ -298,12 +297,6 @@ static const char * const bb_msg_variable_not_found = "variable: %s not found";
 #define error_logger_and_die(p, fmt, args...)         exit(1)
 #endif
 
-static void do_ioctl_or_die(int fd, int request, unsigned long event_mask_flag)
-{
-	if (ioctl(fd, request, event_mask_flag) == -1)
-		msg_logger_and_die(LOG_ERR, "ioctl");
-}
-
 static void safe_memcpy(char *dest, const char *src, int len)
 {
 	memcpy(dest , src, len);
@@ -386,8 +379,7 @@ int devfsd_main(int argc, char **argv)
 	if (fcntl(fd, F_SETFD, FD_CLOEXEC) != 0)
 		bb_perror_msg_and_die("FD_CLOEXEC");
 
-	if (ioctl(fd, DEVFSDIOC_GET_PROTO_REV, &proto_rev) == -1)
-		bb_perror_msg_and_die("ioctl");
+	xioctl(fd, DEVFSDIOC_GET_PROTO_REV, &proto_rev);
 
 	/*setup initial entries */
 	for (curr = initial_symlinks; curr->dest != NULL; ++curr)
@@ -404,7 +396,7 @@ int devfsd_main(int argc, char **argv)
 		exit(EXIT_SUCCESS); /* -v */
 	}
 	/*  Tell kernel we are special(i.e. we get to see hidden entries)  */
-	do_ioctl_or_die(fd, DEVFSDIOC_SET_EVENT_MASK, 0);
+	xioctl(fd, DEVFSDIOC_SET_EVENT_MASK, 0);
 
 	sigemptyset(&new_action.sa_mask);
 	new_action.sa_flags = 0;
@@ -435,7 +427,7 @@ int devfsd_main(int argc, char **argv)
 
 	if (do_daemon) {
 		/*  Release so that the child can grab it  */
-		do_ioctl_or_die(fd, DEVFSDIOC_RELEASE_EVENT_QUEUE, 0);
+		xioctl(fd, DEVFSDIOC_RELEASE_EVENT_QUEUE, 0);
 		bb_daemonize_or_rexec(0, argv);
 	} else if (ENABLE_DEVFSD_FG_NP) {
 		setpgid(0, 0);  /*  Become process group leader                    */
@@ -661,7 +653,7 @@ static int do_servicing(int fd, unsigned long event_mask)
 
 	/*  Tell devfs what events we care about  */
 	tmp_event_mask = event_mask;
-	do_ioctl_or_die(fd, DEVFSDIOC_SET_EVENT_MASK, tmp_event_mask);
+	xioctl(fd, DEVFSDIOC_SET_EVENT_MASK, tmp_event_mask);
 	while (!caught_signal) {
 		errno = 0;
 		bytes = read(fd,(char *) &info, sizeof info);
diff --git a/miscutils/eject.c b/miscutils/eject.c
index 631a344..ba7da5c 100644
--- a/miscutils/eject.c
+++ b/miscutils/eject.c
@@ -50,9 +50,8 @@ int eject_main(int argc, char **argv)
 	if (flags & FLAG_CLOSE
 	 || (flags & FLAG_SMART && ioctl(dev, CDROM_DRIVE_STATUS) == CDS_TRAY_OPEN))
 		cmd = CDROMCLOSETRAY;
-	if (ioctl(dev, cmd)) {
-		bb_perror_msg_and_die("%s", device);
-	}
+
+	ioctl_or_perror_and_die(dev, cmd, NULL, "%s", device);
 
 	if (ENABLE_FEATURE_CLEAN_UP)
 		close(dev);
diff --git a/miscutils/hdparm.c b/miscutils/hdparm.c
index fe4c67a..5c7d1f6 100644
--- a/miscutils/hdparm.c
+++ b/miscutils/hdparm.c
@@ -200,8 +200,7 @@ static const char * const ata1_cfg_str[] = {			/* word 0 in ATA-1 mode */
 #define MULTIPLE_SETTING_VALID  0x0100  /* 1=multiple sector setting is valid */
 
 /* word 49: capabilities 0 */
-#define STD_STBY		0x2000  /* 1=standard values supported (ATA);
-					   0=vendor specific values */
+#define STD_STBY		0x2000  /* 1=standard values supported (ATA); 0=vendor specific values */
 #define IORDY_SUP		0x0800  /* 1=support; 0=may be supported */
 #define IORDY_OFF		0x0400  /* 1=may be disabled */
 #define LBA_SUP			0x0200  /* 1=Logical Block Address support */
@@ -442,25 +441,29 @@ static const char * const secu_str[] = {
 #undef DO_FLUSHCACHE            /* under construction: force cache flush on -W0 */
 
 /* Busybox messages and functions */
-static int bb_ioctl(int fd, int request, void *argp, const char *string)
+#if ENABLE_IOCTL_HEX2STR_ERROR
+static int ioctl_alt_func(int fd, int cmd, unsigned char *args, int alt, const char *string)
 {
-	int e = ioctl(fd, request, argp);
-	if (e && string)
-		bb_perror_msg(" %s", string);
-	return e;
+	if (!ioctl(fd, cmd, args))
+		return 0;
+	args[0] = alt;
+	return bb_ioctl_or_warn(fd, cmd, args, string);
 }
-
-static int bb_ioctl_alt(int fd, int cmd, unsigned char *args, int alt, const char *string)
+#define ioctl_alt_or_warn(fd,cmd,args,alt) ioctl_alt_func(fd,cmd,args,alt,#cmd)
+#else
+static int ioctl_alt_func(int fd, int cmd, unsigned char *args, int alt)
 {
 	if (!ioctl(fd, cmd, args))
 		return 0;
 	args[0] = alt;
-	return bb_ioctl(fd, cmd, args, string);
+	return bb_ioctl_or_warn(fd, cmd, args);
 }
+#define ioctl_alt_or_warn(fd,cmd,args,alt) ioctl_alt_func(fd,cmd,args,alt)
+#endif
 
 static void on_off(int value)
 {
-	printf(value ? " (on)\n" : " (off)\n");
+	puts(value ? " (on)" : " (off)");
 }
 
 static void print_flag_on_off(int get_arg, const char *s, unsigned long arg)
@@ -471,15 +474,10 @@ static void print_flag_on_off(int get_arg, const char *s, unsigned long arg)
 	}
 }
 
-static void bb_ioctl_on_off(int fd, int request, void *argp, const char *string,
-							 const char * str)
+static void print_value_on_off(const char *str, unsigned long argp)
 {
-	if (ioctl(fd, request, &argp) != 0)
-		bb_perror_msg(" %s", string);
-	else {
-		printf(" %s\t= %2ld", str, (unsigned long) argp);
-		on_off(((unsigned long) argp) != 0);
-	}
+	printf(" %s\t= %2ld", str, argp);
+	on_off(argp != 0);
 }
 
 #if ENABLE_FEATURE_HDPARM_GET_IDENTITY
@@ -1245,11 +1243,15 @@ static void dump_identity(const struct hd_driveid *id)
 static void flush_buffer_cache(int fd)
 {
 	fsync(fd);				/* flush buffers */
-	bb_ioctl(fd, BLKFLSBUF, NULL, "BLKFLSBUF"); /* do it again, big time */
+	ioctl_or_warn(fd, BLKFLSBUF, NULL); /* do it again, big time */
 #ifdef HDIO_DRIVE_CMD
 	sleep(1);
-	if (ioctl(fd, HDIO_DRIVE_CMD, NULL) && errno != EINVAL)	/* await completion */
-		bb_perror_msg("HDIO_DRIVE_CMD");
+	if (ioctl(fd, HDIO_DRIVE_CMD, NULL) && errno != EINVAL) {	/* await completion */
+		if (ENABLE_IOCTL_HEX2STR_ERROR) /* To be coherent with ioctl_or_warn */
+			bb_perror_msg("HDIO_DRIVE_CMD");
+		else
+			bb_perror_msg("ioctl %#x failed", HDIO_DRIVE_CMD);
+	}
 #endif
 }
 
@@ -1284,9 +1286,7 @@ static int do_blkgetsize(int fd, unsigned long long *blksize64)
 		*blksize64 /= 512;
 		return 0;
 	}
-	rc = ioctl(fd, BLKGETSIZE, &blksize32);	// returns sectors
-	if (rc)
-		bb_perror_msg("BLKGETSIZE");
+	rc = ioctl_or_warn(fd, BLKGETSIZE, &blksize32);	// returns sectors
 	*blksize64 = blksize32;
 	return rc;
 }
@@ -1516,12 +1516,12 @@ static void process_dev(char *devname)
 
 	if (set_readahead) {
 		print_flag(get_readahead, "fs readahead", Xreadahead);
-		bb_ioctl(fd, BLKRASET, (int *)Xreadahead, "BLKRASET");
+		ioctl_or_warn(fd, BLKRASET, (int *)Xreadahead);
 	}
 #if ENABLE_FEATURE_HDPARM_HDIO_UNREGISTER_HWIF
 	if (unregister_hwif) {
 		printf(" attempting to unregister hwif#%lu\n", hwif);
-		bb_ioctl(fd, HDIO_UNREGISTER_HWIF, (int *)(unsigned long)hwif, "HDIO_UNREGISTER_HWIF");
+		ioctl_or_warn(fd, HDIO_UNREGISTER_HWIF, (int *)(unsigned long)hwif);
 	}
 #endif
 #if ENABLE_FEATURE_HDPARM_HDIO_SCAN_HWIF
@@ -1530,7 +1530,7 @@ static void process_dev(char *devname)
 		args[0] = hwif_data;
 		args[1] = hwif_ctrl;
 		args[2] = hwif_irq;
-		bb_ioctl(fd, HDIO_SCAN_HWIF, args, "HDIO_SCAN_HWIF");
+		ioctl_or_warn(fd, HDIO_SCAN_HWIF, args);
 		args[0] = WIN_SETFEATURES;
 		args[1] = 0;
 	}
@@ -1547,70 +1547,70 @@ static void process_dev(char *devname)
 			else
 				printf("set UDMA mode to %d\n", (piomode-200));
 		}
-		bb_ioctl(fd, HDIO_SET_PIO_MODE, (int *)(unsigned long)piomode, "HDIO_SET_PIO_MODE");
+		ioctl_or_warn(fd, HDIO_SET_PIO_MODE, (int *)(unsigned long)piomode);
 	}
 	if (set_io32bit) {
 		print_flag(get_io32bit, "32-bit IO_support flag", io32bit);
-		bb_ioctl(fd, HDIO_SET_32BIT, (int *)io32bit, "HDIO_SET_32BIT");
+		ioctl_or_warn(fd, HDIO_SET_32BIT, (int *)io32bit);
 	}
 	if (set_mult) {
 		print_flag(get_mult, "multcount", mult);
 #ifdef HDIO_DRIVE_CMD
-		bb_ioctl(fd, HDIO_SET_MULTCOUNT, (void *)mult, "HDIO_SET_MULTCOUNT");
+		ioctl_or_warn(fd, HDIO_SET_MULTCOUNT, (void *)mult);
 #else
-		force_operation |= (!bb_ioctl(fd, HDIO_SET_MULTCOUNT, (void *)mult, "HDIO_SET_MULTCOUNT"));
+		force_operation |= (!ioctl_or_warn(fd, HDIO_SET_MULTCOUNT, (void *)mult));
 #endif
 	}
 	if (set_readonly) {
 		print_flag_on_off(get_readonly, "readonly", readonly);
-		bb_ioctl(fd, BLKROSET, &readonly, "BLKROSET");
+		ioctl_or_warn(fd, BLKROSET, &readonly);
 	}
 	if (set_unmask) {
 		print_flag_on_off(get_unmask, "unmaskirq", unmask);
-		bb_ioctl(fd, HDIO_SET_UNMASKINTR, (int *)unmask, "HDIO_SET_UNMASKINTR");
+		ioctl_or_warn(fd, HDIO_SET_UNMASKINTR, (int *)unmask);
 	}
 #if ENABLE_FEATURE_HDPARM_HDIO_GETSET_DMA
 	if (set_dma) {
 		print_flag_on_off(get_dma, "using_dma", dma);
-		bb_ioctl(fd, HDIO_SET_DMA, (int *)dma, "HDIO_SET_DMA");
+		ioctl_or_warn(fd, HDIO_SET_DMA, (int *)dma);
 	}
 #endif /* FEATURE_HDPARM_HDIO_GETSET_DMA */
 	if (set_dma_q) {
 		print_flag_on_off(get_dma_q, "DMA queue_depth", dma_q);
-		bb_ioctl(fd, HDIO_SET_QDMA, (int *)dma_q, "HDIO_SET_QDMA");
+		ioctl_or_warn(fd, HDIO_SET_QDMA, (int *)dma_q);
 	}
 	if (set_nowerr) {
 		print_flag_on_off(get_nowerr, "nowerr", nowerr);
-		bb_ioctl(fd, HDIO_SET_NOWERR, (int *)nowerr, "HDIO_SET_NOWERR");
+		ioctl_or_warn(fd, HDIO_SET_NOWERR, (int *)nowerr);
 	}
 	if (set_keep) {
 		print_flag_on_off(get_keep, "keep_settings", keep);
-		bb_ioctl(fd, HDIO_SET_KEEPSETTINGS, (int *)keep, "HDIO_SET_KEEPSETTINGS");
+		ioctl_or_warn(fd, HDIO_SET_KEEPSETTINGS, (int *)keep);
 	}
 #ifdef HDIO_DRIVE_CMD
 	if (set_doorlock) {
 		args[0] = doorlock ? WIN_DOORLOCK : WIN_DOORUNLOCK;
 		args[2] = 0;
 		print_flag_on_off(get_doorlock, "drive doorlock", doorlock);
-		bb_ioctl(fd, HDIO_DRIVE_CMD, &args, "HDIO_DRIVE_CMD(doorlock)");
+		ioctl_or_warn(fd, HDIO_DRIVE_CMD, &args);
 		args[0] = WIN_SETFEATURES;
 	}
 	if (set_dkeep) {
 		/* lock/unlock the drive's "feature" settings */
 		print_flag_on_off(get_dkeep, "drive keep features", dkeep);
 		args[2] = dkeep ? 0x66 : 0xcc;
-		bb_ioctl(fd, HDIO_DRIVE_CMD, &args, "HDIO_DRIVE_CMD(keepsettings)");
+		ioctl_or_warn(fd, HDIO_DRIVE_CMD, &args);
 	}
 	if (set_defects) {
 		args[2] = defects ? 0x04 : 0x84;
 		print_flag(get_defects, "drive defect-mgmt", defects);
-		bb_ioctl(fd, HDIO_DRIVE_CMD, &args, "HDIO_DRIVE_CMD(defectmgmt)");
+		ioctl_or_warn(fd, HDIO_DRIVE_CMD, &args);
 	}
 	if (set_prefetch) {
 		args[1] = prefetch;
 		args[2] = 0xab;
 		print_flag(get_prefetch, "drive prefetch", prefetch);
-		bb_ioctl(fd, HDIO_DRIVE_CMD, &args, "HDIO_DRIVE_CMD(setprefetch)");
+		ioctl_or_warn(fd, HDIO_DRIVE_CMD, &args);
 		args[1] = 0;
 	}
 	if (set_xfermode) {
@@ -1620,20 +1620,20 @@ static void process_dev(char *devname)
 			print_flag(1, "xfermode", xfermode_requested);
 			interpret_xfermode(xfermode_requested);
 		}
-		bb_ioctl(fd, HDIO_DRIVE_CMD, &args, "HDIO_DRIVE_CMD(setxfermode)");
+		ioctl_or_warn(fd, HDIO_DRIVE_CMD, &args);
 		args[1] = 0;
 	}
 	if (set_lookahead) {
 		args[2] = lookahead ? 0xaa : 0x55;
 		print_flag_on_off(get_lookahead, "drive read-lookahead", lookahead);
-		bb_ioctl(fd, HDIO_DRIVE_CMD, &args, "HDIO_DRIVE_CMD(setreadahead)");
+		ioctl_or_warn(fd, HDIO_DRIVE_CMD, &args);
 	}
 	if (set_apmmode) {
 		args[2] = (apmmode == 255) ? 0x85 /* disable */ : 0x05 /* set */; /* feature register */
 		args[1] = apmmode; /* sector count register 1-255 */
 		if (get_apmmode)
 			printf(" setting APM level to %s 0x%02lX (%ld)\n", (apmmode == 255) ? "disabled" : "", apmmode, apmmode);
-		bb_ioctl(fd, HDIO_DRIVE_CMD, &args, "HDIO_DRIVE_CMD");
+		ioctl_or_warn(fd, HDIO_DRIVE_CMD, &args);
 		args[1] = 0;
 	}
 	if (set_wcache)	{
@@ -1647,12 +1647,12 @@ static void process_dev(char *devname)
 		print_flag_on_off(get_wcache, "drive write-caching", wcache);
 #ifdef DO_FLUSHCACHE
 		if (!wcache)
-			bb_ioctl(fd, HDIO_DRIVE_CMD, &flushcache, "HDIO_DRIVE_CMD(flushcache)");
+			ioctl_or_warn(fd, HDIO_DRIVE_CMD, &flushcache);
 #endif /* DO_FLUSHCACHE */
-		bb_ioctl(fd, HDIO_DRIVE_CMD, &args, "HDIO_DRIVE_CMD(setcache)");
+		ioctl_or_warn(fd, HDIO_DRIVE_CMD, &args);
 #ifdef DO_FLUSHCACHE
 		if (!wcache)
-			bb_ioctl(fd, HDIO_DRIVE_CMD, &flushcache, "HDIO_DRIVE_CMD(flushcache)");
+			ioctl_or_warn(fd, HDIO_DRIVE_CMD, &flushcache);
 #endif /* DO_FLUSHCACHE */
 	}
 
@@ -1669,7 +1669,7 @@ static void process_dev(char *devname)
 #endif
 		if (get_standbynow) printf(" issuing standby command\n");
 		args[0] = WIN_STANDBYNOW1;
-		bb_ioctl_alt(fd, HDIO_DRIVE_CMD, args, WIN_STANDBYNOW2, "HDIO_DRIVE_CMD(standby)");
+		ioctl_alt_or_warn(fd, HDIO_DRIVE_CMD, args, WIN_STANDBYNOW2);
 	}
 	if (set_sleepnow) {
 #ifndef WIN_SLEEPNOW1
@@ -1680,12 +1680,12 @@ static void process_dev(char *devname)
 #endif
 		if (get_sleepnow) printf(" issuing sleep command\n");
 		args[0] = WIN_SLEEPNOW1;
-		bb_ioctl_alt(fd, HDIO_DRIVE_CMD, args, WIN_SLEEPNOW2, "HDIO_DRIVE_CMD(sleep)");
+		ioctl_alt_or_warn(fd, HDIO_DRIVE_CMD, args, WIN_SLEEPNOW2);
 	}
 	if (set_seagate) {
 		args[0] = 0xfb;
 		if (get_seagate) printf(" disabling Seagate auto powersaving mode\n");
-		bb_ioctl(fd, HDIO_DRIVE_CMD, &args, "HDIO_DRIVE_CMD(seagatepwrsave)");
+		ioctl_or_warn(fd, HDIO_DRIVE_CMD, &args);
 	}
 	if (set_standby) {
 		args[0] = WIN_SETIDLE1;
@@ -1694,7 +1694,7 @@ static void process_dev(char *devname)
 			print_flag(1, "standby", standby_requested);
 			interpret_standby(standby_requested);
 		}
-		bb_ioctl(fd, HDIO_DRIVE_CMD, &args, "HDIO_DRIVE_CMD(setidle1)");
+		ioctl_or_warn(fd, HDIO_DRIVE_CMD, &args);
 		args[1] = 0;
 	}
 #else	/* HDIO_DRIVE_CMD */
@@ -1709,15 +1709,17 @@ static void process_dev(char *devname)
 	if (get_mult || get_identity) {
 		multcount = -1;
 		if (ioctl(fd, HDIO_GET_MULTCOUNT, &multcount)) {
-			if (get_mult)
+			if (get_mult && ENABLE_IOCTL_HEX2STR_ERROR) /* To be coherent with ioctl_or_warn. */
 				bb_perror_msg("HDIO_GET_MULTCOUNT");
+			else
+				bb_perror_msg("ioctl %#x failed", HDIO_GET_MULTCOUNT);
 		} else if (get_mult) {
 			printf(fmt, "multcount", multcount);
 			on_off(multcount != 0);
 		}
 	}
 	if (get_io32bit) {
-		if (!bb_ioctl(fd, HDIO_GET_32BIT, &parm, "HDIO_GET_32BIT")) {
+		if (!ioctl_or_warn(fd, HDIO_GET_32BIT, &parm)) {
 			printf(" IO_support\t=%3ld (", parm);
 			if (parm == 0)
 				printf("default 16-bit)\n");
@@ -1734,14 +1736,14 @@ static void process_dev(char *devname)
 		}
 	}
 	if (get_unmask) {
-		bb_ioctl_on_off(fd, HDIO_GET_UNMASKINTR, (unsigned long *)parm,
-					"HDIO_GET_UNMASKINTR", "unmaskirq");
+		if(!ioctl_or_warn(fd, HDIO_GET_UNMASKINTR, (unsigned long *)parm))
+			print_value_on_off("unmaskirq", parm);
 	}
 
 
 #if ENABLE_FEATURE_HDPARM_HDIO_GETSET_DMA
 	if (get_dma) {
-		if (!bb_ioctl(fd, HDIO_GET_DMA, &parm, "HDIO_GET_DMA")) {
+		if (!ioctl_or_warn(fd, HDIO_GET_DMA, &parm)) {
 			printf(fmt, "using_dma", parm);
 			if (parm == 8)
 				printf(" (DMA-Assisted-PIO)\n");
@@ -1751,31 +1753,31 @@ static void process_dev(char *devname)
 	}
 #endif
 	if (get_dma_q) {
-		bb_ioctl_on_off(fd, HDIO_GET_QDMA, (unsigned long *)parm,
-						"HDIO_GET_QDMA", "queue_depth");
+		if(!ioctl_or_warn(fd, HDIO_GET_QDMA, (unsigned long *)parm))
+			print_value_on_off("queue_depth", parm);
 	}
 	if (get_keep) {
-		bb_ioctl_on_off(fd, HDIO_GET_KEEPSETTINGS, (unsigned long *)parm,
-						"HDIO_GET_KEEPSETTINGS", "keepsettings");
+		if(!ioctl_or_warn(fd, HDIO_GET_KEEPSETTINGS, (unsigned long *)parm))
+			print_value_on_off("keepsettings", parm);
 	}
 
 	if (get_nowerr) {
-		bb_ioctl_on_off(fd, HDIO_GET_NOWERR, (unsigned long *)&parm,
-						"HDIO_GET_NOWERR", "nowerr");
+		if(!ioctl_or_warn(fd, HDIO_GET_NOWERR, (unsigned long *)parm))
+			print_value_on_off("nowerr", parm);
 	}
 	if (get_readonly) {
-		bb_ioctl_on_off(fd, BLKROGET, (unsigned long *)parm,
-						"BLKROGET", "readonly");
+		if(!ioctl_or_warn(fd, BLKROGET, (unsigned long *)parm))
+			print_value_on_off("readonly", parm);
 	}
 	if (get_readahead) {
-		bb_ioctl_on_off(fd, BLKRAGET, (unsigned long *) parm,
-						"BLKRAGET", "readahead");
+		if(!ioctl_or_warn(fd, BLKRAGET, (unsigned long *)parm))
+			print_value_on_off("readahead", parm);
 	}
 	if (get_geom) {
-		if (!bb_ioctl(fd, BLKGETSIZE, &parm, "BLKGETSIZE")) {
+		if (!ioctl_or_warn(fd, BLKGETSIZE, &parm)) {
 			struct hd_geometry g;
 
-			if (!bb_ioctl(fd, HDIO_GETGEO, &g, "HDIO_GETGEO"))
+			if (!ioctl_or_warn(fd, HDIO_GETGEO, &g))
 				printf(" geometry\t= %u/%u/%u, sectors = %ld, start = %ld\n",
 						g.cylinders, g.heads, g.sectors, parm, g.start);
 		}
@@ -1791,7 +1793,7 @@ static void process_dev(char *devname)
 		const char *state;
 
 		args[0] = WIN_CHECKPOWERMODE1;
-		if (bb_ioctl_alt(fd, HDIO_DRIVE_CMD, args, WIN_CHECKPOWERMODE2, 0)) {
+		if (ioctl_alt_or_warn(fd, HDIO_DRIVE_CMD, args, WIN_CHECKPOWERMODE2)) {
 			if (errno != EIO || args[0] != 0 || args[1] != 0)
 				state = "unknown";
 			else
@@ -1805,14 +1807,14 @@ static void process_dev(char *devname)
 #endif
 #if ENABLE_FEATURE_HDPARM_HDIO_DRIVE_RESET
 	if (perform_reset) {
-		bb_ioctl(fd, HDIO_DRIVE_RESET, NULL, "HDIO_DRIVE_RESET");
+		ioctl_or_warn(fd, HDIO_DRIVE_RESET, NULL);
 	}
 #endif /* FEATURE_HDPARM_HDIO_DRIVE_RESET */
 #if ENABLE_FEATURE_HDPARM_HDIO_TRISTATE_HWIF
 	if (perform_tristate) {
 		args[0] = 0;
 		args[1] = tristate;
-		bb_ioctl(fd, HDIO_TRISTATE_HWIF, &args, "HDIO_TRISTATE_HWIF");
+		ioctl_or_warn(fd, HDIO_TRISTATE_HWIF, &args);
 	}
 #endif /* FEATURE_HDPARM_HDIO_TRISTATE_HWIF */
 #if ENABLE_FEATURE_HDPARM_GET_IDENTITY
@@ -1828,8 +1830,10 @@ static void process_dev(char *devname)
 			dump_identity(&id);
 		} else if (errno == -ENOMSG)
 			printf(" no identification info available\n");
+		else if (ENABLE_IOCTL_HEX2STR_ERROR)  /* To be coherent with ioctl_or_warn */
+			bb_perror_msg("HDIO_GET_IDENTITY"); 
 		else
-			bb_perror_msg("HDIO_GET_IDENTITY");
+			bb_perror_msg("ioctl %#x failed", HDIO_GET_IDENTITY);
 	}
 
 	if (get_IDentity) {
@@ -1838,7 +1842,7 @@ static void process_dev(char *devname)
 		memset(args1, 0, sizeof(args1));
 		args1[0] = WIN_IDENTIFY;
 		args1[3] = 1;
-		if (!bb_ioctl_alt(fd, HDIO_DRIVE_CMD, args1, WIN_PIDENTIFY, "HDIO_DRIVE_CMD(identify)"))
+		if (!ioctl_alt_or_warn(fd, HDIO_DRIVE_CMD, args1, WIN_PIDENTIFY))
 			identify((void *)(args1 + 4));
 	}
 #endif
@@ -1848,17 +1852,17 @@ static void process_dev(char *devname)
 			print_flag(1, "bus state", busstate);
 			bus_state_value(busstate);
 		}
-		bb_ioctl(fd, HDIO_SET_BUSSTATE, (int *)(unsigned long)busstate, "HDIO_SET_BUSSTATE");
+		ioctl_or_warn(fd, HDIO_SET_BUSSTATE, (int *)(unsigned long)busstate);
 	}
 	if (get_busstate) {
-		if (!bb_ioctl(fd, HDIO_GET_BUSSTATE, &parm, "HDIO_GET_BUSSTATE")) {
+		if (!ioctl_or_warn(fd, HDIO_GET_BUSSTATE, &parm)) {
 			printf(fmt, "bus state", parm);
 			bus_state_value(parm);
 		}
 	}
 #endif
 	if (reread_partn)
-		bb_ioctl(fd, BLKRRPART, NULL, "BLKRRPART");
+		ioctl_or_warn(fd, BLKRRPART, NULL);
 
 	if (do_ctimings)
 		do_time(0, fd); /* time cache */
diff --git a/miscutils/mt.c b/miscutils/mt.c
index 2971421..b9bc2a1 100644
--- a/miscutils/mt.c
+++ b/miscutils/mt.c
@@ -106,14 +106,12 @@ int mt_main(int argc, char **argv)
 
 	switch (code->value) {
 		case MTTELL:
-			if (ioctl(fd, MTIOCPOS, &position) < 0)
-				bb_perror_msg_and_die("%s", file);
+			ioctl_or_perror_and_die(fd, MTIOCPOS, &position, "%s", file);
 			printf("At block %d.\n", (int) position.mt_blkno);
 			break;
 
 		default:
-			if (ioctl(fd, MTIOCTOP, &op) != 0)
-				bb_perror_msg_and_die("%s", file);
+			ioctl_or_perror_and_die(fd, MTIOCTOP, &op, "%s", file);
 			break;
 	}
 
diff --git a/miscutils/raidautorun.c b/miscutils/raidautorun.c
index 2b65d39..edcb6d6 100644
--- a/miscutils/raidautorun.c
+++ b/miscutils/raidautorun.c
@@ -19,9 +19,7 @@ int raidautorun_main(int argc, char **argv)
 	if (argc != 2)
 		bb_show_usage();
 
-	if (ioctl(xopen(argv[1], O_RDONLY), RAID_AUTORUN, NULL) != 0) {
-		bb_perror_msg_and_die("ioctl");
-	}
+	xioctl(xopen(argv[1], O_RDONLY), RAID_AUTORUN, NULL);
 
 	return EXIT_SUCCESS;
 }
diff --git a/networking/arp.c b/networking/arp.c
index 6a7c862..e529257 100644
--- a/networking/arp.c
+++ b/networking/arp.c
@@ -188,9 +188,8 @@ static void arp_getdevhw(char *ifname, struct sockaddr *sa,
 	const struct hwtype *xhw;
 
 	strcpy(ifr.ifr_name, ifname);
-	if (ioctl(sockfd, SIOCGIFHWADDR, &ifr) < 0) {
-		bb_perror_msg_and_die("cant get HW-Address for '%s'", ifname);
-	}
+	ioctl_or_perror_and_die(sockfd, SIOCGIFHWADDR, &ifr,
+					"cant get HW-Address for '%s'", ifname);
 	if (hwt && (ifr.ifr_hwaddr.sa_family != hw->type)) {
 		bb_error_msg_and_die("protocol type mismatch");
 	}
@@ -306,9 +305,7 @@ static int arp_set(char **args)
 	/* Call the kernel. */
 	if (option_mask32 & ARP_OPT_v)
 		bb_error_msg("SIOCSARP()");
-	if (ioctl(sockfd, SIOCSARP, &req) < 0) {
-		bb_perror_msg_and_die("SIOCSARP");
-	}
+	xioctl(sockfd, SIOCSARP, &req);
 	return 0;
 }
 
diff --git a/networking/arping.c b/networking/arping.c
index 7a9fbc2..8e457b1 100644
--- a/networking/arping.c
+++ b/networking/arping.c
@@ -273,14 +273,11 @@ int arping_main(int argc, char **argv)
 
 		memset(&ifr, 0, sizeof(ifr));
 		strncpy(ifr.ifr_name, device, IFNAMSIZ - 1);
-		if (ioctl(sock, SIOCGIFINDEX, &ifr) < 0) {
-			bb_error_msg_and_die("interface %s not found", device);
-		}
+		ioctl_or_perror_and_die(sock, SIOCGIFINDEX, &ifr, "interface %s not found", device);
 		ifindex = ifr.ifr_ifindex;
 
-		if (ioctl(sock, SIOCGIFFLAGS, (char *) &ifr)) {
-			bb_error_msg_and_die("SIOCGIFFLAGS");
-		}
+		xioctl(sock, SIOCGIFFLAGS, (char *) &ifr);
+
 		if (!(ifr.ifr_flags & IFF_UP)) {
 			bb_error_msg_and_die("interface %s is down", device);
 		}
diff --git a/networking/ether-wake.c b/networking/ether-wake.c
index 9de0d48..b67e1b5 100644
--- a/networking/ether-wake.c
+++ b/networking/ether-wake.c
@@ -220,8 +220,7 @@ int ether_wake_main(int argc, char **argv)
 		struct ifreq if_hwaddr;
 
 		strncpy(if_hwaddr.ifr_name, ifname, sizeof(if_hwaddr.ifr_name));
-		if (ioctl(s, SIOCGIFHWADDR, &if_hwaddr) != 0)
-			bb_perror_msg_and_die("SIOCGIFHWADDR on %s failed", ifname);
+		ioctl_or_perror_and_die(s, SIOCGIFHWADDR, &if_hwaddr, "SIOCGIFHWADDR on %s failed", ifname);
 
 		memcpy(outpack+6, if_hwaddr.ifr_hwaddr.sa_data, 6);
 
@@ -257,8 +256,7 @@ int ether_wake_main(int argc, char **argv)
 	{
 		struct ifreq ifr;
 		strncpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name));
-		if (ioctl(s, SIOCGIFINDEX, &ifr) != 0)
-			bb_perror_msg_and_die("SIOCGIFINDEX");
+		xioctl(s, SIOCGIFINDEX, &ifr);
 		memset(&whereto, 0, sizeof(whereto));
 		whereto.sll_family = AF_PACKET;
 		whereto.sll_ifindex = ifr.ifr_ifindex;
diff --git a/networking/ifconfig.c b/networking/ifconfig.c
index 5e11b2b..0d53676 100644
--- a/networking/ifconfig.c
+++ b/networking/ifconfig.c
@@ -402,12 +402,10 @@ int ifconfig_main(int argc, char **argv)
 
 								/* Create a channel to the NET kernel. */
 								sockfd6 = xsocket(AF_INET6, SOCK_DGRAM, 0);
-								if (ioctl(sockfd6, SIOGIFINDEX, &ifr) < 0)
-									bb_perror_msg_and_die("SIOGIFINDEX");
+								xioctl(sockfd6, SIOGIFINDEX, &ifr);
 								ifr6.ifr6_ifindex = ifr.ifr_ifindex;
 								ifr6.ifr6_prefixlen = prefix_len;
-								if (ioctl(sockfd6, a1op->selector, &ifr6) < 0)
-									bb_perror_msg_and_die(a1op->name);
+								ioctl_or_perror_and_die(sockfd6, a1op->selector, &ifr6, "%s", a1op->name);
 								if (ENABLE_FEATURE_CLEAN_UP)
 									free(lsa);
 								continue;
@@ -444,8 +442,7 @@ int ifconfig_main(int argc, char **argv)
 					p = ((char *)&ifr) + a1op->ifr_offset;
 #if ENABLE_FEATURE_IFCONFIG_MEMSTART_IOADDR_IRQ
 					if (mask & A_MAP_TYPE) {
-						if (ioctl(sockfd, SIOCGIFMAP, &ifr) < 0)
-							bb_perror_msg_and_die("SIOCGIFMAP");
+						xioctl(sockfd, SIOCGIFMAP, &ifr);
 						if ((mask & A_MAP_UCHAR) == A_MAP_UCHAR)
 							*((unsigned char *) p) = i;
 						else if (mask & A_MAP_USHORT)
@@ -460,8 +457,7 @@ int ifconfig_main(int argc, char **argv)
 						*((int *) p) = i;
 				}
 
-				if (ioctl(sockfd, a1op->selector, &ifr) < 0)
-					bb_perror_msg_and_die(a1op->name);
+				ioctl_or_perror_and_die(sockfd, a1op->selector, &ifr, "%s", a1op->name);
 #ifdef QUESTIONABLE_ALIAS_CASE
 				if (mask & A_COLON_CHK) {
 					/*
@@ -486,15 +482,13 @@ int ifconfig_main(int argc, char **argv)
 			mask = N_SET;
 		}
 
-		if (ioctl(sockfd, SIOCGIFFLAGS, &ifr) < 0)
-			bb_perror_msg_and_die("SIOCGIFFLAGS");
+		xioctl(sockfd, SIOCGIFFLAGS, &ifr);
 		selector = op->selector;
 		if (mask & SET_MASK)
 			ifr.ifr_flags |= selector;
 		else
 			ifr.ifr_flags &= ~selector;
-		if (ioctl(sockfd, SIOCSIFFLAGS, &ifr) < 0)
-			bb_perror_msg_and_die("SIOCSIFFLAGS");
+		xioctl(sockfd, SIOCSIFFLAGS, &ifr);
 	} /* while () */
 
 	if (ENABLE_FEATURE_CLEAN_UP)
diff --git a/networking/interface.c b/networking/interface.c
index 204febf..ea02f4c 100644
--- a/networking/interface.c
+++ b/networking/interface.c
@@ -521,8 +521,7 @@ static int if_readconf(void)
 		ifc.ifc_len = sizeof(struct ifreq) * numreqs;
 		ifc.ifc_buf = xrealloc(ifc.ifc_buf, ifc.ifc_len);
 
-		if (ioctl(skfd, SIOCGIFCONF, &ifc) < 0) {
-			bb_perror_msg("SIOCGIFCONF");
+		if (ioctl_or_warn(skfd, SIOCGIFCONF, &ifc) < 0) {
 			goto out;
 		}
 		if (ifc.ifc_len == sizeof(struct ifreq) * numreqs) {
diff --git a/networking/libiproute/ipaddress.c b/networking/libiproute/ipaddress.c
index a4add6a..fc10ba3 100644
--- a/networking/libiproute/ipaddress.c
+++ b/networking/libiproute/ipaddress.c
@@ -84,8 +84,7 @@ static void print_queuelen(char *name)
 
 	memset(&ifr, 0, sizeof(ifr));
 	strncpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
-	if (ioctl(s, SIOCGIFTXQLEN, &ifr) < 0) {
-		bb_perror_msg("SIOCGIFXQLEN");
+	if (ioctl_or_warn(s, SIOCGIFTXQLEN, &ifr) < 0) {
 		close(s);
 		return;
 	}
diff --git a/networking/libiproute/iplink.c b/networking/libiproute/iplink.c
index 7db4d7e..3d3ea2a 100644
--- a/networking/libiproute/iplink.c
+++ b/networking/libiproute/iplink.c
@@ -49,14 +49,11 @@ static void do_chflags(char *dev, uint32_t flags, uint32_t mask)
 
 	strncpy(ifr.ifr_name, dev, sizeof(ifr.ifr_name));
 	fd = get_ctl_fd();
-	if (ioctl(fd, SIOCGIFFLAGS, &ifr)) {
-		bb_perror_msg_and_die("SIOCGIFFLAGS");
-	}
+	xioctl(fd, SIOCGIFFLAGS, &ifr);
 	if ((ifr.ifr_flags ^ flags) & mask) {
 		ifr.ifr_flags &= ~mask;
 		ifr.ifr_flags |= mask & flags;
-		if (ioctl(fd, SIOCSIFFLAGS, &ifr))
-			bb_perror_msg_and_die("SIOCSIFFLAGS");
+		xioctl(fd, SIOCSIFFLAGS, &ifr);
 	}
 	close(fd);
 }
@@ -66,15 +63,11 @@ static void do_changename(char *dev, char *newdev)
 {
 	struct ifreq ifr;
 	int fd;
-	int err;
 
 	strncpy(ifr.ifr_name, dev, sizeof(ifr.ifr_name));
 	strncpy(ifr.ifr_newname, newdev, sizeof(ifr.ifr_newname));
 	fd = get_ctl_fd();
-	err = ioctl(fd, SIOCSIFNAME, &ifr);
-	if (err) {
-		bb_perror_msg_and_die("SIOCSIFNAME");
-	}
+	xioctl(fd, SIOCSIFNAME, &ifr);
 	close(fd);
 }
 
@@ -88,9 +81,7 @@ static void set_qlen(char *dev, int qlen)
 	memset(&ifr, 0, sizeof(ifr));
 	strncpy(ifr.ifr_name, dev, sizeof(ifr.ifr_name));
 	ifr.ifr_qlen = qlen;
-	if (ioctl(s, SIOCSIFTXQLEN, &ifr) < 0) {
-		bb_perror_msg_and_die("SIOCSIFXQLEN");
-	}
+	xioctl(s, SIOCSIFTXQLEN, &ifr);
 	close(s);
 }
 
@@ -104,9 +95,7 @@ static void set_mtu(char *dev, int mtu)
 	memset(&ifr, 0, sizeof(ifr));
 	strncpy(ifr.ifr_name, dev, sizeof(ifr.ifr_name));
 	ifr.ifr_mtu = mtu;
-	if (ioctl(s, SIOCSIFMTU, &ifr) < 0) {
-		bb_perror_msg_and_die("SIOCSIFMTU");
-	}
+	xioctl(s, SIOCSIFMTU, &ifr);
 	close(s);
 }
 
@@ -122,9 +111,7 @@ static int get_address(char *dev, int *htype)
 
 	memset(&ifr, 0, sizeof(ifr));
 	strncpy(ifr.ifr_name, dev, sizeof(ifr.ifr_name));
-	if (ioctl(s, SIOCGIFINDEX, &ifr) < 0) {
-		bb_perror_msg_and_die("SIOCGIFINDEX");
-	}
+	xioctl(s, SIOCGIFINDEX, &ifr);
 
 	memset(&me, 0, sizeof(me));
 	me.sll_family = AF_PACKET;
@@ -163,9 +150,10 @@ static void set_address(struct ifreq *ifr, int brd)
 	int s;
 
 	s = get_ctl_fd();
-	if (ioctl(s, brd ? SIOCSIFHWBROADCAST  :SIOCSIFHWADDR, ifr) < 0) {
-		bb_perror_msg_and_die(brd ? "SIOCSIFHWBROADCAST" : "SIOCSIFHWADDR");
-	}
+	if (brd)
+		xioctl(s, SIOCSIFHWBROADCAST, ifr);
+	else
+		xioctl(s, SIOCSIFHWADDR, ifr);
 	close(s);
 }
 
diff --git a/networking/libiproute/iptunnel.c b/networking/libiproute/iptunnel.c
index b12bceb..90d0e11 100644
--- a/networking/libiproute/iptunnel.c
+++ b/networking/libiproute/iptunnel.c
@@ -14,8 +14,6 @@
  * Phil Karn <karn@ka9q.ampr.org>	990408:	"pmtudisc" flag
  */
 
-//#include <sys/socket.h>
-//#include <sys/ioctl.h>
 #include <netinet/ip.h>
 #include <net/if.h>
 #include <net/if_arp.h>
@@ -38,9 +36,7 @@ static int do_ioctl_get_ifindex(char *dev)
 
 	strncpy(ifr.ifr_name, dev, sizeof(ifr.ifr_name));
 	fd = xsocket(AF_INET, SOCK_DGRAM, 0);
-	if (ioctl(fd, SIOCGIFINDEX, &ifr)) {
-		bb_perror_msg_and_die("SIOCGIFINDEX");
-	}
+	xioctl(fd, SIOCGIFINDEX, &ifr);
 	close(fd);
 	return ifr.ifr_ifindex;
 }
@@ -49,30 +45,26 @@ static int do_ioctl_get_iftype(char *dev)
 {
 	struct ifreq ifr;
 	int fd;
+	int err;
 
 	strncpy(ifr.ifr_name, dev, sizeof(ifr.ifr_name));
 	fd = xsocket(AF_INET, SOCK_DGRAM, 0);
-	if (ioctl(fd, SIOCGIFHWADDR, &ifr)) {
-		bb_perror_msg("SIOCGIFHWADDR");
-		return -1;
-	}
+	err = ioctl_or_warn(fd, SIOCGIFHWADDR, &ifr);
 	close(fd);
-	return ifr.ifr_addr.sa_family;
+	return err ? -1 : ifr.ifr_addr.sa_family;
 }
 
 static char *do_ioctl_get_ifname(int idx)
 {
 	struct ifreq ifr;
 	int fd;
+	int err;
 
 	ifr.ifr_ifindex = idx;
 	fd = xsocket(AF_INET, SOCK_DGRAM, 0);
-	if (ioctl(fd, SIOCGIFNAME, &ifr)) {
-		bb_perror_msg("SIOCGIFNAME");
-		return NULL;
-	}
+	err = ioctl_or_warn(fd, SIOCGIFNAME, &ifr);
 	close(fd);
-	return xstrndup(ifr.ifr_name, sizeof(ifr.ifr_name));
+	return err ? NULL : xstrndup(ifr.ifr_name, sizeof(ifr.ifr_name));
 }
 
 static int do_get_ioctl(const char *basedev, struct ip_tunnel_parm *p)
@@ -84,10 +76,7 @@ static int do_get_ioctl(const char *basedev, struct ip_tunnel_parm *p)
 	strncpy(ifr.ifr_name, basedev, sizeof(ifr.ifr_name));
 	ifr.ifr_ifru.ifru_data = (void*)p;
 	fd = xsocket(AF_INET, SOCK_DGRAM, 0);
-	err = ioctl(fd, SIOCGETTUNNEL, &ifr);
-	if (err) {
-		bb_perror_msg("SIOCGETTUNNEL");
-	}
+	err = ioctl_or_warn(fd, SIOCGETTUNNEL, &ifr);
 	close(fd);
 	return err;
 }
@@ -105,9 +94,15 @@ static int do_add_ioctl(int cmd, const char *basedev, struct ip_tunnel_parm *p)
 	}
 	ifr.ifr_ifru.ifru_data = (void*)p;
 	fd = xsocket(AF_INET, SOCK_DGRAM, 0);
-	if (ioctl(fd, cmd, &ifr)) {
-		bb_perror_msg_and_die("ioctl");
-	}
+#if ENABLE_IOCTL_HEX2STR_ERROR
+	/* #define magic will turn ioctl# into string */
+	if (cmd == SIOCCHGTUNNEL)
+		xioctl(fd, SIOCCHGTUNNEL, &ifr);
+	else
+		xioctl(fd, SIOCADDTUNNEL, &ifr);
+#else
+	xioctl(fd, cmd, &ifr);
+#endif
 	close(fd);
 	return 0;
 }
@@ -125,9 +120,7 @@ static int do_del_ioctl(const char *basedev, struct ip_tunnel_parm *p)
 	}
 	ifr.ifr_ifru.ifru_data = (void*)p;
 	fd = xsocket(AF_INET, SOCK_DGRAM, 0);
-	if (ioctl(fd, SIOCDELTUNNEL, &ifr)) {
-		bb_perror_msg_and_die("SIOCDELTUNNEL");
-	}
+	xioctl(fd, SIOCDELTUNNEL, &ifr);
 	close(fd);
 	return 0;
 }
@@ -526,29 +519,24 @@ static int do_show(int argc, char **argv)
 /* Return value becomes exitcode. It's okay to not return at all */
 int do_iptunnel(int argc, char **argv)
 {
-	static const char * const keywords[] = {
+	static const char *const keywords[] = {
 		"add", "change", "delete", "show", "list", "lst", NULL
 	};
-	enum {ARG_add = 1, ARG_change, ARG_del, ARG_show, ARG_list, ARG_lst};
-	smalluint key = 4; /* show */
-	if (argc > 0) {
-		key = index_in_substr_array(keywords, *argv) +1;
+	enum { ARG_add = 0, ARG_change, ARG_del, ARG_show, ARG_list, ARG_lst };
+	int key;
+
+	if (argc) {
+		key = index_in_substr_array(keywords, *argv);
+		if (key < 0)
+			bb_error_msg_and_die(bb_msg_invalid_arg, *argv, applet_name);
 		--argc;
 		++argv;
-	} else
-		return do_show(0, NULL);
-	if (key < ARG_add)
- bail:
-		bb_error_msg_and_die(bb_msg_invalid_arg, *argv, applet_name);
-
-	if (key == ARG_add)
-		return do_add(SIOCADDTUNNEL, argc, argv);
-	if (key == ARG_change)
-		return do_add(SIOCCHGTUNNEL, argc, argv);
-	if (key == ARG_del)
-		return do_del(argc, argv);
-	if (key == ARG_show || key == ARG_list || key == ARG_lst)
-		return do_show(argc, argv);
-	/* be gentle to gcc; avoid warning about non returning */
-	goto bail; /* never reached */
+		if (key == ARG_add)
+			return do_add(SIOCADDTUNNEL, argc, argv);
+		if (key == ARG_change)
+			return do_add(SIOCCHGTUNNEL, argc, argv);
+		if (key == ARG_del)
+			return do_del(argc, argv);
+	}
+	return do_show(argc, argv);
 }
diff --git a/networking/nameif.c b/networking/nameif.c
index a65f308..fd081fd 100644
--- a/networking/nameif.c
+++ b/networking/nameif.c
@@ -148,9 +148,9 @@ int nameif_main(int argc, char **argv)
 			continue;
 
 		strcpy(ifr.ifr_newname, ch->ifname);
-		if (ioctl(ctl_sk, SIOCSIFNAME, &ifr) < 0)
-			bb_perror_msg_and_die("cannot change ifname %s to %s",
-				   ifr.ifr_name, ch->ifname);
+		ioctl_or_perror_and_die(ctl_sk, SIOCSIFNAME, &ifr,
+					"cannot change ifname %s to %s",
+					ifr.ifr_name, ch->ifname);
 
 		/* Remove list entry of renamed interface */
 		if (ch->prev != NULL) {
diff --git a/networking/route.c b/networking/route.c
index b5490dd..530c51b 100644
--- a/networking/route.c
+++ b/networking/route.c
@@ -327,9 +327,10 @@ static void INET_setroute(int action, char **args)
 	/* Create a socket to the INET kernel. */
 	skfd = xsocket(AF_INET, SOCK_DGRAM, 0);
 
-	if (ioctl(skfd, ((action==RTACTION_ADD) ? SIOCADDRT : SIOCDELRT), &rt)<0) {
-		bb_perror_msg_and_die("SIOC[ADD|DEL]RT");
-	}
+	if (action == RTACTION_ADD)
+		xioctl(skfd, SIOCADDRT, &rt);
+	else
+		xioctl(skfd, SIOCDELRT, &rt);
 
 	if (ENABLE_FEATURE_CLEAN_UP) close(skfd);
 }
@@ -423,17 +424,15 @@ static void INET6_setroute(int action, char **args)
 		struct ifreq ifr;
 		memset(&ifr, 0, sizeof(ifr));
 		strncpy(ifr.ifr_name, devname, sizeof(ifr.ifr_name));
-
-		if (ioctl(skfd, SIOGIFINDEX, &ifr) < 0) {
-			bb_perror_msg_and_die("SIOGIFINDEX");
-		}
+		xioctl(skfd, SIOGIFINDEX, &ifr);
 		rt.rtmsg_ifindex = ifr.ifr_ifindex;
 	}
 
 	/* Tell the kernel to accept this route. */
-	if (ioctl(skfd, ((action==RTACTION_ADD) ? SIOCADDRT : SIOCDELRT), &rt)<0) {
-		bb_perror_msg_and_die("SIOC[ADD|DEL]RT");
-	}
+	if (action == RTACTION_ADD)
+		xioctl(skfd, SIOCADDRT, &rt);
+	else
+		xioctl(skfd, SIOCDELRT, &rt);
 
 	if (ENABLE_FEATURE_CLEAN_UP) close(skfd);
 }
diff --git a/networking/slattach.c b/networking/slattach.c
index 3495df5..1a4423b 100644
--- a/networking/slattach.c
+++ b/networking/slattach.c
@@ -50,8 +50,7 @@ static void save_state(void)
 		bb_perror_msg_and_die("get state");
 
 	/* Save line discipline */
-	if (ioctl(handle, TIOCGETD, &saved_disc) < 0)
-		bb_perror_msg_and_die("get discipline");
+	xioctl(handle, TIOCGETD, &saved_disc);
 }
 
 static int set_termios_state_and_warn(struct termios *state)
@@ -81,8 +80,7 @@ static void restore_state_and_exit(int exitcode)
 	struct termios state;
 
 	/* Restore line discipline */
-	if (ioctl(handle, TIOCSETD, &saved_disc) < 0) {
-		bb_perror_msg("set discipline");
+	if (ioctl_or_warn(handle, TIOCSETD, &saved_disc) < 0) {
 		exitcode = 1;
 	}
 
@@ -115,14 +113,12 @@ static void set_state(struct termios *state, int encap)
 		goto bad;
 	/* Set line discliple (N_SLIP always) */
 	disc = N_SLIP;
-	if (ioctl(handle, TIOCSETD, &disc) < 0) {
-		bb_perror_msg("set discipline");
+	if (ioctl_or_warn(handle, TIOCSETD, &disc) < 0) {
 		goto bad;
 	}
 
 	/* Set encapsulation (SLIP, CSLIP, etc) */
-	if (ioctl(handle, SIOCSIFENCAP, &encap) < 0) {
-		bb_perror_msg("set encapsulation");
+	if (ioctl_or_warn(handle, SIOCSIFENCAP, &encap) < 0) {
  bad:
 		restore_state_and_exit(1);
 	}
diff --git a/networking/traceroute.c b/networking/traceroute.c
index ad3ec4e..c87f7ff 100644
--- a/networking/traceroute.c
+++ b/networking/traceroute.c
@@ -445,8 +445,8 @@ ifaddrlist(struct IFADDRLIST **ipaddrp)
 		if (strchr(al->device, ':') != NULL)
 			continue;
 #endif
-		if (ioctl(fd, SIOCGIFADDR, (char *)&ifr) < 0)
-			bb_perror_msg_and_die("SIOCGIFADDR: %s", al->device);
+		ioctl_or_perror_and_die(fd, SIOCGIFADDR, (char *)&ifr,
+				"SIOCGIFADDR: %s", al->device);
 
 		addr_sin = (struct sockaddr_in *)&ifr.ifr_addr;
 		al->addr = addr_sin->sin_addr.s_addr;
diff --git a/networking/udhcp/socket.c b/networking/udhcp/socket.c
index be5985f..21a0585 100644
--- a/networking/udhcp/socket.c
+++ b/networking/udhcp/socket.c
@@ -53,9 +53,9 @@ int read_interface(const char *interface, int *ifindex, uint32_t *addr, uint8_t
 	ifr.ifr_addr.sa_family = AF_INET;
 	strncpy(ifr.ifr_name, interface, sizeof(ifr.ifr_name));
 	if (addr) {
-		if (ioctl(fd, SIOCGIFADDR, &ifr) != 0) {
-			bb_perror_msg("SIOCGIFADDR failed (is interface %s "
-					"up and configured?)", interface);
+		if (ioctl_or_perror(fd, SIOCGIFADDR, &ifr, 
+			"is interface %s up and configured?", interface)
+		) {
 			close(fd);
 			return -1;
 		}
@@ -65,8 +65,7 @@ int read_interface(const char *interface, int *ifindex, uint32_t *addr, uint8_t
 	}
 
 	if (ifindex) {
-		if (ioctl(fd, SIOCGIFINDEX, &ifr) != 0) {
-			bb_perror_msg("SIOCGIFINDEX failed");
+		if (ioctl_or_warn(fd, SIOCGIFINDEX, &ifr) != 0) {
 			close(fd);
 			return -1;
 		}
@@ -75,8 +74,7 @@ int read_interface(const char *interface, int *ifindex, uint32_t *addr, uint8_t
 	}
 
 	if (arp) {
-		if (ioctl(fd, SIOCGIFHWADDR, &ifr) != 0) {
-			bb_perror_msg("SIOCGIFHWADDR failed");
+		if (ioctl_or_warn(fd, SIOCGIFHWADDR, &ifr) != 0) {
 			close(fd);
 			return -1;
 		}
diff --git a/networking/vconfig.c b/networking/vconfig.c
index e063d0a..4776e13 100644
--- a/networking/vconfig.c
+++ b/networking/vconfig.c
@@ -157,9 +157,8 @@ int vconfig_main(int argc, char **argv)
 	}
 
 	fd = xsocket(AF_INET, SOCK_STREAM, 0);
-	if (ioctl(fd, SIOCSIFVLAN, &ifr) < 0) {
-		bb_perror_msg_and_die("ioctl error for %s", *argv);
-	}
+	ioctl_or_perror_and_die(fd, SIOCSIFVLAN, &ifr,
+						"ioctl error for %s", *argv);
 
 	return 0;
 }
diff --git a/networking/zcip.c b/networking/zcip.c
index de4ee0b..281f551 100644
--- a/networking/zcip.c
+++ b/networking/zcip.c
@@ -247,9 +247,7 @@ int zcip_main(int argc, char **argv)
 	// get the interface's ethernet address
 	//memset(&ifr, 0, sizeof(ifr));
 	strncpy(ifr.ifr_name, intf, sizeof(ifr.ifr_name));
-	if (ioctl(fd, SIOCGIFHWADDR, &ifr) < 0) {
-		bb_perror_msg_and_die("get ethernet address");
-	}
+	xioctl(fd, SIOCGIFHWADDR, &ifr);
 	memcpy(&eth_addr, &ifr.ifr_hwaddr.sa_data, ETH_ALEN);
 
 	// start with some stable ip address, either a function of
diff --git a/scripts/defconfig b/scripts/defconfig
index 522b1ca..4d12f8e 100644
--- a/scripts/defconfig
+++ b/scripts/defconfig
@@ -77,6 +77,7 @@ CONFIG_FEATURE_EDITING_HISTORY=15
 # CONFIG_FEATURE_USERNAME_COMPLETION is not set
 # CONFIG_FEATURE_EDITING_FANCY_PROMPT is not set
 # CONFIG_MONOTONIC_SYSCALL is not set
+CONFIG_IOCTL_HEX2STR_ERROR=y
 
 #
 # Applets
diff --git a/util-linux/fbset.c b/util-linux/fbset.c
index f963040..69986df 100644
--- a/util-linux/fbset.c
+++ b/util-linux/fbset.c
@@ -385,8 +385,7 @@ int fbset_main(int argc, char **argv)
 	}
 
 	fh = xopen(fbdev, O_RDONLY);
-	if (ioctl(fh, FBIOGET_VSCREENINFO, &var))
-		bb_perror_msg_and_die("ioctl(%sT_VSCREENINFO)", "GE");
+	xioctl(fh, FBIOGET_VSCREENINFO, &var);
 	if (g_options & OPT_READMODE) {
 		if (!readmode(&var, modefile, mode)) {
 			bb_error_msg_and_die("unknown video mode '%s'", mode);
@@ -397,8 +396,7 @@ int fbset_main(int argc, char **argv)
 	if (g_options & OPT_CHANGE) {
 		if (g_options & OPT_ALL)
 			var.activate = FB_ACTIVATE_ALL;
-		if (ioctl(fh, FBIOPUT_VSCREENINFO, &var))
-			bb_perror_msg_and_die("ioctl(%sT_VSCREENINFO)", "PU");
+		xioctl(fh, FBIOPUT_VSCREENINFO, &var);
 	}
 	showmode(&var);
 	/* Don't close the file, as exiting will take care of that */
diff --git a/util-linux/fdformat.c b/util-linux/fdformat.c
index e9fbeee..5e253ef 100644
--- a/util-linux/fdformat.c
+++ b/util-linux/fdformat.c
@@ -45,13 +45,6 @@ struct format_descr {
 #define FDGETPRM _IOR(2, 0x04, struct floppy_struct)
 #define FD_FILL_BYTE 0xF6 /* format fill byte. */
 
-static void xioctl(int fd, int request, void *argp, const char *string)
-{
-	if (ioctl(fd, request, argp) < 0) {
-		bb_perror_msg_and_die(string);
-	}
-}
-
 int fdformat_main(int argc,char **argv);
 int fdformat_main(int argc,char **argv)
 {
@@ -77,7 +70,7 @@ int fdformat_main(int argc,char **argv)
 	fd = xopen(*argv, O_RDWR);
 
 	/* original message was: "Could not determine current format type" */
-	xioctl(fd, FDGETPRM, &param, "FDGETPRM");
+	xioctl(fd, FDGETPRM, &param);
 
 	printf("%s-sided, %d tracks, %d sec/track. Total capacity %d kB\n",
 		(param.head == 2) ? "Double" : "Single",
@@ -85,21 +78,21 @@ int fdformat_main(int argc,char **argv)
 
 	/* FORMAT */
 	printf("Formatting... ");
-	xioctl(fd, FDFMTBEG, NULL, "FDFMTBEG");
+	xioctl(fd, FDFMTBEG, NULL);
 
 	/* n == track */
 	for (n = 0; n < param.track; n++) {
 		descr.head = 0;
 		descr.track = n;
-		xioctl(fd, FDFMTTRK, &descr, "FDFMTTRK");
+		xioctl(fd, FDFMTTRK, &descr);
 		printf("%3d\b\b\b", n);
 		if (param.head == 2) {
 			descr.head = 1;
-			xioctl(fd, FDFMTTRK, &descr, "FDFMTTRK");
+			xioctl(fd, FDFMTTRK, &descr);
 		}
 	}
 
-	xioctl(fd, FDFMTEND, NULL, "FDFMTEND");
+	xioctl(fd, FDFMTEND, NULL);
 	printf("done\n");
 
 	/* VERIFY */
diff --git a/util-linux/fdisk.c b/util-linux/fdisk.c
index 8707891..3b9892f 100644
--- a/util-linux/fdisk.c
+++ b/util-linux/fdisk.c
@@ -2434,23 +2434,9 @@ reread_partition_table(int leave)
 	printf("Calling ioctl() to re-read partition table\n");
 	sync();
 	/* sleep(2); Huh? */
-	i = ioctl(fd, BLKRRPART);
-#if 0
-	else {
-		/* some kernel versions (1.2.x) seem to have trouble
-		   rereading the partition table, but if asked to do it
-		   twice, the second time works. - biro@yggdrasil.com */
-		sync();
-		sleep(2);
-		i = ioctl(fd, BLKRRPART);
-	}
-#endif
-
-	if (i) {
-		bb_perror_msg("WARNING: rereading partition table "
+	i = ioctl_or_perror(fd, BLKRRPART, NULL,
+			"WARNING: rereading partition table "
 			"failed, kernel still uses old table");
-	}
-
 #if 0
 	if (dos_changed)
 		printf(
diff --git a/util-linux/freeramdisk.c b/util-linux/freeramdisk.c
index a1f2c56..4bd9378 100644
--- a/util-linux/freeramdisk.c
+++ b/util-linux/freeramdisk.c
@@ -17,7 +17,6 @@
 int freeramdisk_main(int argc, char **argv);
 int freeramdisk_main(int argc, char **argv)
 {
-	int result;
 	int fd;
 
 	if (argc != 2) bb_show_usage();
@@ -25,11 +24,10 @@ int freeramdisk_main(int argc, char **argv)
 	fd = xopen(argv[1], O_RDWR);
 
 	// Act like freeramdisk, fdflush, or both depending on configuration.
-	result = ioctl(fd, (ENABLE_FREERAMDISK && applet_name[1]=='r')
-			|| !ENABLE_FDFLUSH ? BLKFLSBUF : FDFLUSH);
+	ioctl_or_perror_and_die(fd, (ENABLE_FREERAMDISK && applet_name[1]=='r')
+			|| !ENABLE_FDFLUSH ? BLKFLSBUF : FDFLUSH, NULL, "%s", argv[1]);
 
 	if (ENABLE_FEATURE_CLEAN_UP) close(fd);
 
-	if (result) bb_perror_msg_and_die("%s", argv[1]);
 	return EXIT_SUCCESS;
 }
diff --git a/util-linux/hwclock.c b/util-linux/hwclock.c
index 204a103..8b65df6 100644
--- a/util-linux/hwclock.c
+++ b/util-linux/hwclock.c
@@ -59,25 +59,23 @@ static time_t read_rtc(int utc)
 	int rtc = xopen_rtc(O_RDONLY);
 
 	memset(&tm, 0, sizeof(struct tm));
-	if (ioctl(rtc, RTC_RD_TIME, &tm) < 0)
-		bb_perror_msg_and_die("cannot read time from RTC");
+	xioctl(rtc, RTC_RD_TIME, &tm);
 	tm.tm_isdst = -1; /* not known */
 
 	close(rtc);
 
 	if (utc) {
 		oldtz = getenv("TZ");
-		setenv("TZ", "UTC 0", 1);
+		putenv((char*)"TZ=UTC0");
 		tzset();
 	}
 
 	t = mktime(&tm);
 
 	if (utc) {
+		unsetenv("TZ");
 		if (oldtz)
-			setenv("TZ", oldtz, 1);
-		else
-			unsetenv("TZ");
+			putenv(oldtz - 3);
 		tzset();
 	}
 	return t;
@@ -91,8 +89,7 @@ static void write_rtc(time_t t, int utc)
 	tm = *(utc ? gmtime(&t) : localtime(&t));
 	tm.tm_isdst = 0;
 
-	if (ioctl(rtc, RTC_SET_TIME, &tm) < 0)
-		bb_perror_msg_and_die("cannot set the RTC time");
+	xioctl(rtc, RTC_SET_TIME, &tm);
 
 	close(rtc);
 }
