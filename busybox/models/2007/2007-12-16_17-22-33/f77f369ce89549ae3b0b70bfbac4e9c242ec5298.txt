2007-12-16 17:22:33 +0000
diff --git a/util-linux/fdisk.c b/util-linux/fdisk.c
index 3b60847..8271f60 100644
--- a/util-linux/fdisk.c
+++ b/util-linux/fdisk.c
@@ -57,18 +57,6 @@ static const char msg_part_already_defined[] ALIGN1 =
 "Partition %d is already defined, delete it before re-adding\n";
 
 
-static unsigned sector_size = DEFAULT_SECTOR_SIZE;
-static unsigned user_set_sector_size;
-static unsigned sector_offset = 1;
-
-#if ENABLE_FEATURE_OSF_LABEL
-static int possibly_osf_label;
-#endif
-
-static unsigned heads, sectors, cylinders;
-static void update_units(void);
-
-
 struct partition {
 	unsigned char boot_ind;         /* 0x80 - active */
 	unsigned char head;             /* starting head */
@@ -129,13 +117,7 @@ enum label_type {
 
 enum action { fdisk, require, try_only, create_empty_dos, create_empty_sun };
 
-static enum label_type current_label_type;
-
-static const char *disk_device;
-static int fd;                  /* the disk */
-static int partitions = 4;      /* maximum partition + 1 */
-static int display_in_cyl_units = 1;
-static unsigned units_per_sector = 1;
+static void update_units(void);
 #if ENABLE_FEATURE_FDISK_WRITABLE
 static void change_units(void);
 static void reread_partition_table(int leave);
@@ -282,28 +264,60 @@ static const char *const i386_sys_types[] = {
 
 struct globals {
 	char *line_ptr;
+
+	const char *disk_device;
+	int fd;                         /* the disk */
+	int g_partitions; // = 4;       /* maximum partition + 1 */
+	unsigned units_per_sector; // = 1;
+	unsigned sector_size; // = DEFAULT_SECTOR_SIZE;
+	unsigned user_set_sector_size;
+	unsigned sector_offset; // = 1;
+	unsigned g_heads, g_sectors, g_cylinders;
+	enum label_type current_label_type;
+	smallint display_in_cyl_units; // = 1;
+#if ENABLE_FEATURE_OSF_LABEL
+	smallint possibly_osf_label;
+#endif
+
+	jmp_buf listingbuf;
 	char line_buffer[80];
 	char partname_buffer[80];
-	jmp_buf listingbuf;
 	/* Raw disk label. For DOS-type partition tables the MBR,
 	 * with descriptions of the primary partitions. */
 	char MBRbuffer[MAX_SECTOR_SIZE];
 	/* Partition tables */
 	struct pte ptes[MAXIMUM_PARTS];
 };
-/* bb_common_bufsiz1 is too small for this on 64 bit CPUs */
 #define G (*ptr_to_globals)
-
 #define line_ptr        (G.line_ptr)
+#define disk_device          (G.disk_device         )
+#define fd                   (G.fd                  )
+#define g_partitions         (G.g_partitions        )
+#define units_per_sector     (G.units_per_sector    )
+#define sector_size          (G.sector_size         )
+#define user_set_sector_size (G.user_set_sector_size)
+#define sector_offset        (G.sector_offset       )
+#define g_heads              (G.g_heads             )
+#define g_sectors            (G.g_sectors           )
+#define g_cylinders          (G.g_cylinders         )
+#define current_label_type   (G.current_label_type  )
+#define display_in_cyl_units (G.display_in_cyl_units)
+#define possibly_osf_label   (G.possibly_osf_label  )
 #define listingbuf      (G.listingbuf)
 #define line_buffer     (G.line_buffer)
 #define partname_buffer (G.partname_buffer)
 #define MBRbuffer       (G.MBRbuffer)
 #define ptes            (G.ptes)
+#define INIT_G() do { \
+	PTR_TO_GLOBALS = xzalloc(sizeof(G)); \
+	sector_size = DEFAULT_SECTOR_SIZE; \
+	sector_offset = 1; \
+	g_partitions = 4; \
+	display_in_cyl_units = 1; \
+	units_per_sector = 1; \
+} while (0)
 
 
-/* Code */
-
 #define IS_EXTENDED(i) \
 	((i) == EXTENDED || (i) == WIN98_EXTENDED || (i) == LINUX_EXTENDED)
 
@@ -323,12 +337,12 @@ struct globals {
 
 #define set_hsc(h,s,c,sector) \
 	do { \
-		s = sector % sectors + 1;  \
-		sector /= sectors;         \
-		h = sector % heads;        \
-		sector /= heads;           \
-		c = sector & 0xff;         \
-		s |= (sector >> 2) & 0xc0; \
+		s = sector % g_sectors + 1;  \
+		sector /= g_sectors;         \
+		h = sector % g_heads;        \
+		sector /= g_heads;           \
+		c = sector & 0xff;           \
+		s |= (sector >> 2) & 0xc0;   \
 	} while (0)
 
 #if ENABLE_FEATURE_FDISK_WRITABLE
@@ -611,11 +625,11 @@ get_nr_sects(const struct partition *p)
 static int type_open = O_RDWR;
 
 static int ext_index;               /* the prime extended partition */
-static int listing;                 /* no aborts for fdisk -l */
+static smallint listing;                 /* no aborts for fdisk -l */
 static int dos_compatible_flag = ~0;
 #if ENABLE_FEATURE_FDISK_WRITABLE
-static int dos_changed;
-static int nowarn;            /* no warnings for fdisk -l/-s */
+//static int dos_changed;
+static smallint nowarn;            /* no warnings for fdisk -l/-s */
 #endif
 
 static unsigned user_cylinders, user_heads, user_sectors;
@@ -930,11 +944,11 @@ set_partition(int i, int doext, ullong start, ullong stop, int sysid)
 	p->sys_ind = sysid;
 	set_start_sect(p, start - offset);
 	set_nr_sects(p, stop - start + 1);
-	if (dos_compatible_flag && (start/(sectors*heads) > 1023))
-		start = heads*sectors*1024 - 1;
+	if (dos_compatible_flag && (start / (g_sectors * g_heads) > 1023))
+		start = g_heads * g_sectors * 1024 - 1;
 	set_hsc(p->head, p->sector, p->cyl, start);
-	if (dos_compatible_flag && (stop/(sectors*heads) > 1023))
-		stop = heads*sectors*1024 - 1;
+	if (dos_compatible_flag && (stop / (g_sectors * g_heads) > 1023))
+		stop = g_heads * g_sectors * 1024 - 1;
 	set_hsc(p->end_head, p->end_sector, p->end_cyl, stop);
 	ptes[i].changed = 1;
 }
@@ -943,15 +957,15 @@ set_partition(int i, int doext, ullong start, ullong stop, int sysid)
 static int
 warn_geometry(void)
 {
-	if (heads && sectors && cylinders)
+	if (g_heads && g_sectors && g_cylinders)
 		return 0;
 
 	printf("Unknown value(s) for:");
-	if (!heads)
+	if (!g_heads)
 		printf(" heads");
-	if (!sectors)
+	if (!g_sectors)
 		printf(" sectors");
-	if (!cylinders)
+	if (!g_cylinders)
 		printf(" cylinders");
 	printf(
 #if ENABLE_FEATURE_FDISK_WRITABLE
@@ -964,7 +978,7 @@ warn_geometry(void)
 static void
 update_units(void)
 {
-	int cyl_units = heads * sectors;
+	int cyl_units = g_heads * g_sectors;
 
 	if (display_in_cyl_units && cyl_units)
 		units_per_sector = cyl_units;
@@ -976,7 +990,7 @@ update_units(void)
 static void
 warn_cylinders(void)
 {
-	if (LABEL_IS_DOS && cylinders > 1024 && !nowarn)
+	if (LABEL_IS_DOS && g_cylinders > 1024 && !nowarn)
 		printf("\n"
 "The number of cylinders for this disk is set to %d.\n"
 "There is nothing wrong with that, but this is larger than 1024,\n"
@@ -984,7 +998,7 @@ warn_cylinders(void)
 "1) software that runs at boot time (e.g., old versions of LILO)\n"
 "2) booting and partitioning software from other OSs\n"
 "   (e.g., DOS FDISK, OS/2 FDISK)\n",
-			cylinders);
+			g_cylinders);
 }
 #endif
 
@@ -1006,16 +1020,16 @@ read_extended(int ext)
 	}
 
 	while (IS_EXTENDED(p->sys_ind)) {
-		struct pte *pe = &ptes[partitions];
+		struct pte *pe = &ptes[g_partitions];
 
-		if (partitions >= MAXIMUM_PARTS) {
+		if (g_partitions >= MAXIMUM_PARTS) {
 			/* This is not a Linux restriction, but
 			   this program uses arrays of size MAXIMUM_PARTS.
 			   Do not try to 'improve' this test. */
-			struct pte *pre = &ptes[partitions-1];
+			struct pte *pre = &ptes[g_partitions - 1];
 #if ENABLE_FEATURE_FDISK_WRITABLE
 			printf("Warning: deleting partitions after %d\n",
-				partitions);
+				g_partitions);
 			pre->changed = 1;
 #endif
 			clear_partition(pre->ext_pointer);
@@ -1033,14 +1047,14 @@ read_extended(int ext)
 				if (pe->ext_pointer)
 					printf("Warning: extra link "
 						"pointer in partition table"
-						" %d\n", partitions + 1);
+						" %d\n", g_partitions + 1);
 				else
 					pe->ext_pointer = p;
 			} else if (p->sys_ind) {
 				if (pe->part_table)
 					printf("Warning: ignoring extra "
 						  "data in partition table"
-						  " %d\n", partitions + 1);
+						  " %d\n", g_partitions + 1);
 				else
 					pe->part_table = p;
 			}
@@ -1061,17 +1075,17 @@ read_extended(int ext)
 		}
 
 		p = pe->ext_pointer;
-		partitions++;
+		g_partitions++;
 	}
 
 #if ENABLE_FEATURE_FDISK_WRITABLE
 	/* remove empty links */
  remove:
-	for (i = 4; i < partitions; i++) {
+	for (i = 4; i < g_partitions; i++) {
 		struct pte *pe = &ptes[i];
 
 		if (!get_nr_sects(pe->part_table)
-		 && (partitions > 5 || ptes[4].part_table->sys_ind)
+		 && (g_partitions > 5 || ptes[4].part_table->sys_ind)
 		) {
 			printf("Omitting empty partition (%d)\n", i+1);
 			delete_partition(i);
@@ -1094,7 +1108,7 @@ create_doslabel(void)
 #if ENABLE_FEATURE_OSF_LABEL
 	possibly_osf_label = 0;
 #endif
-	partitions = 4;
+	g_partitions = 4;
 
 	for (i = 510-64; i < 510; i++)
 		MBRbuffer[i] = 0;
@@ -1175,17 +1189,17 @@ get_geometry(void)
 #if ENABLE_FEATURE_SUN_LABEL
 	guess_device_type();
 #endif
-	heads = cylinders = sectors = 0;
+	g_heads = g_cylinders = g_sectors = 0;
 	kern_heads = kern_sectors = 0;
 	pt_heads = pt_sectors = 0;
 
 	get_kernel_geometry();
 	get_partition_table_geometry();
 
-	heads = user_heads ? user_heads :
+	g_heads = user_heads ? user_heads :
 		pt_heads ? pt_heads :
 		kern_heads ? kern_heads : 255;
-	sectors = user_sectors ? user_sectors :
+	g_sectors = user_sectors ? user_sectors :
 		pt_sectors ? pt_sectors :
 		kern_sectors ? kern_sectors : 63;
 	if (ioctl(fd, BLKGETSIZE64, &v64) == 0) {
@@ -1200,11 +1214,11 @@ get_geometry(void)
 
 	sector_offset = 1;
 	if (dos_compatible_flag)
-		sector_offset = sectors;
+		sector_offset = g_sectors;
 
-	cylinders = total_number_of_sectors / (heads * sectors * sec_fac);
-	if (!cylinders)
-		cylinders = user_cylinders;
+	g_cylinders = total_number_of_sectors / (g_heads * g_sectors * sec_fac);
+	if (!g_cylinders)
+		g_cylinders = user_cylinders;
 }
 
 /*
@@ -1218,7 +1232,7 @@ get_boot(enum action what)
 {
 	int i;
 
-	partitions = 4;
+	g_partitions = 4;
 
 	for (i = 0; i < 4; i++) {
 		struct pte *pe = &ptes[i];
@@ -1342,7 +1356,7 @@ get_boot(enum action what)
 		struct pte *pe = &ptes[i];
 
 		if (IS_EXTENDED(pe->part_table->sys_ind)) {
-			if (partitions != 4)
+			if (g_partitions != 4)
 				printf("Ignoring extra extended "
 					"partition %d\n", i + 1);
 			else
@@ -1350,7 +1364,7 @@ get_boot(enum action what)
 		}
 	}
 
-	for (i = 3; i < partitions; i++) {
+	for (i = 3; i < g_partitions; i++) {
 		struct pte *pe = &ptes[i];
 
 		if (!valid_part_table_flag(pe->sectorbuffer)) {
@@ -1411,7 +1425,7 @@ read_int(unsigned low, unsigned dflt, unsigned high, unsigned base, const char *
 			case 'c':
 			case 'C':
 				if (!display_in_cyl_units)
-					i *= heads * sectors;
+					i *= g_heads * g_sectors;
 				break;
 			case 'K':
 				absolute = 1024;
@@ -1562,7 +1576,7 @@ toggle_dos_compatibility_flag(void)
 {
 	dos_compatible_flag = ~dos_compatible_flag;
 	if (dos_compatible_flag) {
-		sector_offset = sectors;
+		sector_offset = g_sectors;
 		printf("DOS Compatibility flag is set\n");
 	} else {
 		sector_offset = 1;
@@ -1596,7 +1610,7 @@ delete_partition(int i)
 
 	if (i < 4) {
 		if (IS_EXTENDED(p->sys_ind) && i == ext_index) {
-			partitions = 4;
+			g_partitions = 4;
 			ptes[ext_index].ext_pointer = NULL;
 			extended_offset = 0;
 		}
@@ -1606,7 +1620,7 @@ delete_partition(int i)
 
 	if (!q->sys_ind && i > 4) {
 		/* the last one in the chain - just delete */
-		--partitions;
+		--g_partitions;
 		--i;
 		clear_partition(ptes[i].ext_pointer);
 		ptes[i].changed = 1;
@@ -1619,7 +1633,7 @@ delete_partition(int i)
 			set_start_sect(p, get_start_sect(q));
 			set_nr_sects(p, get_nr_sects(q));
 			ptes[i-1].changed = 1;
-		} else if (partitions > 5) {    /* 5 will be moved to 4 */
+		} else if (g_partitions > 5) {    /* 5 will be moved to 4 */
 			/* the first logical in a longer chain */
 			pe = &ptes[5];
 
@@ -1631,9 +1645,9 @@ delete_partition(int i)
 			pe->changed = 1;
 		}
 
-		if (partitions > 5) {
-			partitions--;
-			while (i < partitions) {
+		if (g_partitions > 5) {
+			g_partitions--;
+			while (i < g_partitions) {
 				ptes[i] = ptes[i+1];
 				i++;
 			}
@@ -1653,9 +1667,9 @@ change_sysid(void)
 	   let the user select a partition, since get_existing_partition()
 	   only works for Linux like partition tables. */
 	if (!LABEL_IS_SGI) {
-		i = get_existing_partition(0, partitions);
+		i = get_existing_partition(0, g_partitions);
 	} else {
-		i = get_partition(0, partitions);
+		i = get_partition(0, g_partitions);
 	}
 	if (i == -1)
 		return;
@@ -1722,7 +1736,7 @@ change_sysid(void)
 			ptes[i].changed = 1;
 			if (is_dos_partition(origsys) ||
 				is_dos_partition(sys))
-				dos_changed = 1;
+				//dos_changed = 1;
 			break;
 		}
 	}
@@ -1738,12 +1752,12 @@ change_sysid(void)
 static void
 linear2chs(unsigned ls, unsigned *c, unsigned *h, unsigned *s)
 {
-	int spc = heads * sectors;
+	int spc = g_heads * g_sectors;
 
 	*c = ls / spc;
 	ls = ls % spc;
-	*h = ls / sectors;
-	*s = ls % sectors + 1;  /* sectors count from 1 */
+	*h = ls / g_sectors;
+	*s = ls % g_sectors + 1;  /* sectors count from 1 */
 }
 
 static void
@@ -1754,7 +1768,7 @@ check_consistency(const struct partition *p, int partition)
 	unsigned lbc, lbh, lbs;          /* logical beginning c, h, s */
 	unsigned lec, leh, les;          /* logical ending c, h, s */
 
-	if (!heads || !sectors || (partition >= 4))
+	if (!g_heads || !g_sectors || (partition >= 4))
 		return;         /* do not check extended partitions */
 
 /* physical beginning c, h, s */
@@ -1774,7 +1788,7 @@ check_consistency(const struct partition *p, int partition)
 	linear2chs(get_start_sect(p) + get_nr_sects(p) - 1, &lec, &leh, &les);
 
 /* Same physical / logical beginning? */
-	if (cylinders <= 1024 && (pbc != lbc || pbh != lbh || pbs != lbs)) {
+	if (g_cylinders <= 1024 && (pbc != lbc || pbh != lbh || pbs != lbs)) {
 		printf("Partition %d has different physical/logical "
 			"beginnings (non-Linux?):\n", partition + 1);
 		printf("     phys=(%d, %d, %d) ", pbc, pbh, pbs);
@@ -1782,7 +1796,7 @@ check_consistency(const struct partition *p, int partition)
 	}
 
 /* Same physical / logical ending? */
-	if (cylinders <= 1024 && (pec != lec || peh != leh || pes != les)) {
+	if (g_cylinders <= 1024 && (pec != lec || peh != leh || pes != les)) {
 		printf("Partition %d has different physical/logical "
 			"endings:\n", partition + 1);
 		printf("     phys=(%d, %d, %d) ", pec, peh, pes);
@@ -1790,7 +1804,7 @@ check_consistency(const struct partition *p, int partition)
 	}
 
 /* Ending on cylinder boundary? */
-	if (peh != (heads - 1) || pes != sectors) {
+	if (peh != (g_heads - 1) || pes != g_sectors) {
 		printf("Partition %i does not end on cylinder boundary\n",
 			partition + 1);
 	}
@@ -1809,7 +1823,7 @@ list_disk_geometry(void)
 		printf("\nDisk %s: %ld.%ld GB, %lld bytes\n",
 			   disk_device, megabytes/1000, (megabytes/100)%10, bytes);
 	printf("%d heads, %d sectors/track, %d cylinders",
-		   heads, sectors, cylinders);
+		   g_heads, g_sectors, g_cylinders);
 	if (units_per_sector == 1)
 		printf(", total %llu sectors",
 			   total_number_of_sectors / (sector_size/512));
@@ -1831,7 +1845,7 @@ wrong_p_order(int *prev)
 	ullong last_p_start_pos = 0, p_start_pos;
 	int i, last_i = 0;
 
-	for (i = 0; i < partitions; i++) {
+	for (i = 0; i < g_partitions; i++) {
 		if (i == 4) {
 			last_i = 4;
 			last_p_start_pos = 0;
@@ -1877,7 +1891,7 @@ fix_chain_of_logicals(void)
 	/* Stage 1: sort sectors but leave sector of part 4 */
 	/* (Its sector is the global extended_offset.) */
  stage1:
-	for (j = 5; j < partitions-1; j++) {
+	for (j = 5; j < g_partitions - 1; j++) {
 		oj = ptes[j].offset;
 		ojj = ptes[j+1].offset;
 		if (oj > ojj) {
@@ -1897,7 +1911,7 @@ fix_chain_of_logicals(void)
 
 	/* Stage 2: sort starting sectors */
  stage2:
-	for (j = 4; j < partitions-1; j++) {
+	for (j = 4; j < g_partitions - 1; j++) {
 		pj = ptes[j].part_table;
 		pjj = ptes[j+1].part_table;
 		sj = get_start_sect(pj);
@@ -1915,7 +1929,7 @@ fix_chain_of_logicals(void)
 	}
 
 	/* Probably something was changed */
-	for (j = 4; j < partitions; j++)
+	for (j = 4; j < g_partitions; j++)
 		ptes[j].changed = 1;
 }
 
@@ -1995,7 +2009,7 @@ list_table(int xtra)
 	printf("%*s Boot      Start         End      Blocks  Id System\n",
 		   w+1, "Device");
 
-	for (i = 0; i < partitions; i++) {
+	for (i = 0; i < g_partitions; i++) {
 		const struct pte *pe = &ptes[i];
 		ullong psects;
 		ullong pblocks;
@@ -2048,9 +2062,9 @@ x_list_table(int extend)
 	int i;
 
 	printf("\nDisk %s: %d heads, %d sectors, %d cylinders\n\n",
-		disk_device, heads, sectors, cylinders);
+		disk_device, g_heads, g_sectors, g_cylinders);
 	printf("Nr AF  Hd Sec  Cyl  Hd Sec  Cyl      Start       Size ID\n");
-	for (i = 0; i < partitions; i++) {
+	for (i = 0; i < g_partitions; i++) {
 		pe = &ptes[i];
 		p = (extend ? pe->ext_pointer : pe->part_table);
 		if (p != NULL) {
@@ -2076,7 +2090,7 @@ fill_bounds(ullong *first, ullong *last)
 	const struct pte *pe = &ptes[0];
 	const struct partition *p;
 
-	for (i = 0; i < partitions; pe++,i++) {
+	for (i = 0; i < g_partitions; pe++,i++) {
 		p = pe->part_table;
 		if (!p->sys_ind || IS_EXTENDED(p->sys_ind)) {
 			first[i] = 0xffffffff;
@@ -2095,19 +2109,19 @@ check(int n, unsigned h, unsigned s, unsigned c, ullong start)
 
 	real_s = sector(s) - 1;
 	real_c = cylinder(s, c);
-	total = (real_c * sectors + real_s) * heads + h;
+	total = (real_c * g_sectors + real_s) * g_heads + h;
 	if (!total)
 		printf("Partition %d contains sector 0\n", n);
-	if (h >= heads)
+	if (h >= g_heads)
 		printf("Partition %d: head %d greater than maximum %d\n",
-			n, h + 1, heads);
-	if (real_s >= sectors)
+			n, h + 1, g_heads);
+	if (real_s >= g_sectors)
 		printf("Partition %d: sector %d greater than "
-			"maximum %d\n", n, s, sectors);
-	if (real_c >= cylinders)
+			"maximum %d\n", n, s, g_sectors);
+	if (real_c >= g_cylinders)
 		printf("Partition %d: cylinder %llu greater than "
-			"maximum %d\n", n, real_c + 1, cylinders);
-	if (cylinders <= 1024 && start != total)
+			"maximum %d\n", n, real_c + 1, g_cylinders);
+	if (g_cylinders <= 1024 && start != total)
 		printf("Partition %d: previous sectors %llu disagrees with "
 			"total %llu\n", n, start, total);
 }
@@ -2117,7 +2131,7 @@ verify(void)
 {
 	int i, j;
 	unsigned total = 1;
-	ullong first[partitions], last[partitions];
+	ullong first[g_partitions], last[g_partitions];
 	struct partition *p;
 
 	if (warn_geometry())
@@ -2133,7 +2147,7 @@ verify(void)
 	}
 
 	fill_bounds(first, last);
-	for (i = 0; i < partitions; i++) {
+	for (i = 0; i < g_partitions; i++) {
 		struct pte *pe = &ptes[i];
 
 		p = pe->part_table;
@@ -2164,11 +2178,11 @@ verify(void)
 		ullong e_last = get_start_sect(pex->part_table) +
 			get_nr_sects(pex->part_table) - 1;
 
-		for (i = 4; i < partitions; i++) {
+		for (i = 4; i < g_partitions; i++) {
 			total++;
 			p = ptes[i].part_table;
 			if (!p->sys_ind) {
-				if (i != 4 || i + 1 < partitions)
+				if (i != 4 || i + 1 < g_partitions)
 					printf("Warning: partition %d "
 						"is empty\n", i + 1);
 			} else if (first[i] < extended_offset || last[i] > e_last) {
@@ -2178,11 +2192,11 @@ verify(void)
 		}
 	}
 
-	if (total > heads * sectors * cylinders)
+	if (total > g_heads * g_sectors * g_cylinders)
 		printf("Total allocated sectors %d greater than the maximum "
-			"%d\n", total, heads * sectors * cylinders);
+			"%d\n", total, g_heads * g_sectors * g_cylinders);
 	else {
-		total = heads * sectors * cylinders - total;
+		total = g_heads * g_sectors * g_cylinders - total;
 		if (total != 0)
 			printf("%d unallocated sectors\n", total);
 	}
@@ -2197,7 +2211,7 @@ add_partition(int n, int sys)
 	struct partition *q = ptes[ext_index].part_table;
 	ullong limit, temp;
 	ullong start, stop = 0;
-	ullong first[partitions], last[partitions];
+	ullong first[g_partitions], last[g_partitions];
 
 	if (p && p->sys_ind) {
 		printf(msg_part_already_defined, n + 1);
@@ -2207,7 +2221,7 @@ add_partition(int n, int sys)
 	if (n < 4) {
 		start = sector_offset;
 		if (display_in_cyl_units || !total_number_of_sectors)
-			limit = (ullong) heads * sectors * cylinders - 1;
+			limit = (ullong) g_heads * g_sectors * g_cylinders - 1;
 		else
 			limit = total_number_of_sectors - 1;
 		if (extended_offset) {
@@ -2220,13 +2234,13 @@ add_partition(int n, int sys)
 		limit = get_start_sect(q) + get_nr_sects(q) - 1;
 	}
 	if (display_in_cyl_units)
-		for (i = 0; i < partitions; i++)
+		for (i = 0; i < g_partitions; i++)
 			first[i] = (cround(first[i]) - 1) * units_per_sector;
 
 	snprintf(mesg, sizeof(mesg), "First %s", str_units(SINGULAR));
 	do {
 		temp = start;
-		for (i = 0; i < partitions; i++) {
+		for (i = 0; i < g_partitions; i++) {
 			int lastplusoff;
 
 			if (start == ptes[i].offset)
@@ -2266,7 +2280,7 @@ add_partition(int n, int sys)
 		}
 	}
 
-	for (i = 0; i < partitions; i++) {
+	for (i = 0; i < g_partitions; i++) {
 		struct pte *pe = &ptes[i];
 
 		if (start < pe->offset && limit >= pe->offset)
@@ -2277,7 +2291,7 @@ add_partition(int n, int sys)
 	if (start > limit) {
 		printf("No free sectors available\n");
 		if (n > 4)
-			partitions--;
+			g_partitions--;
 		return;
 	}
 	if (cround(start) == cround(limit)) {
@@ -2310,24 +2324,24 @@ add_partition(int n, int sys)
 		pe4->part_table = pt_offset(pe4->sectorbuffer, 0);
 		pe4->ext_pointer = pe4->part_table + 1;
 		pe4->changed = 1;
-		partitions = 5;
+		g_partitions = 5;
 	}
 }
 
 static void
 add_logical(void)
 {
-	if (partitions > 5 || ptes[4].part_table->sys_ind) {
-		struct pte *pe = &ptes[partitions];
+	if (g_partitions > 5 || ptes[4].part_table->sys_ind) {
+		struct pte *pe = &ptes[g_partitions];
 
 		pe->sectorbuffer = xzalloc(sector_size);
 		pe->part_table = pt_offset(pe->sectorbuffer, 0);
 		pe->ext_pointer = pe->part_table + 1;
 		pe->offset = 0;
 		pe->changed = 1;
-		partitions++;
+		g_partitions++;
 	}
-	add_partition(partitions - 1, LINUX_NATIVE);
+	add_partition(g_partitions - 1, LINUX_NATIVE);
 }
 
 static void
@@ -2339,11 +2353,11 @@ new_partition(void)
 		return;
 
 	if (LABEL_IS_SUN) {
-		add_sun_partition(get_partition(0, partitions), LINUX_NATIVE);
+		add_sun_partition(get_partition(0, g_partitions), LINUX_NATIVE);
 		return;
 	}
 	if (LABEL_IS_SGI) {
-		sgi_add_partition(get_partition(0, partitions), LINUX_NATIVE);
+		sgi_add_partition(get_partition(0, g_partitions), LINUX_NATIVE);
 		return;
 	}
 	if (LABEL_IS_AIX) {
@@ -2356,7 +2370,7 @@ new_partition(void)
 	for (i = 0; i < 4; i++)
 		free_primary += !ptes[i].part_table->sys_ind;
 
-	if (!free_primary && partitions >= MAXIMUM_PARTS) {
+	if (!free_primary && g_partitions >= MAXIMUM_PARTS) {
 		printf("The maximum number of partitions has been created\n");
 		return;
 	}
@@ -2408,7 +2422,7 @@ write_table(void)
 		for (i = 0; i < 3; i++)
 			if (ptes[i].changed)
 				ptes[3].changed = 1;
-		for (i = 3; i < partitions; i++) {
+		for (i = 3; i < g_partitions; i++) {
 			struct pte *pe = &ptes[i];
 
 			if (pe->changed) {
@@ -2492,7 +2506,7 @@ print_raw(void)
 	if (LABEL_IS_SGI || LABEL_IS_SUN)
 		print_buffer(MBRbuffer);
 	else {
-		for (i = 3; i < partitions; i++)
+		for (i = 3; i < g_partitions; i++)
 			print_buffer(ptes[i].sectorbuffer);
 	}
 }
@@ -2537,14 +2551,14 @@ xselect(void)
 			break;
 		case 'b':
 			if (LABEL_IS_DOS)
-				move_begin(get_partition(0, partitions));
+				move_begin(get_partition(0, g_partitions));
 			break;
 		case 'c':
-			user_cylinders = cylinders =
-				read_int(1, cylinders, 1048576, 0,
+			user_cylinders = g_cylinders =
+				read_int(1, g_cylinders, 1048576, 0,
 					"Number of cylinders");
 			if (LABEL_IS_SUN)
-				sun_set_ncyl(cylinders);
+				sun_set_ncyl(g_cylinders);
 			if (LABEL_IS_DOS)
 				warn_cylinders();
 			break;
@@ -2569,7 +2583,7 @@ xselect(void)
 #endif
 			break;
 		case 'h':
-			user_heads = heads = read_int(1, heads, 256, 0,
+			user_heads = g_heads = read_int(1, g_heads, 256, 0,
 					"Number of heads");
 			update_units();
 			break;
@@ -2594,10 +2608,10 @@ xselect(void)
 		case 'r':
 			return;
 		case 's':
-			user_sectors = sectors = read_int(1, sectors, 63, 0,
+			user_sectors = g_sectors = read_int(1, g_sectors, 63, 0,
 					   "Number of sectors");
 			if (dos_compatible_flag) {
-				sector_offset = sectors;
+				sector_offset = g_sectors;
 				printf("Warning: setting sector offset for DOS "
 					"compatiblity\n");
 			}
@@ -2686,7 +2700,7 @@ trydev(const char *device, int user_specified)
 			close(fd);
 			list_table(0);
 #if ENABLE_FEATURE_FDISK_WRITABLE
-			if (!LABEL_IS_SUN && partitions > 4){
+			if (!LABEL_IS_SUN && g_partitions > 4){
 				delete_partition(ext_index);
 			}
 #endif
@@ -2759,7 +2773,7 @@ int fdisk_main(int argc, char **argv)
 		OPT_s = (1 << 6) * ENABLE_FEATURE_FDISK_BLKSIZE,
 	};
 
-	PTR_TO_GLOBALS = xzalloc(sizeof(G));
+	INIT_G();
 
 	opt = getopt32(argv, "b:C:H:lS:u" USE_FEATURE_FDISK_BLKSIZE("s"),
 				&str_b, &str_C, &str_H, &str_S);
@@ -2873,13 +2887,13 @@ int fdisk_main(int argc, char **argv)
 		switch (c) {
 		case 'a':
 			if (LABEL_IS_DOS)
-				toggle_active(get_partition(1, partitions));
+				toggle_active(get_partition(1, g_partitions));
 			else if (LABEL_IS_SUN)
-				toggle_sunflags(get_partition(1, partitions),
+				toggle_sunflags(get_partition(1, g_partitions),
 						0x01);
 			else if (LABEL_IS_SGI)
 				sgi_set_bootpartition(
-					get_partition(1, partitions));
+					get_partition(1, g_partitions));
 			else
 				unknown_command(c);
 			break;
@@ -2902,11 +2916,11 @@ int fdisk_main(int argc, char **argv)
 			if (LABEL_IS_DOS)
 				toggle_dos_compatibility_flag();
 			else if (LABEL_IS_SUN)
-				toggle_sunflags(get_partition(1, partitions),
+				toggle_sunflags(get_partition(1, g_partitions),
 						0x10);
 			else if (LABEL_IS_SGI)
 				sgi_set_swappartition(
-						get_partition(1, partitions));
+						get_partition(1, g_partitions));
 			else
 				unknown_command(c);
 			break;
@@ -2918,9 +2932,9 @@ int fdisk_main(int argc, char **argv)
 			   get_existing_partition() only works for Linux-like
 			   partition tables */
 				if (!LABEL_IS_SGI) {
-					j = get_existing_partition(1, partitions);
+					j = get_existing_partition(1, g_partitions);
 				} else {
-					j = get_partition(1, partitions);
+					j = get_partition(1, g_partitions);
 				}
 				if (j >= 0)
 					delete_partition(j);
diff --git a/util-linux/fdisk_aix.c b/util-linux/fdisk_aix.c
index 8095fc4..69aef97 100644
--- a/util-linux/fdisk_aix.c
+++ b/util-linux/fdisk_aix.c
@@ -63,7 +63,7 @@ check_aix_label(void)
 	aix_other_endian = (aixlabel->magic == AIX_LABEL_MAGIC_SWAPPED);
 	update_units();
 	current_label_type = label_aix;
-	partitions = 1016;
+	g_partitions = 1016;
 	aix_volumes = 15;
 	aix_info();
 	/*aix_nolabel();*/              /* %% */
diff --git a/util-linux/fdisk_osf.c b/util-linux/fdisk_osf.c
index 7261382..5a7e632 100644
--- a/util-linux/fdisk_osf.c
+++ b/util-linux/fdisk_osf.c
@@ -240,8 +240,6 @@ static const char *const xbsd_fstypes[] = {
    Also fixed unaligned accesses in alpha_bootblock_checksum()
 */
 
-static int possibly_osf_label;
-
 #define FREEBSD_PARTITION       0xa5
 #define NETBSD_PARTITION        0xa9
 
@@ -876,10 +874,10 @@ xbsd_initlabel(struct partition *p)
 	d->d_flags = 0;
 #endif
 	d->d_secsize = SECTOR_SIZE;           /* bytes/sector  */
-	d->d_nsectors = sectors;              /* sectors/track */
-	d->d_ntracks = heads;                 /* tracks/cylinder (heads) */
-	d->d_ncylinders = cylinders;
-	d->d_secpercyl  = sectors * heads;    /* sectors/cylinder */
+	d->d_nsectors = g_sectors;            /* sectors/track */
+	d->d_ntracks = g_heads;               /* tracks/cylinder (heads) */
+	d->d_ncylinders = g_cylinders;
+	d->d_secpercyl  = g_sectors * g_heads;/* sectors/cylinder */
 	if (d->d_secpercyl == 0)
 		d->d_secpercyl = 1;           /* avoid segfaults */
 	d->d_secperunit = d->d_secpercyl * d->d_ncylinders;
@@ -1027,7 +1025,7 @@ xbsd_link_part(void)
 	int k, i;
 	struct partition *p;
 
-	k = get_partition(1, partitions);
+	k = get_partition(1, g_partitions);
 
 	if (!xbsd_check_new_partition(&i))
 		return;
diff --git a/util-linux/fdisk_sgi.c b/util-linux/fdisk_sgi.c
index 25e75b0..f0bd195 100644
--- a/util-linux/fdisk_sgi.c
+++ b/util-linux/fdisk_sgi.c
@@ -248,7 +248,7 @@ check_sgi_label(void)
 	}
 	update_units();
 	current_label_type = label_sgi;
-	partitions = 16;
+	g_partitions = 16;
 	sgi_volumes = 15;
 	return 1;
 }
@@ -295,7 +295,7 @@ sgi_list_table(int xtra)
 			"%d extra sects/cyl, interleave %d:1\n"
 			"%s\n"
 			"Units = %s of %d * 512 bytes\n\n",
-			disk_device, heads, sectors, cylinders,
+			disk_device, g_heads, g_sectors, g_cylinders,
 			SGI_SSWAP16(sgiparam.pcylcount),
 			SGI_SSWAP16(sgiparam.sparecyl),
 			SGI_SSWAP16(sgiparam.ilfact),
@@ -305,7 +305,7 @@ sgi_list_table(int xtra)
 		printf("\nDisk %s (SGI disk label): "
 			"%d heads, %d sectors, %d cylinders\n"
 			"Units = %s of %d * 512 bytes\n\n",
-			disk_device, heads, sectors, cylinders,
+			disk_device, g_heads, g_sectors, g_cylinders,
 			str_units(PLURAL), units_per_sector );
 	}
 
@@ -317,7 +317,7 @@ sgi_list_table(int xtra)
 	printf("----- partitions -----\n"
 		"Pt# %*s  Info     Start       End   Sectors  Id  System\n",
 		w + 2, "Device");
-	for (i = 0; i < partitions; i++) {
+	for (i = 0; i < g_partitions; i++) {
 		if (sgi_get_num_sectors(i) || debug ) {
 			uint32_t start = sgi_get_start_sector(i);
 			uint32_t len = sgi_get_num_sectors(i);
@@ -359,7 +359,7 @@ sgi_set_bootpartition(int i)
 static unsigned int
 sgi_get_lastblock(void)
 {
-	return heads * sectors * cylinders;
+	return g_heads * g_sectors * g_cylinders;
 }
 
 static void
@@ -660,7 +660,7 @@ sgi_set_entire(void)
 {
 	int n;
 
-	for (n = 10; n < partitions; n++) {
+	for (n = 10; n < g_partitions; n++) {
 		if (!sgi_get_num_sectors(n) ) {
 			sgi_set_partition(n, 0, sgi_get_lastblock(), SGI_VOLUME);
 			break;
@@ -673,7 +673,7 @@ sgi_set_volhdr(void)
 {
 	int n;
 
-	for (n = 8; n < partitions; n++) {
+	for (n = 8; n < g_partitions; n++) {
 	if (!sgi_get_num_sectors(n)) {
 		/*
 		 * 5 cylinders is an arbitrary value I like
@@ -681,8 +681,8 @@ sgi_set_volhdr(void)
 		 * (like sash, symmon, fx, ide) with ca. 3200
 		 * sectors.
 		 */
-		if (heads * sectors * 5 < sgi_get_lastblock())
-			sgi_set_partition(n, 0, heads * sectors * 5, SGI_VOLHDR);
+		if (g_heads * g_sectors * 5 < sgi_get_lastblock())
+			sgi_set_partition(n, 0, g_heads * g_sectors * 5, SGI_VOLHDR);
 			break;
 		}
 	}
@@ -783,18 +783,18 @@ create_sgilabel(void)
 	sgi_other_endian = (BYTE_ORDER == LITTLE_ENDIAN);
 	res = ioctl(fd, BLKGETSIZE, &longsectors);
 	if (!ioctl(fd, HDIO_GETGEO, &geometry)) {
-		heads = geometry.heads;
-		sectors = geometry.sectors;
+		g_heads = geometry.heads;
+		g_sectors = geometry.sectors;
 		if (res == 0) {
 			/* the get device size ioctl was successful */
-			cylinders = longsectors / (heads * sectors);
-			cylinders /= sec_fac;
+			g_cylinders = longsectors / (g_heads * g_sectors);
+			g_cylinders /= sec_fac;
 		} else {
 			/* otherwise print error and use truncated version */
-			cylinders = geometry.cylinders;
+			g_cylinders = geometry.cylinders;
 			printf(
 "Warning: BLKGETSIZE ioctl failed on %s.  Using geometry cylinder value of %d.\n"
-"This value may be truncated for devices > 33.8 GB.\n", disk_device, cylinders);
+"This value may be truncated for devices > 33.8 GB.\n", disk_device, g_cylinders);
 		}
 	}
 	for (i = 0; i < 4; i++) {
@@ -851,7 +851,7 @@ create_sgilabel(void)
 	//memset( &(sgilabel->directory), 0, sizeof(struct volume_directory)*15 );
 	//memset( &(sgilabel->partitions), 0, sizeof(struct sgi_partinfo)*16 );
 	current_label_type = label_sgi;
-	partitions = 16;
+	g_partitions = 16;
 	sgi_volumes = 15;
 	sgi_set_entire();
 	sgi_set_volhdr();
diff --git a/util-linux/fdisk_sun.c b/util-linux/fdisk_sun.c
index 274b103..fcd3818 100644
--- a/util-linux/fdisk_sun.c
+++ b/util-linux/fdisk_sun.c
@@ -84,7 +84,7 @@ set_sun_partition(int i, uint start, uint stop, int sysid)
 {
 	sunlabel->infos[i].id = sysid;
 	sunlabel->partitions[i].start_cylinder =
-		SUN_SSWAP32(start / (heads * sectors));
+		SUN_SSWAP32(start / (g_heads * g_sectors));
 	sunlabel->partitions[i].num_sectors =
 		SUN_SSWAP32(stop - start);
 	set_changed(i);
@@ -111,13 +111,13 @@ check_sun_label(void)
 "e.g. heads, sectors, cylinders and partitions\n"
 "or force a fresh label (s command in main menu)\n");
 	} else {
-		heads = SUN_SSWAP16(sunlabel->ntrks);
-		cylinders = SUN_SSWAP16(sunlabel->ncyl);
-		sectors = SUN_SSWAP16(sunlabel->nsect);
+		g_heads = SUN_SSWAP16(sunlabel->ntrks);
+		g_cylinders = SUN_SSWAP16(sunlabel->ncyl);
+		g_sectors = SUN_SSWAP16(sunlabel->nsect);
 	}
 	update_units();
 	current_label_type = label_sun;
-	partitions = 8;
+	g_partitions = 8;
 	return 1;
 }
 
@@ -273,32 +273,32 @@ create_sunlabel(void)
 	}
 	if (!p || floppy) {
 		if (!ioctl(fd, HDIO_GETGEO, &geometry)) {
-			heads = geometry.heads;
-			sectors = geometry.sectors;
-			cylinders = geometry.cylinders;
+			g_heads = geometry.heads;
+			g_sectors = geometry.sectors;
+			g_cylinders = geometry.cylinders;
 		} else {
-			heads = 0;
-			sectors = 0;
-			cylinders = 0;
+			g_heads = 0;
+			g_sectors = 0;
+			g_cylinders = 0;
 		}
 		if (floppy) {
 			sunlabel->nacyl = 0;
-			sunlabel->pcylcount = SUN_SSWAP16(cylinders);
+			sunlabel->pcylcount = SUN_SSWAP16(g_cylinders);
 			sunlabel->rspeed = SUN_SSWAP16(300);
 			sunlabel->ilfact = SUN_SSWAP16(1);
 			sunlabel->sparecyl = 0;
 		} else {
-			heads = read_int(1, heads, 1024, 0, "Heads");
-			sectors = read_int(1, sectors, 1024, 0, "Sectors/track");
-		if (cylinders)
-			cylinders = read_int(1, cylinders-2, 65535, 0, "Cylinders");
+			g_heads = read_int(1, g_heads, 1024, 0, "Heads");
+			g_sectors = read_int(1, g_sectors, 1024, 0, "Sectors/track");
+		if (g_cylinders)
+			g_cylinders = read_int(1, g_cylinders - 2, 65535, 0, "Cylinders");
 		else
-			cylinders = read_int(1, 0, 65535, 0, "Cylinders");
+			g_cylinders = read_int(1, 0, 65535, 0, "Cylinders");
 			sunlabel->nacyl = SUN_SSWAP16(read_int(0, 2, 65535, 0, "Alternate cylinders"));
-			sunlabel->pcylcount = SUN_SSWAP16(read_int(0, cylinders+SUN_SSWAP16(sunlabel->nacyl), 65535, 0, "Physical cylinders"));
+			sunlabel->pcylcount = SUN_SSWAP16(read_int(0, g_cylinders + SUN_SSWAP16(sunlabel->nacyl), 65535, 0, "Physical cylinders"));
 			sunlabel->rspeed = SUN_SSWAP16(read_int(1, 5400, 100000, 0, "Rotation speed (rpm)"));
 			sunlabel->ilfact = SUN_SSWAP16(read_int(1, 1, 32, 0, "Interleave factor"));
-			sunlabel->sparecyl = SUN_SSWAP16(read_int(0, 0, sectors, 0, "Extra sectors per cylinder"));
+			sunlabel->sparecyl = SUN_SSWAP16(read_int(0, 0, g_sectors, 0, "Extra sectors per cylinder"));
 		}
 	} else {
 		sunlabel->sparecyl = SUN_SSWAP16(p->sparecyl);
@@ -309,9 +309,9 @@ create_sunlabel(void)
 		sunlabel->nsect = SUN_SSWAP16(p->nsect);
 		sunlabel->rspeed = SUN_SSWAP16(p->rspeed);
 		sunlabel->ilfact = SUN_SSWAP16(1);
-		cylinders = p->ncyl;
-		heads = p->ntrks;
-		sectors = p->nsect;
+		g_cylinders = p->ncyl;
+		g_heads = p->ntrks;
+		g_sectors = p->nsect;
 		puts("You may change all the disk params from the x menu");
 	}
 
@@ -319,23 +319,23 @@ create_sunlabel(void)
 		"%s%s%s cyl %d alt %d hd %d sec %d",
 		p ? p->vendor : "", (p && *p->vendor) ? " " : "",
 		p ? p->model : (floppy ? "3,5\" floppy" : "Linux custom"),
-		cylinders, SUN_SSWAP16(sunlabel->nacyl), heads, sectors);
+		g_cylinders, SUN_SSWAP16(sunlabel->nacyl), g_heads, g_sectors);
 
-	sunlabel->ntrks = SUN_SSWAP16(heads);
-	sunlabel->nsect = SUN_SSWAP16(sectors);
-	sunlabel->ncyl = SUN_SSWAP16(cylinders);
+	sunlabel->ntrks = SUN_SSWAP16(g_heads);
+	sunlabel->nsect = SUN_SSWAP16(g_sectors);
+	sunlabel->ncyl = SUN_SSWAP16(g_cylinders);
 	if (floppy)
-		set_sun_partition(0, 0, cylinders * heads * sectors, LINUX_NATIVE);
+		set_sun_partition(0, 0, g_cylinders * g_heads * g_sectors, LINUX_NATIVE);
 	else {
-		if (cylinders * heads * sectors >= 150 * 2048) {
-			ndiv = cylinders - (50 * 2048 / (heads * sectors)); /* 50M swap */
+		if (g_cylinders * g_heads * g_sectors >= 150 * 2048) {
+			ndiv = g_cylinders - (50 * 2048 / (g_heads * g_sectors)); /* 50M swap */
 		} else
-			ndiv = cylinders * 2 / 3;
-		set_sun_partition(0, 0, ndiv * heads * sectors, LINUX_NATIVE);
-		set_sun_partition(1, ndiv * heads * sectors, cylinders * heads * sectors, LINUX_SWAP);
+			ndiv = g_cylinders * 2 / 3;
+		set_sun_partition(0, 0, ndiv * g_heads * g_sectors, LINUX_NATIVE);
+		set_sun_partition(1, ndiv * g_heads * g_sectors, g_cylinders * g_heads * g_sectors, LINUX_SWAP);
 		sunlabel->infos[1].flags |= 0x01; /* Not mountable */
 	}
-	set_sun_partition(2, 0, cylinders * heads * sectors, SUN_WHOLE_DISK);
+	set_sun_partition(2, 0, g_cylinders * g_heads * g_sectors, SUN_WHOLE_DISK);
 	{
 		unsigned short *ush = (unsigned short *)sunlabel;
 		unsigned short csum = 0;
@@ -365,12 +365,12 @@ fetch_sun(uint *starts, uint *lens, uint *start, uint *stop)
 	int i, continuous = 1;
 
 	*start = 0;
-	*stop = cylinders * heads * sectors;
-	for (i = 0; i < partitions; i++) {
+	*stop = g_cylinders * g_heads * g_sectors;
+	for (i = 0; i < g_partitions; i++) {
 		if (sunlabel->partitions[i].num_sectors
 		 && sunlabel->infos[i].id
 		 && sunlabel->infos[i].id != SUN_WHOLE_DISK) {
-			starts[i] = SUN_SSWAP32(sunlabel->partitions[i].start_cylinder) * heads * sectors;
+			starts[i] = SUN_SSWAP32(sunlabel->partitions[i].start_cylinder) * g_heads * g_sectors;
 			lens[i] = SUN_SSWAP32(sunlabel->partitions[i].num_sectors);
 			if (continuous) {
 				if (starts[i] == *start)
@@ -408,10 +408,10 @@ verify_sun(void)
 	int array[8];
 
 	verify_sun_starts = starts;
-	fetch_sun(starts,lens,&start,&stop);
+	fetch_sun(starts, lens, &start, &stop);
 	for (k = 0; k < 7; k++) {
 		for (i = 0; i < 8; i++) {
-			if (k && (lens[i] % (heads * sectors))) {
+			if (k && (lens[i] % (g_heads * g_sectors))) {
 				printf("Partition %d doesn't end on cylinder boundary\n", i+1);
 			}
 			if (lens[i]) {
@@ -452,7 +452,7 @@ verify_sun(void)
 		printf("No partitions defined\n");
 		return;
 	}
-	stop = cylinders * heads * sectors;
+	stop = g_cylinders * g_heads * g_sectors;
 	if (starts[array[0]])
 		printf("Unused gap - sectors 0-%d\n", starts[array[0]]);
 	for (i = 0; i < 7 && array[i+1] != -1; i++) {
@@ -499,7 +499,7 @@ add_sun_partition(int n, int sys)
 			first *= units_per_sector;
 		else
 			/* Starting sector has to be properly aligned */
-			first = (first + heads * sectors - 1) / (heads * sectors);
+			first = (first + g_heads * g_sectors - 1) / (g_heads * g_sectors);
 		if (n == 2 && first != 0)
 			printf("\
 It is highly recommended that the third partition covers the whole disk\n\
@@ -520,10 +520,10 @@ and is of type 'Whole disk'\n");
 		/* On the other hand, one should not use partitions
 		   starting at block 0 in an md, or the label will
 		   be trashed. */
-		for (i = 0; i < partitions; i++)
+		for (i = 0; i < g_partitions; i++)
 			if (lens[i] && starts[i] <= first && starts[i] + lens[i] > first)
 				break;
-		if (i < partitions && !whole_disk) {
+		if (i < g_partitions && !whole_disk) {
 			if (n == 2 && !first) {
 				whole_disk = 1;
 				break;
@@ -532,9 +532,9 @@ and is of type 'Whole disk'\n");
 		} else
 			break;
 	}
-	stop = cylinders * heads * sectors;
+	stop = g_cylinders * g_heads * g_sectors;
 	stop2 = stop;
-	for (i = 0; i < partitions; i++) {
+	for (i = 0; i < g_partitions; i++) {
 		if (starts[i] > first && starts[i] < stop)
 			stop = starts[i];
 	}
@@ -581,7 +581,7 @@ sun_delete_partition(int i)
 	if (i == 2
 	 && sunlabel->infos[i].id == SUN_WHOLE_DISK
 	 && !sunlabel->partitions[i].start_cylinder
-	 && (nsec = SUN_SSWAP32(sunlabel->partitions[i].num_sectors)) == heads * sectors * cylinders)
+	 && (nsec = SUN_SSWAP32(sunlabel->partitions[i].num_sectors)) == g_heads * g_sectors * g_cylinders)
 		printf("If you want to maintain SunOS/Solaris compatibility, "
 			"consider leaving this\n"
 			"partition as Whole disk (5), starting at 0, with %u "
@@ -631,8 +631,8 @@ sun_list_table(int xtra)
 		"%d extra sects/cyl, interleave %d:1\n"
 		"%s\n"
 		"Units = %s of %d * 512 bytes\n\n",
-			disk_device, heads, sectors, SUN_SSWAP16(sunlabel->rspeed),
-			cylinders, SUN_SSWAP16(sunlabel->nacyl),
+			disk_device, g_heads, g_sectors, SUN_SSWAP16(sunlabel->rspeed),
+			g_cylinders, SUN_SSWAP16(sunlabel->nacyl),
 			SUN_SSWAP16(sunlabel->pcylcount),
 			SUN_SSWAP16(sunlabel->sparecyl),
 			SUN_SSWAP16(sunlabel->ilfact),
@@ -642,14 +642,14 @@ sun_list_table(int xtra)
 		printf(
 	"\nDisk %s (Sun disk label): %d heads, %d sectors, %d cylinders\n"
 	"Units = %s of %d * 512 bytes\n\n",
-			disk_device, heads, sectors, cylinders,
+			disk_device, g_heads, g_sectors, g_cylinders,
 			str_units(PLURAL), units_per_sector);
 
 	printf("%*s Flag    Start       End    Blocks   Id  System\n",
 		w + 1, "Device");
-	for (i = 0; i < partitions; i++) {
+	for (i = 0; i < g_partitions; i++) {
 		if (sunlabel->partitions[i].num_sectors) {
-			uint32_t start = SUN_SSWAP32(sunlabel->partitions[i].start_cylinder) * heads * sectors;
+			uint32_t start = SUN_SSWAP32(sunlabel->partitions[i].start_cylinder) * g_heads * g_sectors;
 			uint32_t len = SUN_SSWAP32(sunlabel->partitions[i].num_sectors);
 			printf("%s %c%c %9ld %9ld %9ld%c  %2x  %s\n",
 				partname(disk_device, i+1, w),			/* device */
@@ -684,7 +684,7 @@ static void
 sun_set_xcyl(void)
 {
 	sunlabel->sparecyl =
-		SUN_SSWAP16(read_int(0, SUN_SSWAP16(sunlabel->sparecyl), sectors, 0,
+		SUN_SSWAP16(read_int(0, SUN_SSWAP16(sunlabel->sparecyl), g_sectors, 0,
 				"Extra sectors per cylinder"));
 }
 
