2010-03-22 14:29:13 +0100
diff --git a/networking/udhcp/Kbuild b/networking/udhcp/Kbuild
index 693f6c8..c09f9aa 100644
--- a/networking/udhcp/Kbuild
+++ b/networking/udhcp/Kbuild
@@ -10,7 +10,7 @@ lib-y:=
 lib-$(CONFIG_UDHCPC)     += common.o options.o packet.o signalpipe.o socket.o
 lib-$(CONFIG_UDHCPD)     += common.o options.o packet.o signalpipe.o socket.o
 
-lib-$(CONFIG_UDHCPC)     += dhcpc.o script.o
+lib-$(CONFIG_UDHCPC)     += dhcpc.o
 lib-$(CONFIG_UDHCPD)     += dhcpd.o arpping.o files.o leases.o static_leases.o
 lib-$(CONFIG_DUMPLEASES) += dumpleases.o
 lib-$(CONFIG_DHCPRELAY)  += dhcprelay.o
diff --git a/networking/udhcp/common.h b/networking/udhcp/common.h
index d740ca5..2ce6759 100644
--- a/networking/udhcp/common.h
+++ b/networking/udhcp/common.h
@@ -15,17 +15,14 @@
 
 PUSH_AND_SET_FUNCTION_VISIBILITY_TO_HIDDEN
 
-#define DEFAULT_SCRIPT   CONFIG_UDHCPC_DEFAULT_SCRIPT
-
 extern const uint8_t MAC_BCAST_ADDR[6]; /* six all-ones */
 
-/*** packet.h ***/
+
+/*** DHCP packet ***/
 
 /* DHCP protocol. See RFC 2131 */
 #define DHCP_MAGIC              0x63825363
-
 #define DHCP_OPTIONS_BUFSIZE    308
-
 #define BOOTREQUEST             1
 #define BOOTREPLY               2
 
@@ -67,6 +64,116 @@ struct BUG_bad_sizeof_struct_ip_udp_dhcp_packet {
 		[(sizeof(struct ip_udp_dhcp_packet) != 576 + CONFIG_UDHCPC_SLACK_FOR_BUGGY_SERVERS) ? -1 : 1];
 };
 
+
+/*** Options ***/
+
+enum {
+	OPTION_IP = 1,
+	OPTION_IP_PAIR,
+	OPTION_STRING,
+#if ENABLE_FEATURE_UDHCP_RFC3397
+	OPTION_STR1035,	/* RFC1035 compressed domain name list */
+#endif
+	OPTION_BOOLEAN,
+	OPTION_U8,
+	OPTION_U16,
+	OPTION_S16,
+	OPTION_U32,
+	OPTION_S32,
+	OPTION_STATIC_ROUTES,
+
+	OPTION_TYPE_MASK = 0x0f,
+	/* Client requests this option by default */
+	OPTION_REQ  = 0x10,
+	/* There can be a list of 1 or more of these */
+	OPTION_LIST = 0x20,
+};
+
+/* DHCP option codes (partial list). See RFC 2132 and
+ * http://www.iana.org/assignments/bootp-dhcp-parameters/
+ * Commented out options are handled by common option machinery,
+ * uncommented ones have spacial cases (grep for them to see).
+ */
+#define DHCP_PADDING            0x00
+#define DHCP_SUBNET             0x01
+//#define DHCP_TIME_OFFSET      0x02 /* (localtime - UTC_time) in seconds. signed */
+//#define DHCP_ROUTER           0x03
+//#define DHCP_TIME_SERVER      0x04 /* RFC 868 time server (32-bit, 0 = 1.1.1900) */
+//#define DHCP_NAME_SERVER      0x05 /* IEN 116 _really_ ancient kind of NS */
+//#define DHCP_DNS_SERVER       0x06
+//#define DHCP_LOG_SERVER       0x07 /* port 704 UDP log (not syslog)
+//#define DHCP_COOKIE_SERVER    0x08 /* "quote of the day" server */
+//#define DHCP_LPR_SERVER       0x09
+#define DHCP_HOST_NAME          0x0c /* either client informs server or server gives name to client */
+//#define DHCP_BOOT_SIZE        0x0d
+//#define DHCP_DOMAIN_NAME      0x0f /* server gives domain suffix */
+//#define DHCP_SWAP_SERVER      0x10
+//#define DHCP_ROOT_PATH        0x11
+//#define DHCP_IP_TTL           0x17
+//#define DHCP_MTU              0x1a
+//#define DHCP_BROADCAST        0x1c
+//#define DHCP_NIS_DOMAIN       0x28
+//#define DHCP_NIS_SERVER       0x29
+//#define DHCP_NTP_SERVER       0x2a
+//#define DHCP_WINS_SERVER      0x2c
+#define DHCP_REQUESTED_IP       0x32 /* sent by client if specific IP is wanted */
+#define DHCP_LEASE_TIME         0x33
+#define DHCP_OPTION_OVERLOAD    0x34
+#define DHCP_MESSAGE_TYPE       0x35
+#define DHCP_SERVER_ID          0x36 /* by default server's IP */
+#define DHCP_PARAM_REQ          0x37 /* list of options client wants */
+//#define DHCP_ERR_MESSAGE      0x38 /* error message when sending NAK etc */
+#define DHCP_MAX_SIZE           0x39
+#define DHCP_VENDOR             0x3c /* client's vendor (a string) */
+#define DHCP_CLIENT_ID          0x3d /* by default client's MAC addr, but may be arbitrarily long */
+//#define DHCP_TFTP_SERVER_NAME 0x42 /* same as 'sname' field */
+//#define DHCP_BOOT_FILE        0x43 /* same as 'file' field */
+//#define DHCP_USER_CLASS       0x4d /* RFC 3004. set of LASCII strings. "I am a printer" etc */
+#define DHCP_FQDN               0x51 /* client asks to update DNS to map its FQDN to its new IP */
+//#define DHCP_DOMAIN_SEARCH    0x77 /* RFC 3397. set of ASCIZ string, DNS-style compressed */
+//#define DHCP_STATIC_ROUTES    0x79 /* RFC 3442. (mask,ip,router) tuples */
+//#define DHCP_WPAD             0xfc /* MSIE's Web Proxy Autodiscovery Protocol */
+#define DHCP_END                0xff
+
+/* Offsets in option byte sequence */
+#define OPT_CODE                0
+#define OPT_LEN                 1
+#define OPT_DATA                2
+/* Bits in "overload" option */
+#define OPTION_FIELD            0
+#define FILE_FIELD              1
+#define SNAME_FIELD             2
+
+/* DHCP_MESSAGE_TYPE values */
+#define DHCPDISCOVER            1 /* client -> server */
+#define DHCPOFFER               2 /* client <- server */
+#define DHCPREQUEST             3 /* client -> server */
+#define DHCPDECLINE             4 /* client -> server */
+#define DHCPACK                 5 /* client <- server */
+#define DHCPNAK                 6 /* client <- server */
+#define DHCPRELEASE             7 /* client -> server */
+#define DHCPINFORM              8 /* client -> server */
+#define DHCP_MINTYPE DHCPDISCOVER
+#define DHCP_MAXTYPE DHCPINFORM
+
+struct dhcp_option {
+	uint8_t flags;
+	uint8_t code;
+};
+
+extern const struct dhcp_option dhcp_options[];
+extern const char dhcp_option_strings[];
+extern const uint8_t dhcp_option_lengths[];
+
+uint8_t *udhcp_get_option(struct dhcp_packet *packet, int code) FAST_FUNC;
+int udhcp_end_option(uint8_t *optionptr) FAST_FUNC;
+void udhcp_add_option_string(uint8_t *optionptr, uint8_t *string) FAST_FUNC;
+void udhcp_add_simple_option(uint8_t *optionptr, uint8_t code, uint32_t data) FAST_FUNC;
+#if ENABLE_FEATURE_UDHCP_RFC3397
+char *dname_dec(const uint8_t *cstr, int clen, const char *pre) FAST_FUNC;
+uint8_t *dname_enc(const uint8_t *cstr, int clen, const char *src, int *retlen) FAST_FUNC;
+#endif
+
 // RFC 2131  Table 5: Fields and options used by DHCP clients
 //
 // Field      DHCPDISCOVER          DHCPREQUEST           DHCPDECLINE,
@@ -132,6 +239,33 @@ struct BUG_bad_sizeof_struct_ip_udp_dhcp_packet {
 // All others                 MAY           MAY              MUST NOT
 
 
+/*** Logging ***/
+
+#if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 1
+extern unsigned dhcp_verbose;
+# define log1(...) do { if (dhcp_verbose >= 1) bb_info_msg(__VA_ARGS__); } while (0)
+# if CONFIG_UDHCP_DEBUG >= 2
+void udhcp_dump_packet(struct dhcp_packet *packet) FAST_FUNC;
+#  define log2(...) do { if (dhcp_verbose >= 2) bb_info_msg(__VA_ARGS__); } while (0)
+# else
+#  define udhcp_dump_packet(...) ((void)0)
+#  define log2(...) ((void)0)
+# endif
+# if CONFIG_UDHCP_DEBUG >= 3
+#  define log3(...) do { if (dhcp_verbose >= 3) bb_info_msg(__VA_ARGS__); } while (0)
+# else
+#  define log3(...) ((void)0)
+# endif
+#else
+# define udhcp_dump_packet(...) ((void)0)
+# define log1(...) ((void)0)
+# define log2(...) ((void)0)
+# define log3(...) ((void)0)
+#endif
+
+
+/*** Other shared functions ***/
+
 uint16_t udhcp_checksum(void *addr, int count) FAST_FUNC;
 
 void udhcp_init_header(struct dhcp_packet *packet, char type) FAST_FUNC;
@@ -147,24 +281,14 @@ int udhcp_send_kernel_packet(struct dhcp_packet *dhcp_pkt,
 		uint32_t source_ip, int source_port,
 		uint32_t dest_ip, int dest_port) FAST_FUNC;
 
-
-/**/
-
-void udhcp_run_script(struct dhcp_packet *packet, const char *name) FAST_FUNC;
-
-// Still need to clean these up...
-
-/* from options.h */
-#define get_option		udhcp_get_option
-#define end_option		udhcp_end_option
-#define add_option_string	udhcp_add_option_string
-#define add_simple_option	udhcp_add_simple_option
-
 void udhcp_sp_setup(void) FAST_FUNC;
 int udhcp_sp_fd_set(fd_set *rfds, int extra_fd) FAST_FUNC;
 int udhcp_sp_read(const fd_set *rfds) FAST_FUNC;
+
 int udhcp_read_interface(const char *interface, int *ifindex, uint32_t *nip, uint8_t *mac) FAST_FUNC;
+
 int udhcp_listen_socket(/*uint32_t ip,*/ int port, const char *inf) FAST_FUNC;
+
 /* Returns 1 if no reply received */
 int arpping(uint32_t test_nip,
 		const uint8_t *safe_mac,
@@ -172,28 +296,6 @@ int arpping(uint32_t test_nip,
 		uint8_t *from_mac,
 		const char *interface) FAST_FUNC;
 
-#if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 1
-extern unsigned dhcp_verbose;
-# define log1(...) do { if (dhcp_verbose >= 1) bb_info_msg(__VA_ARGS__); } while (0)
-# if CONFIG_UDHCP_DEBUG >= 2
-void udhcp_dump_packet(struct dhcp_packet *packet) FAST_FUNC;
-#  define log2(...) do { if (dhcp_verbose >= 2) bb_info_msg(__VA_ARGS__); } while (0)
-# else
-#  define udhcp_dump_packet(...) ((void)0)
-#  define log2(...) ((void)0)
-# endif
-# if CONFIG_UDHCP_DEBUG >= 3
-#  define log3(...) do { if (dhcp_verbose >= 3) bb_info_msg(__VA_ARGS__); } while (0)
-# else
-#  define log3(...) ((void)0)
-# endif
-#else
-# define udhcp_dump_packet(...) ((void)0)
-# define log1(...) ((void)0)
-# define log2(...) ((void)0)
-# define log3(...) ((void)0)
-#endif
-
 POP_SAVED_FUNCTION_VISIBILITY
 
 #endif
diff --git a/networking/udhcp/dhcpc.c b/networking/udhcp/dhcpc.c
index e79feb7..7587509 100644
--- a/networking/udhcp/dhcpc.c
+++ b/networking/udhcp/dhcpc.c
@@ -24,7 +24,6 @@
 #include "common.h"
 #include "dhcpd.h"
 #include "dhcpc.h"
-#include "options.h"
 
 #include <asm/types.h>
 #if (defined(__GLIBC__) && __GLIBC__ >= 2 && __GLIBC_MINOR__ >= 1) || defined(_NEWLIB_VERSION)
@@ -36,34 +35,278 @@
 #endif
 #include <linux/filter.h>
 
+/* struct client_config_t client_config is in bb_common_bufsiz1 */
 
-static int sockfd = -1;
 
-#define LISTEN_NONE   0
-#define LISTEN_KERNEL 1
-#define LISTEN_RAW    2
-static smallint listen_mode;
+/*** Script execution code ***/
 
-/* initial state: (re)start DHCP negotiation */
-#define INIT_SELECTING  0
-/* discover was sent, DHCPOFFER reply received */
-#define REQUESTING      1
-/* select/renew was sent, DHCPACK reply received */
-#define BOUND           2
-/* half of lease passed, want to renew it by sending unicast renew requests */
-#define RENEWING        3
-/* renew requests were not answered, lease is almost over, send broadcast renew */
-#define REBINDING       4
-/* manually requested renew (SIGUSR1) */
-#define RENEW_REQUESTED 5
-/* release, possibly manually requested (SIGUSR2) */
-#define RELEASED        6
-static smallint state;
+/* get a rough idea of how long an option will be (rounding up...) */
+static const uint8_t len_of_option_as_string[] = {
+	[OPTION_IP] =		sizeof("255.255.255.255 "),
+	[OPTION_IP_PAIR] =	sizeof("255.255.255.255 ") * 2,
+	[OPTION_STATIC_ROUTES]= sizeof("255.255.255.255/32 255.255.255.255 "),
+	[OPTION_STRING] =	1,
+#if ENABLE_FEATURE_UDHCP_RFC3397
+	[OPTION_STR1035] =	1,
+#endif
+	[OPTION_BOOLEAN] =	sizeof("yes "),
+	[OPTION_U8] =		sizeof("255 "),
+	[OPTION_U16] =		sizeof("65535 "),
+	[OPTION_S16] =		sizeof("-32768 "),
+	[OPTION_U32] =		sizeof("4294967295 "),
+	[OPTION_S32] =		sizeof("-2147483684 "),
+};
+
+/* note: ip is a pointer to an IP in network order, possibly misaliged */
+static int sprint_nip(char *dest, const char *pre, const uint8_t *ip)
+{
+	return sprintf(dest, "%s%u.%u.%u.%u", pre, ip[0], ip[1], ip[2], ip[3]);
+}
 
-/* struct client_config_t client_config is in bb_common_bufsiz1 */
+/* really simple implementation, just count the bits */
+static int mton(uint32_t mask)
+{
+	int i = 0;
+	mask = ntohl(mask); /* 111110000-like bit pattern */
+	while (mask) {
+		i++;
+		mask <<= 1;
+	}
+	return i;
+}
+
+/* Create "opt_name=opt_value" string */
+static NOINLINE char *xmalloc_optname_optval(uint8_t *option, const struct dhcp_option *type_p, const char *opt_name)
+{
+	unsigned upper_length;
+	int len, type, optlen;
+	uint16_t val_u16;
+	int16_t val_s16;
+	uint32_t val_u32;
+	int32_t val_s32;
+	char *dest, *ret;
+
+	/* option points to OPT_DATA, need to go back and get OPT_LEN */
+	len = option[OPT_LEN - OPT_DATA];
+	type = type_p->flags & OPTION_TYPE_MASK;
+	optlen = dhcp_option_lengths[type];
+	upper_length = len_of_option_as_string[type] * (len / optlen);
+
+	dest = ret = xmalloc(upper_length + strlen(opt_name) + 2);
+	dest += sprintf(ret, "%s=", opt_name);
+
+	while (len >= optlen) {
+		switch (type) {
+		case OPTION_IP_PAIR:
+			dest += sprint_nip(dest, "", option);
+			*dest++ = '/';
+			option += 4;
+			optlen = 4;
+		case OPTION_IP:
+			dest += sprint_nip(dest, "", option);
+// TODO: it can be a list only if (type_p->flags & OPTION_LIST).
+// Should we bail out/warn if we see multi-ip option which is
+// not allowed to be such? For example, DHCP_BROADCAST...
+			break;
+		case OPTION_BOOLEAN:
+			dest += sprintf(dest, *option ? "yes" : "no");
+			break;
+		case OPTION_U8:
+			dest += sprintf(dest, "%u", *option);
+			break;
+		case OPTION_U16:
+			move_from_unaligned16(val_u16, option);
+			dest += sprintf(dest, "%u", ntohs(val_u16));
+			break;
+		case OPTION_S16:
+			move_from_unaligned16(val_s16, option);
+			dest += sprintf(dest, "%d", ntohs(val_s16));
+			break;
+		case OPTION_U32:
+			move_from_unaligned32(val_u32, option);
+			dest += sprintf(dest, "%lu", (unsigned long) ntohl(val_u32));
+			break;
+		case OPTION_S32:
+			move_from_unaligned32(val_s32, option);
+			dest += sprintf(dest, "%ld", (long) ntohl(val_s32));
+			break;
+		case OPTION_STRING:
+			memcpy(dest, option, len);
+			dest[len] = '\0';
+			return ret;	 /* Short circuit this case */
+		case OPTION_STATIC_ROUTES: {
+			/* Option binary format:
+			 * mask [one byte, 0..32]
+			 * ip [big endian, 0..4 bytes depending on mask]
+			 * router [big endian, 4 bytes]
+			 * may be repeated
+			 *
+			 * We convert it to a string "IP/MASK ROUTER IP2/MASK2 ROUTER2"
+			 */
+			const char *pfx = "";
+
+			while (len >= 1 + 4) { /* mask + 0-byte ip + router */
+				uint32_t nip;
+				uint8_t *p;
+				unsigned mask;
+				int bytes;
+
+				mask = *option++;
+				if (mask > 32)
+					break;
+				len--;
+
+				nip = 0;
+				p = (void*) &nip;
+				bytes = (mask + 7) / 8; /* 0 -> 0, 1..8 -> 1, 9..16 -> 2 etc */
+				while (--bytes >= 0) {
+					*p++ = *option++;
+					len--;
+				}
+				if (len < 4)
+					break;
+
+				/* print ip/mask */
+				dest += sprint_nip(dest, pfx, (void*) &nip);
+				pfx = " ";
+				dest += sprintf(dest, "/%u ", mask);
+				/* print router */
+				dest += sprint_nip(dest, "", option);
+				option += 4;
+				len -= 4;
+			}
+
+			return ret;
+		}
+#if ENABLE_FEATURE_UDHCP_RFC3397
+		case OPTION_STR1035:
+			/* unpack option into dest; use ret for prefix (i.e., "optname=") */
+			dest = dname_dec(option, len, ret);
+			if (dest) {
+				free(ret);
+				return dest;
+			}
+			/* error. return "optname=" string */
+			return ret;
+#endif
+		}
+		option += optlen;
+		len -= optlen;
+		if (len <= 0)
+			break;
+		*dest++ = ' ';
+		*dest = '\0';
+	}
+	return ret;
+}
+
+/* put all the parameters into the environment */
+static char **fill_envp(struct dhcp_packet *packet)
+{
+	int num_options = 0;
+	int i;
+	char **envp, **curr;
+	const char *opt_name;
+	uint8_t *temp;
+	uint8_t over = 0;
+
+	if (packet) {
+		for (i = 0; dhcp_options[i].code; i++) {
+			if (udhcp_get_option(packet, dhcp_options[i].code)) {
+				num_options++;
+				if (dhcp_options[i].code == DHCP_SUBNET)
+					num_options++; /* for mton */
+			}
+		}
+		if (packet->siaddr_nip)
+			num_options++;
+		temp = udhcp_get_option(packet, DHCP_OPTION_OVERLOAD);
+		if (temp)
+			over = *temp;
+		if (!(over & FILE_FIELD) && packet->file[0])
+			num_options++;
+		if (!(over & SNAME_FIELD) && packet->sname[0])
+			num_options++;
+	}
+
+	curr = envp = xzalloc(sizeof(char *) * (num_options + 3));
+	*curr = xasprintf("interface=%s", client_config.interface);
+	putenv(*curr++);
+
+	if (packet == NULL)
+		return envp;
+
+	*curr = xmalloc(sizeof("ip=255.255.255.255"));
+	sprint_nip(*curr, "ip=", (uint8_t *) &packet->yiaddr);
+	putenv(*curr++);
+
+	opt_name = dhcp_option_strings;
+	i = 0;
+	while (*opt_name) {
+		temp = udhcp_get_option(packet, dhcp_options[i].code);
+		if (!temp)
+			goto next;
+		*curr = xmalloc_optname_optval(temp, &dhcp_options[i], opt_name);
+		putenv(*curr++);
+
+		/* Fill in a subnet bits option for things like /24 */
+		if (dhcp_options[i].code == DHCP_SUBNET) {
+			uint32_t subnet;
+			move_from_unaligned32(subnet, temp);
+			*curr = xasprintf("mask=%d", mton(subnet));
+			putenv(*curr++);
+		}
+ next:
+		opt_name += strlen(opt_name) + 1;
+		i++;
+	}
+	if (packet->siaddr_nip) {
+		*curr = xmalloc(sizeof("siaddr=255.255.255.255"));
+		sprint_nip(*curr, "siaddr=", (uint8_t *) &packet->siaddr_nip);
+		putenv(*curr++);
+	}
+	if (!(over & FILE_FIELD) && packet->file[0]) {
+		/* watch out for invalid packets */
+		*curr = xasprintf("boot_file=%."DHCP_PKT_FILE_LEN_STR"s", packet->file);
+		putenv(*curr++);
+	}
+	if (!(over & SNAME_FIELD) && packet->sname[0]) {
+		/* watch out for invalid packets */
+		*curr = xasprintf("sname=%."DHCP_PKT_SNAME_LEN_STR"s", packet->sname);
+		putenv(*curr++);
+	}
+	return envp;
+}
+
+/* Call a script with a par file and env vars */
+static void udhcp_run_script(struct dhcp_packet *packet, const char *name)
+{
+	char **envp, **curr;
+	char *argv[3];
+
+	if (client_config.script == NULL)
+		return;
+
+	envp = fill_envp(packet);
+
+	/* call script */
+	log1("Executing %s %s", client_config.script, name);
+	argv[0] = (char*) client_config.script;
+	argv[1] = (char*) name;
+	argv[2] = NULL;
+	spawn_and_wait(argv);
+
+	for (curr = envp; *curr; curr++) {
+		log2(" %s", *curr);
+		bb_unsetenv(*curr);
+		free(*curr);
+	}
+	free(envp);
+}
 
 
-/* Create a random xid */
+/*** Sending/receiving packets ***/
+
 static ALWAYS_INLINE uint32_t random_xid(void)
 {
 	return rand();
@@ -75,16 +318,16 @@ static void init_packet(struct dhcp_packet *packet, char type)
 	udhcp_init_header(packet, type);
 	memcpy(packet->chaddr, client_config.client_mac, 6);
 	if (client_config.clientid)
-		add_option_string(packet->options, client_config.clientid);
+		udhcp_add_option_string(packet->options, client_config.clientid);
 	if (client_config.hostname)
-		add_option_string(packet->options, client_config.hostname);
+		udhcp_add_option_string(packet->options, client_config.hostname);
 	if (client_config.fqdn)
-		add_option_string(packet->options, client_config.fqdn);
+		udhcp_add_option_string(packet->options, client_config.fqdn);
 	if (type != DHCPDECLINE
 	 && type != DHCPRELEASE
 	 && client_config.vendorclass
 	) {
-		add_option_string(packet->options, client_config.vendorclass);
+		udhcp_add_option_string(packet->options, client_config.vendorclass);
 	}
 }
 
@@ -94,7 +337,7 @@ static void init_packet(struct dhcp_packet *packet, char type)
 static void add_param_req_option(struct dhcp_packet *packet)
 {
 	uint8_t c;
-	int end = end_option(packet->options);
+	int end = udhcp_end_option(packet->options);
 	int i, len = 0;
 
 	for (i = 0; (c = dhcp_options[i].code) != 0; i++) {
@@ -148,10 +391,10 @@ static int send_discover(uint32_t xid, uint32_t requested)
 	init_packet(&packet, DHCPDISCOVER);
 	packet.xid = xid;
 	if (requested)
-		add_simple_option(packet.options, DHCP_REQUESTED_IP, requested);
+		udhcp_add_simple_option(packet.options, DHCP_REQUESTED_IP, requested);
 	/* Explicitly saying that we want RFC-compliant packets helps
 	 * some buggy DHCP servers to NOT send bigger packets */
-	add_simple_option(packet.options, DHCP_MAX_SIZE, htons(576));
+	udhcp_add_simple_option(packet.options, DHCP_MAX_SIZE, htons(576));
 	add_param_req_option(&packet);
 
 	bb_info_msg("Sending discover...");
@@ -169,8 +412,8 @@ static int send_select(uint32_t xid, uint32_t server, uint32_t requested)
 
 	init_packet(&packet, DHCPREQUEST);
 	packet.xid = xid;
-	add_simple_option(packet.options, DHCP_REQUESTED_IP, requested);
-	add_simple_option(packet.options, DHCP_SERVER_ID, server);
+	udhcp_add_simple_option(packet.options, DHCP_REQUESTED_IP, requested);
+	udhcp_add_simple_option(packet.options, DHCP_SERVER_ID, server);
 	add_param_req_option(&packet);
 
 	addr.s_addr = requested;
@@ -204,8 +447,8 @@ static int send_decline(uint32_t xid, uint32_t server, uint32_t requested)
 
 	init_packet(&packet, DHCPDECLINE);
 	packet.xid = xid;
-	add_simple_option(packet.options, DHCP_REQUESTED_IP, requested);
-	add_simple_option(packet.options, DHCP_SERVER_ID, server);
+	udhcp_add_simple_option(packet.options, DHCP_REQUESTED_IP, requested);
+	udhcp_add_simple_option(packet.options, DHCP_SERVER_ID, server);
 
 	bb_info_msg("Sending decline...");
 	return raw_bcast_from_client_config_ifindex(&packet);
@@ -221,7 +464,7 @@ static int send_release(uint32_t server, uint32_t ciaddr)
 	packet.xid = random_xid();
 	packet.ciaddr = ciaddr;
 
-	add_simple_option(packet.options, DHCP_SERVER_ID, server);
+	udhcp_add_simple_option(packet.options, DHCP_SERVER_ID, server);
 
 	bb_info_msg("Sending release...");
 	return udhcp_send_kernel_packet(&packet, ciaddr, CLIENT_PORT, server, SERVER_PORT);
@@ -297,6 +540,32 @@ static NOINLINE int udhcp_recv_raw_packet(struct dhcp_packet *dhcp_pkt, int fd)
 	return bytes - (sizeof(packet.ip) + sizeof(packet.udp));
 }
 
+
+/*** Main ***/
+
+static int sockfd = -1;
+
+#define LISTEN_NONE   0
+#define LISTEN_KERNEL 1
+#define LISTEN_RAW    2
+static smallint listen_mode;
+
+/* initial state: (re)start DHCP negotiation */
+#define INIT_SELECTING  0
+/* discover was sent, DHCPOFFER reply received */
+#define REQUESTING      1
+/* select/renew was sent, DHCPACK reply received */
+#define BOUND           2
+/* half of lease passed, want to renew it by sending unicast renew requests */
+#define RENEWING        3
+/* renew requests were not answered, lease is almost over, send broadcast renew */
+#define REBINDING       4
+/* manually requested renew (SIGUSR1) */
+#define RENEW_REQUESTED 5
+/* release, possibly manually requested (SIGUSR2) */
+#define RELEASED        6
+static smallint state;
+
 static int udhcp_raw_socket(int ifindex)
 {
 	int fd;
@@ -368,7 +637,6 @@ static int udhcp_raw_socket(int ifindex)
 	return fd;
 }
 
-/* just a little helper */
 static void change_listen_mode(int new_mode)
 {
 	log1("Entering listen mode: %s",
@@ -389,7 +657,6 @@ static void change_listen_mode(int new_mode)
 	/* else LISTEN_NONE: sockfd stays closed */
 }
 
-/* perform a renew */
 static void perform_renew(void)
 {
 	bb_info_msg("Performing a DHCP renew");
@@ -412,7 +679,6 @@ static void perform_renew(void)
 	}
 }
 
-/* perform a release */
 static void perform_release(uint32_t requested_ip, uint32_t server_addr)
 {
 	char buffer[sizeof("255.255.255.255")];
@@ -434,16 +700,6 @@ static void perform_release(uint32_t requested_ip, uint32_t server_addr)
 	state = RELEASED;
 }
 
-#if BB_MMU
-static void client_background(void)
-{
-	bb_daemonize(0);
-	logmode &= ~LOGMODE_STDIO;
-	/* rewrite pidfile, as our pid is different now */
-	write_pidfile(client_config.pidfile);
-}
-#endif
-
 static uint8_t* alloc_dhcp_option(int code, const char *str, int extra)
 {
 	uint8_t *storage;
@@ -455,6 +711,16 @@ static uint8_t* alloc_dhcp_option(int code, const char *str, int extra)
 	return storage;
 }
 
+#if BB_MMU
+static void client_background(void)
+{
+	bb_daemonize(0);
+	logmode &= ~LOGMODE_STDIO;
+	/* rewrite pidfile, as our pid is different now */
+	write_pidfile(client_config.pidfile);
+}
+#endif
+
 int udhcpc_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int udhcpc_main(int argc UNUSED_PARAM, char **argv)
 {
@@ -541,7 +807,7 @@ int udhcpc_main(int argc UNUSED_PARAM, char **argv)
 	IF_FEATURE_UDHCP_PORT(SERVER_PORT = 67;)
 	IF_FEATURE_UDHCP_PORT(CLIENT_PORT = 68;)
 	client_config.interface = "eth0";
-	client_config.script = DEFAULT_SCRIPT;
+	client_config.script = CONFIG_UDHCPC_DEFAULT_SCRIPT;
 	str_V = "udhcp "BB_VER;
 
 	/* Parse command line */
@@ -861,7 +1127,7 @@ int udhcpc_main(int argc UNUSED_PARAM, char **argv)
 			continue;
 		}
 
-		message = get_option(&packet, DHCP_MESSAGE_TYPE);
+		message = udhcp_get_option(&packet, DHCP_MESSAGE_TYPE);
 		if (message == NULL) {
 			bb_error_msg("no message type option, ignoring packet");
 			continue;
@@ -872,7 +1138,7 @@ int udhcpc_main(int argc UNUSED_PARAM, char **argv)
 			/* Must be a DHCPOFFER to one of our xid's */
 			if (*message == DHCPOFFER) {
 		/* TODO: why we don't just fetch server's IP from IP header? */
-				temp = get_option(&packet, DHCP_SERVER_ID);
+				temp = udhcp_get_option(&packet, DHCP_SERVER_ID);
 				if (!temp) {
 					bb_error_msg("no server ID in message");
 					continue;
@@ -895,7 +1161,7 @@ int udhcpc_main(int argc UNUSED_PARAM, char **argv)
 		case RENEW_REQUESTED:
 		case REBINDING:
 			if (*message == DHCPACK) {
-				temp = get_option(&packet, DHCP_LEASE_TIME);
+				temp = udhcp_get_option(&packet, DHCP_LEASE_TIME);
 				if (!temp) {
 					bb_error_msg("no lease time with ACK, using 1 hour lease");
 					lease_seconds = 60 * 60;
diff --git a/networking/udhcp/dhcpd.c b/networking/udhcp/dhcpd.c
index d6e90cd..93e06b2 100644
--- a/networking/udhcp/dhcpd.c
+++ b/networking/udhcp/dhcpd.c
@@ -25,7 +25,6 @@
 #include "common.h"
 #include "dhcpc.h"
 #include "dhcpd.h"
-#include "options.h"
 
 
 /* Send a packet to a specific mac address and ip address by creating our own ip packet */
@@ -94,7 +93,7 @@ static void init_packet(struct dhcp_packet *packet, struct dhcp_packet *oldpacke
 	packet->flags = oldpacket->flags;
 	packet->gateway_nip = oldpacket->gateway_nip;
 	packet->ciaddr = oldpacket->ciaddr;
-	add_simple_option(packet->options, DHCP_SERVER_ID, server_config.server_nip);
+	udhcp_add_simple_option(packet->options, DHCP_SERVER_ID, server_config.server_nip);
 }
 
 /* Fill options field, siaddr_nip, and sname and boot_file fields.
@@ -106,7 +105,7 @@ static void add_server_options(struct dhcp_packet *packet)
 
 	while (curr) {
 		if (curr->data[OPT_CODE] != DHCP_LEASE_TIME)
-			add_option_string(packet->options, curr->data);
+			udhcp_add_option_string(packet->options, curr->data);
 		curr = curr->next;
 	}
 
@@ -121,7 +120,7 @@ static void add_server_options(struct dhcp_packet *packet)
 static uint32_t select_lease_time(struct dhcp_packet *packet)
 {
 	uint32_t lease_time_sec = server_config.max_lease_sec;
-	uint8_t *lease_time_opt = get_option(packet, DHCP_LEASE_TIME);
+	uint8_t *lease_time_opt = udhcp_get_option(packet, DHCP_LEASE_TIME);
 	if (lease_time_opt) {
 		move_from_unaligned32(lease_time_sec, lease_time_opt);
 		lease_time_sec = ntohl(lease_time_sec);
@@ -159,7 +158,7 @@ static void send_offer(struct dhcp_packet *oldpacket, uint32_t static_lease_nip,
 			packet.yiaddr = lease->lease_nip;
 		}
 		/* Or: if client has requested an IP */
-		else if ((req_ip_opt = get_option(oldpacket, DHCP_REQUESTED_IP)) != NULL
+		else if ((req_ip_opt = udhcp_get_option(oldpacket, DHCP_REQUESTED_IP)) != NULL
 		 /* (read IP) */
 		 && (move_from_unaligned32(req_nip, req_ip_opt), 1)
 		 /* and the IP is in the lease range */
@@ -182,7 +181,7 @@ static void send_offer(struct dhcp_packet *oldpacket, uint32_t static_lease_nip,
 			return;
 		}
 		/* Reserve the IP for a short time hoping to get DHCPREQUEST soon */
-		p_host_name = (const char*) get_option(oldpacket, DHCP_HOST_NAME);
+		p_host_name = (const char*) udhcp_get_option(oldpacket, DHCP_HOST_NAME);
 		lease = add_lease(packet.chaddr, packet.yiaddr,
 				server_config.offer_time,
 				p_host_name,
@@ -195,7 +194,7 @@ static void send_offer(struct dhcp_packet *oldpacket, uint32_t static_lease_nip,
 	}
 
 	lease_time_sec = select_lease_time(oldpacket);
-	add_simple_option(packet.options, DHCP_LEASE_TIME, htonl(lease_time_sec));
+	udhcp_add_simple_option(packet.options, DHCP_LEASE_TIME, htonl(lease_time_sec));
 	add_server_options(&packet);
 
 	addr.s_addr = packet.yiaddr;
@@ -225,7 +224,7 @@ static void send_ACK(struct dhcp_packet *oldpacket, uint32_t yiaddr)
 	packet.yiaddr = yiaddr;
 
 	lease_time_sec = select_lease_time(oldpacket);
-	add_simple_option(packet.options, DHCP_LEASE_TIME, htonl(lease_time_sec));
+	udhcp_add_simple_option(packet.options, DHCP_LEASE_TIME, htonl(lease_time_sec));
 
 	add_server_options(&packet);
 
@@ -233,7 +232,7 @@ static void send_ACK(struct dhcp_packet *oldpacket, uint32_t yiaddr)
 	bb_info_msg("Sending ACK to %s", inet_ntoa(addr));
 	send_packet(&packet, /*force_bcast:*/ 0);
 
-	p_host_name = (const char*) get_option(oldpacket, DHCP_HOST_NAME);
+	p_host_name = (const char*) udhcp_get_option(oldpacket, DHCP_HOST_NAME);
 	add_lease(packet.chaddr, packet.yiaddr,
 		lease_time_sec,
 		p_host_name,
@@ -422,7 +421,7 @@ int udhcpd_main(int argc UNUSED_PARAM, char **argv)
 			bb_error_msg("not a REQUEST, ignoring packet");
 			continue;
 		}
-		state = get_option(&packet, DHCP_MESSAGE_TYPE);
+		state = udhcp_get_option(&packet, DHCP_MESSAGE_TYPE);
 		if (state == NULL || state[0] < DHCP_MINTYPE || state[0] > DHCP_MAXTYPE) {
 			bb_error_msg("no or bad message type option, ignoring packet");
 			continue;
@@ -441,7 +440,7 @@ int udhcpd_main(int argc UNUSED_PARAM, char **argv)
 		}
 
 		/* Get REQUESTED_IP and SERVER_ID if present */
-		server_id_opt = get_option(&packet, DHCP_SERVER_ID);
+		server_id_opt = udhcp_get_option(&packet, DHCP_SERVER_ID);
 		if (server_id_opt) {
 			uint32_t server_id_net;
 			move_from_unaligned32(server_id_net, server_id_opt);
@@ -451,7 +450,7 @@ int udhcpd_main(int argc UNUSED_PARAM, char **argv)
 				continue;
 			}
 		}
-		requested_opt = get_option(&packet, DHCP_REQUESTED_IP);
+		requested_opt = udhcp_get_option(&packet, DHCP_REQUESTED_IP);
 		if (requested_opt) {
 			move_from_unaligned32(requested_nip, requested_opt);
 		}
diff --git a/networking/udhcp/dhcprelay.c b/networking/udhcp/dhcprelay.c
index a7e715f..9f6ac69 100644
--- a/networking/udhcp/dhcprelay.c
+++ b/networking/udhcp/dhcprelay.c
@@ -11,7 +11,6 @@
  */
 
 #include "common.h"
-#include "options.h"
 
 #define SERVER_PORT      67
 #define SELECT_TIMEOUT    5 /* select timeout in sec. */
@@ -105,7 +104,7 @@ static int get_dhcp_packet_type(struct dhcp_packet *p)
 	if (p->op != BOOTREQUEST && p->op != BOOTREPLY)
 		return -1;
 	/* get message type option */
-	op = get_option(p, DHCP_MESSAGE_TYPE);
+	op = udhcp_get_option(p, DHCP_MESSAGE_TYPE);
 	if (op != NULL)
 		return op[0];
 	return -1;
diff --git a/networking/udhcp/domain_codec.c b/networking/udhcp/domain_codec.c
index 45354e7..c00b4ed 100644
--- a/networking/udhcp/domain_codec.c
+++ b/networking/udhcp/domain_codec.c
@@ -10,7 +10,6 @@
 #if ENABLE_FEATURE_UDHCP_RFC3397
 
 #include "common.h"
-#include "options.h"
 
 #define NS_MAXDNAME  1025	/* max domain name length */
 #define NS_MAXCDNAME  255	/* max compressed domain name length */
diff --git a/networking/udhcp/files.c b/networking/udhcp/files.c
index 62f4a38..a23e886 100644
--- a/networking/udhcp/files.c
+++ b/networking/udhcp/files.c
@@ -10,7 +10,6 @@
 
 #include "common.h"
 #include "dhcpd.h"
-#include "options.h"
 
 #if BB_LITTLE_ENDIAN
 static inline uint64_t hton64(uint64_t v)
diff --git a/networking/udhcp/options.c b/networking/udhcp/options.c
index 29a2640..b4d2d2d 100644
--- a/networking/udhcp/options.c
+++ b/networking/udhcp/options.c
@@ -7,8 +7,6 @@
  */
 
 #include "common.h"
-#include "dhcpd.h"
-#include "options.h"
 
 
 /* Supported options are easily added here.
@@ -111,7 +109,6 @@ const char dhcp_option_strings[] ALIGN1 =
 	"wpad" "\0"        /* DHCP_WPAD          */
 	;
 
-
 /* Lengths of the different option types */
 const uint8_t dhcp_option_lengths[] ALIGN1 = {
 	[OPTION_IP] =      4,
@@ -144,9 +141,8 @@ static void log_option(const char *pfx, const uint8_t *opt)
 # define log_option(pfx, opt) ((void)0)
 #endif
 
-
 /* get an option with bounds checking (warning, result is not aligned). */
-uint8_t* FAST_FUNC get_option(struct dhcp_packet *packet, int code)
+uint8_t* FAST_FUNC udhcp_get_option(struct dhcp_packet *packet, int code)
 {
 	uint8_t *optionptr;
 	int len;
@@ -162,7 +158,7 @@ uint8_t* FAST_FUNC get_option(struct dhcp_packet *packet, int code)
 	rem = sizeof(packet->options);
 	while (1) {
 		if (rem <= 0) {
-			bb_error_msg("bogus packet, malformed option field");
+			bb_error_msg("bad packet, malformed option field");
 			return NULL;
 		}
 		if (optionptr[OPT_CODE] == DHCP_PADDING) {
@@ -209,9 +205,8 @@ uint8_t* FAST_FUNC get_option(struct dhcp_packet *packet, int code)
 	return NULL;
 }
 
-
 /* return the position of the 'end' option (no bounds checking) */
-int FAST_FUNC end_option(uint8_t *optionptr)
+int FAST_FUNC udhcp_end_option(uint8_t *optionptr)
 {
 	int i = 0;
 
@@ -223,12 +218,11 @@ int FAST_FUNC end_option(uint8_t *optionptr)
 	return i;
 }
 
-
 /* add an option string to the options */
 /* option bytes: [code][len][data1][data2]..[dataLEN] */
-void FAST_FUNC add_option_string(uint8_t *optionptr, uint8_t *string)
+void FAST_FUNC udhcp_add_option_string(uint8_t *optionptr, uint8_t *string)
 {
-	int end = end_option(optionptr);
+	int end = udhcp_end_option(optionptr);
 
 	/* end position + string length + option code/length + end option */
 	if (end + string[OPT_LEN] + 2 + 1 >= DHCP_OPTIONS_BUFSIZE) {
@@ -241,9 +235,8 @@ void FAST_FUNC add_option_string(uint8_t *optionptr, uint8_t *string)
 	optionptr[end + string[OPT_LEN] + 2] = DHCP_END;
 }
 
-
 /* add a one to four byte option to a packet */
-void FAST_FUNC add_simple_option(uint8_t *optionptr, uint8_t code, uint32_t data)
+void FAST_FUNC udhcp_add_simple_option(uint8_t *optionptr, uint8_t code, uint32_t data)
 {
 	const struct dhcp_option *dh;
 
@@ -258,7 +251,7 @@ void FAST_FUNC add_simple_option(uint8_t *optionptr, uint8_t code, uint32_t data
 				data <<= 8 * (4 - len);
 			/* Assignment is unaligned! */
 			move_to_unaligned32(&option[OPT_DATA], data);
-			add_option_string(optionptr, option);
+			udhcp_add_option_string(optionptr, option);
 			return;
 		}
 	}
diff --git a/networking/udhcp/options.h b/networking/udhcp/options.h
deleted file mode 100644
index 3ca4dc4..0000000
--- a/networking/udhcp/options.h
+++ /dev/null
@@ -1,119 +0,0 @@
-/* vi: set sw=4 ts=4: */
-/* options.h */
-#ifndef UDHCP_OPTIONS_H
-#define UDHCP_OPTIONS_H 1
-
-PUSH_AND_SET_FUNCTION_VISIBILITY_TO_HIDDEN
-
-
-enum {
-	OPTION_IP = 1,
-	OPTION_IP_PAIR,
-	OPTION_STRING,
-#if ENABLE_FEATURE_UDHCP_RFC3397
-	OPTION_STR1035,	/* RFC1035 compressed domain name list */
-#endif
-	OPTION_BOOLEAN,
-	OPTION_U8,
-	OPTION_U16,
-	OPTION_S16,
-	OPTION_U32,
-	OPTION_S32,
-	OPTION_STATIC_ROUTES,
-
-	OPTION_TYPE_MASK = 0x0f,
-	/* Client requests this option by default */
-	OPTION_REQ  = 0x10,
-	/* There can be a list of 1 or more of these */
-	OPTION_LIST = 0x20,
-};
-
-/* DHCP option codes (partial list). See RFC 2132 and
- * http://www.iana.org/assignments/bootp-dhcp-parameters/
- * Commented out options are handled by common option machinery,
- * uncommented ones have spacial cases (grep for them to see).
- */
-#define DHCP_PADDING            0x00
-#define DHCP_SUBNET             0x01
-//#define DHCP_TIME_OFFSET      0x02 /* (localtime - UTC_time) in seconds. signed */
-//#define DHCP_ROUTER           0x03
-//#define DHCP_TIME_SERVER      0x04 /* RFC 868 time server (32-bit, 0 = 1.1.1900) */
-//#define DHCP_NAME_SERVER      0x05 /* IEN 116 _really_ ancient kind of NS */
-//#define DHCP_DNS_SERVER       0x06
-//#define DHCP_LOG_SERVER       0x07 /* port 704 UDP log (not syslog)
-//#define DHCP_COOKIE_SERVER    0x08 /* "quote of the day" server */
-//#define DHCP_LPR_SERVER       0x09
-#define DHCP_HOST_NAME          0x0c /* either client informs server or server gives name to client */
-//#define DHCP_BOOT_SIZE        0x0d
-//#define DHCP_DOMAIN_NAME      0x0f /* server gives domain suffix */
-//#define DHCP_SWAP_SERVER      0x10
-//#define DHCP_ROOT_PATH        0x11
-//#define DHCP_IP_TTL           0x17
-//#define DHCP_MTU              0x1a
-//#define DHCP_BROADCAST        0x1c
-//#define DHCP_NIS_DOMAIN       0x28
-//#define DHCP_NIS_SERVER       0x29
-//#define DHCP_NTP_SERVER       0x2a
-//#define DHCP_WINS_SERVER      0x2c
-#define DHCP_REQUESTED_IP       0x32 /* sent by client if specific IP is wanted */
-#define DHCP_LEASE_TIME         0x33
-#define DHCP_OPTION_OVERLOAD    0x34
-#define DHCP_MESSAGE_TYPE       0x35
-#define DHCP_SERVER_ID          0x36 /* by default server's IP */
-#define DHCP_PARAM_REQ          0x37 /* list of options client wants */
-//#define DHCP_ERR_MESSAGE      0x38 /* error message when sending NAK etc */
-#define DHCP_MAX_SIZE           0x39
-#define DHCP_VENDOR             0x3c /* client's vendor (a string) */
-#define DHCP_CLIENT_ID          0x3d /* by default client's MAC addr, but may be arbitrarily long */
-//#define DHCP_TFTP_SERVER_NAME 0x42 /* same as 'sname' field */
-//#define DHCP_BOOT_FILE        0x43 /* same as 'file' field */
-//#define DHCP_USER_CLASS       0x4d /* RFC 3004. set of LASCII strings. "I am a printer" etc */
-#define DHCP_FQDN               0x51 /* client asks to update DNS to map its FQDN to its new IP */
-//#define DHCP_DOMAIN_SEARCH    0x77 /* RFC 3397. set of ASCIZ string, DNS-style compressed */
-//#define DHCP_STATIC_ROUTES    0x79 /* RFC 3442. (mask,ip,router) tuples */
-//#define DHCP_WPAD             0xfc /* MSIE's Web Proxy Autodiscovery Protocol */
-#define DHCP_END                0xff
-
-/* Offsets in option byte sequence */
-#define OPT_CODE                0
-#define OPT_LEN                 1
-#define OPT_DATA                2
-/* Bits in "overload" option */
-#define OPTION_FIELD            0
-#define FILE_FIELD              1
-#define SNAME_FIELD             2
-
-/* DHCP_MESSAGE_TYPE values */
-#define DHCPDISCOVER            1 /* client -> server */
-#define DHCPOFFER               2 /* client <- server */
-#define DHCPREQUEST             3 /* client -> server */
-#define DHCPDECLINE             4 /* client -> server */
-#define DHCPACK                 5 /* client <- server */
-#define DHCPNAK                 6 /* client <- server */
-#define DHCPRELEASE             7 /* client -> server */
-#define DHCPINFORM              8 /* client -> server */
-#define DHCP_MINTYPE DHCPDISCOVER
-#define DHCP_MAXTYPE DHCPINFORM
-
-
-struct dhcp_option {
-	uint8_t flags;
-	uint8_t code;
-};
-
-extern const struct dhcp_option dhcp_options[];
-extern const char dhcp_option_strings[];
-extern const uint8_t dhcp_option_lengths[];
-
-uint8_t *get_option(struct dhcp_packet *packet, int code) FAST_FUNC;
-int end_option(uint8_t *optionptr) FAST_FUNC;
-void add_option_string(uint8_t *optionptr, uint8_t *string) FAST_FUNC;
-void add_simple_option(uint8_t *optionptr, uint8_t code, uint32_t data) FAST_FUNC;
-#if ENABLE_FEATURE_UDHCP_RFC3397
-char *dname_dec(const uint8_t *cstr, int clen, const char *pre) FAST_FUNC;
-uint8_t *dname_enc(const uint8_t *cstr, int clen, const char *src, int *retlen) FAST_FUNC;
-#endif
-
-POP_SAVED_FUNCTION_VISIBILITY
-
-#endif
diff --git a/networking/udhcp/packet.c b/networking/udhcp/packet.c
index 84d8309..03d5e1f 100644
--- a/networking/udhcp/packet.c
+++ b/networking/udhcp/packet.c
@@ -17,7 +17,6 @@
 
 #include "common.h"
 #include "dhcpd.h"
-#include "options.h"
 
 void FAST_FUNC udhcp_init_header(struct dhcp_packet *packet, char type)
 {
@@ -34,7 +33,7 @@ void FAST_FUNC udhcp_init_header(struct dhcp_packet *packet, char type)
 	packet->cookie = htonl(DHCP_MAGIC);
 	if (DHCP_END != 0)
 		packet->options[0] = DHCP_END;
-	add_simple_option(packet->options, DHCP_MESSAGE_TYPE, type);
+	udhcp_add_simple_option(packet->options, DHCP_MESSAGE_TYPE, type);
 }
 
 #if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 2
@@ -105,7 +104,7 @@ int FAST_FUNC udhcp_recv_kernel_packet(struct dhcp_packet *packet, int fd)
 	udhcp_dump_packet(packet);
 
 	if (packet->op == BOOTREQUEST) {
-		vendor = get_option(packet, DHCP_VENDOR);
+		vendor = udhcp_get_option(packet, DHCP_VENDOR);
 		if (vendor) {
 #if 0
 			static const char broken_vendors[][8] = {
@@ -221,7 +220,7 @@ int FAST_FUNC udhcp_send_raw_packet(struct dhcp_packet *dhcp_pkt,
 
 	/* Currently we send full-sized DHCP packets (zero padded).
 	 * If you need to change this: last byte of the packet is
-	 * packet.data.options[end_option(packet.data.options)]
+	 * packet.data.options[udhcp_end_option(packet.data.options)]
 	 */
 	udhcp_dump_packet(dhcp_pkt);
 	result = sendto(fd, &packet, IP_UPD_DHCP_SIZE, 0,
diff --git a/networking/udhcp/script.c b/networking/udhcp/script.c
deleted file mode 100644
index 400fd2b..0000000
--- a/networking/udhcp/script.c
+++ /dev/null
@@ -1,283 +0,0 @@
-/* vi: set sw=4 ts=4: */
-/* script.c
- *
- * Functions to call the DHCP client notification scripts
- *
- * Russ Dill <Russ.Dill@asu.edu> July 2001
- *
- * Licensed under GPLv2 or later, see file LICENSE in this tarball for details.
- */
-
-#include "common.h"
-#include "dhcpc.h"
-#include "options.h"
-
-
-/* get a rough idea of how long an option will be (rounding up...) */
-static const uint8_t len_of_option_as_string[] = {
-	[OPTION_IP] =		sizeof("255.255.255.255 "),
-	[OPTION_IP_PAIR] =	sizeof("255.255.255.255 ") * 2,
-	[OPTION_STATIC_ROUTES]= sizeof("255.255.255.255/32 255.255.255.255 "),
-	[OPTION_STRING] =	1,
-#if ENABLE_FEATURE_UDHCP_RFC3397
-	[OPTION_STR1035] =	1,
-#endif
-	[OPTION_BOOLEAN] =	sizeof("yes "),
-	[OPTION_U8] =		sizeof("255 "),
-	[OPTION_U16] =		sizeof("65535 "),
-	[OPTION_S16] =		sizeof("-32768 "),
-	[OPTION_U32] =		sizeof("4294967295 "),
-	[OPTION_S32] =		sizeof("-2147483684 "),
-};
-
-
-/* note: ip is a pointer to an IP in network order, possibly misaliged */
-static int sprint_nip(char *dest, const char *pre, const uint8_t *ip)
-{
-	return sprintf(dest, "%s%u.%u.%u.%u", pre, ip[0], ip[1], ip[2], ip[3]);
-}
-
-
-/* really simple implementation, just count the bits */
-static int mton(uint32_t mask)
-{
-	int i = 0;
-	mask = ntohl(mask); /* 111110000-like bit pattern */
-	while (mask) {
-		i++;
-		mask <<= 1;
-	}
-	return i;
-}
-
-
-/* Create "opt_name=opt_value" string */
-static NOINLINE char *xmalloc_optname_optval(uint8_t *option, const struct dhcp_option *type_p, const char *opt_name)
-{
-	unsigned upper_length;
-	int len, type, optlen;
-	uint16_t val_u16;
-	int16_t val_s16;
-	uint32_t val_u32;
-	int32_t val_s32;
-	char *dest, *ret;
-
-	/* option points to OPT_DATA, need to go back and get OPT_LEN */
-	len = option[OPT_LEN - OPT_DATA];
-	type = type_p->flags & OPTION_TYPE_MASK;
-	optlen = dhcp_option_lengths[type];
-	upper_length = len_of_option_as_string[type] * (len / optlen);
-
-	dest = ret = xmalloc(upper_length + strlen(opt_name) + 2);
-	dest += sprintf(ret, "%s=", opt_name);
-
-	while (len >= optlen) {
-		switch (type) {
-		case OPTION_IP_PAIR:
-			dest += sprint_nip(dest, "", option);
-			*dest++ = '/';
-			option += 4;
-			optlen = 4;
-		case OPTION_IP:
-			dest += sprint_nip(dest, "", option);
-// TODO: it can be a list only if (type_p->flags & OPTION_LIST).
-// Should we bail out/warn if we see multi-ip option which is
-// not allowed to be such? For example, DHCP_BROADCAST...
-			break;
-		case OPTION_BOOLEAN:
-			dest += sprintf(dest, *option ? "yes" : "no");
-			break;
-		case OPTION_U8:
-			dest += sprintf(dest, "%u", *option);
-			break;
-		case OPTION_U16:
-			move_from_unaligned16(val_u16, option);
-			dest += sprintf(dest, "%u", ntohs(val_u16));
-			break;
-		case OPTION_S16:
-			move_from_unaligned16(val_s16, option);
-			dest += sprintf(dest, "%d", ntohs(val_s16));
-			break;
-		case OPTION_U32:
-			move_from_unaligned32(val_u32, option);
-			dest += sprintf(dest, "%lu", (unsigned long) ntohl(val_u32));
-			break;
-		case OPTION_S32:
-			move_from_unaligned32(val_s32, option);
-			dest += sprintf(dest, "%ld", (long) ntohl(val_s32));
-			break;
-		case OPTION_STRING:
-			memcpy(dest, option, len);
-			dest[len] = '\0';
-			return ret;	 /* Short circuit this case */
-		case OPTION_STATIC_ROUTES: {
-			/* Option binary format:
-			 * mask [one byte, 0..32]
-			 * ip [big endian, 0..4 bytes depending on mask]
-			 * router [big endian, 4 bytes]
-			 * may be repeated
-			 *
-			 * We convert it to a string "IP/MASK ROUTER IP2/MASK2 ROUTER2"
-			 */
-			const char *pfx = "";
-
-			while (len >= 1 + 4) { /* mask + 0-byte ip + router */
-				uint32_t nip;
-				uint8_t *p;
-				unsigned mask;
-				int bytes;
-
-				mask = *option++;
-				if (mask > 32)
-					break;
-				len--;
-
-				nip = 0;
-				p = (void*) &nip;
-				bytes = (mask + 7) / 8; /* 0 -> 0, 1..8 -> 1, 9..16 -> 2 etc */
-				while (--bytes >= 0) {
-					*p++ = *option++;
-					len--;
-				}
-				if (len < 4)
-					break;
-
-				/* print ip/mask */
-				dest += sprint_nip(dest, pfx, (void*) &nip);
-				pfx = " ";
-				dest += sprintf(dest, "/%u ", mask);
-				/* print router */
-				dest += sprint_nip(dest, "", option);
-				option += 4;
-				len -= 4;
-			}
-
-			return ret;
-		}
-#if ENABLE_FEATURE_UDHCP_RFC3397
-		case OPTION_STR1035:
-			/* unpack option into dest; use ret for prefix (i.e., "optname=") */
-			dest = dname_dec(option, len, ret);
-			if (dest) {
-				free(ret);
-				return dest;
-			}
-			/* error. return "optname=" string */
-			return ret;
-#endif
-		}
-		option += optlen;
-		len -= optlen;
-		if (len <= 0)
-			break;
-		*dest++ = ' ';
-		*dest = '\0';
-	}
-	return ret;
-}
-
-
-/* put all the parameters into the environment */
-static char **fill_envp(struct dhcp_packet *packet)
-{
-	int num_options = 0;
-	int i;
-	char **envp, **curr;
-	const char *opt_name;
-	uint8_t *temp;
-	uint8_t over = 0;
-
-	if (packet) {
-		for (i = 0; dhcp_options[i].code; i++) {
-			if (get_option(packet, dhcp_options[i].code)) {
-				num_options++;
-				if (dhcp_options[i].code == DHCP_SUBNET)
-					num_options++; /* for mton */
-			}
-		}
-		if (packet->siaddr_nip)
-			num_options++;
-		temp = get_option(packet, DHCP_OPTION_OVERLOAD);
-		if (temp)
-			over = *temp;
-		if (!(over & FILE_FIELD) && packet->file[0])
-			num_options++;
-		if (!(over & SNAME_FIELD) && packet->sname[0])
-			num_options++;
-	}
-
-	curr = envp = xzalloc(sizeof(char *) * (num_options + 3));
-	*curr = xasprintf("interface=%s", client_config.interface);
-	putenv(*curr++);
-
-	if (packet == NULL)
-		return envp;
-
-	*curr = xmalloc(sizeof("ip=255.255.255.255"));
-	sprint_nip(*curr, "ip=", (uint8_t *) &packet->yiaddr);
-	putenv(*curr++);
-
-	opt_name = dhcp_option_strings;
-	i = 0;
-	while (*opt_name) {
-		temp = get_option(packet, dhcp_options[i].code);
-		if (!temp)
-			goto next;
-		*curr = xmalloc_optname_optval(temp, &dhcp_options[i], opt_name);
-		putenv(*curr++);
-
-		/* Fill in a subnet bits option for things like /24 */
-		if (dhcp_options[i].code == DHCP_SUBNET) {
-			uint32_t subnet;
-			move_from_unaligned32(subnet, temp);
-			*curr = xasprintf("mask=%d", mton(subnet));
-			putenv(*curr++);
-		}
- next:
-		opt_name += strlen(opt_name) + 1;
-		i++;
-	}
-	if (packet->siaddr_nip) {
-		*curr = xmalloc(sizeof("siaddr=255.255.255.255"));
-		sprint_nip(*curr, "siaddr=", (uint8_t *) &packet->siaddr_nip);
-		putenv(*curr++);
-	}
-	if (!(over & FILE_FIELD) && packet->file[0]) {
-		/* watch out for invalid packets */
-		*curr = xasprintf("boot_file=%."DHCP_PKT_FILE_LEN_STR"s", packet->file);
-		putenv(*curr++);
-	}
-	if (!(over & SNAME_FIELD) && packet->sname[0]) {
-		/* watch out for invalid packets */
-		*curr = xasprintf("sname=%."DHCP_PKT_SNAME_LEN_STR"s", packet->sname);
-		putenv(*curr++);
-	}
-	return envp;
-}
-
-
-/* Call a script with a par file and env vars */
-void FAST_FUNC udhcp_run_script(struct dhcp_packet *packet, const char *name)
-{
-	char **envp, **curr;
-	char *argv[3];
-
-	if (client_config.script == NULL)
-		return;
-
-	envp = fill_envp(packet);
-
-	/* call script */
-	log1("Executing %s %s", client_config.script, name);
-	argv[0] = (char*) client_config.script;
-	argv[1] = (char*) name;
-	argv[2] = NULL;
-	spawn_and_wait(argv);
-
-	for (curr = envp; *curr; curr++) {
-		log2(" %s", *curr);
-		bb_unsetenv(*curr);
-		free(*curr);
-	}
-	free(envp);
-}
