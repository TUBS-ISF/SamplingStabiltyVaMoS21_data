2008-03-17 09:25:05 +0000
diff --git a/TODO_config_nommu b/TODO_config_nommu
index e628568..21960a0 100644
--- a/TODO_config_nommu
+++ b/TODO_config_nommu
@@ -497,27 +497,16 @@ CONFIG_FEATURE_VOLUMEID_REISERFS=y
 CONFIG_FEATURE_VOLUMEID_FAT=y
 CONFIG_FEATURE_VOLUMEID_HFS=y
 CONFIG_FEATURE_VOLUMEID_JFS=y
-CONFIG_FEATURE_VOLUMEID_UFS=y
 CONFIG_FEATURE_VOLUMEID_XFS=y
 CONFIG_FEATURE_VOLUMEID_NTFS=y
 CONFIG_FEATURE_VOLUMEID_ISO9660=y
 CONFIG_FEATURE_VOLUMEID_UDF=y
 CONFIG_FEATURE_VOLUMEID_LUKS=y
 CONFIG_FEATURE_VOLUMEID_LINUXSWAP=y
-CONFIG_FEATURE_VOLUMEID_LVM=y
 CONFIG_FEATURE_VOLUMEID_CRAMFS=y
-CONFIG_FEATURE_VOLUMEID_HPFS=y
 CONFIG_FEATURE_VOLUMEID_ROMFS=y
 CONFIG_FEATURE_VOLUMEID_SYSV=y
-CONFIG_FEATURE_VOLUMEID_MINIX=y
 CONFIG_FEATURE_VOLUMEID_OCFS2=y
-CONFIG_FEATURE_VOLUMEID_HIGHPOINTRAID=y
-CONFIG_FEATURE_VOLUMEID_ISWRAID=y
-CONFIG_FEATURE_VOLUMEID_LSIRAID=y
-CONFIG_FEATURE_VOLUMEID_VIARAID=y
-CONFIG_FEATURE_VOLUMEID_SILICONRAID=y
-CONFIG_FEATURE_VOLUMEID_NVIDIARAID=y
-CONFIG_FEATURE_VOLUMEID_PROMISERAID=y
 CONFIG_FEATURE_VOLUMEID_LINUXRAID=y
 CONFIG_MOUNT=y
 CONFIG_FEATURE_MOUNT_FAKE=y
diff --git a/e2fsprogs/Config.in b/e2fsprogs/Config.in
index 521273e..fe8d031 100644
--- a/e2fsprogs/Config.in
+++ b/e2fsprogs/Config.in
@@ -12,13 +12,13 @@ config CHATTR
 	  chattr changes the file attributes on a second extended file system.
 
 ### config E2FSCK
-### 	bool "e2fsck"
-### 	default n
-### 	help
-### 	  e2fsck is used to check Linux second extended file systems (ext2fs).
-### 	  e2fsck also supports ext2 filesystems countaining a journal (ext3).
-### 	  The normal compat symlinks 'fsck.ext2' and 'fsck.ext3' are also
-### 	  provided.
+###	bool "e2fsck"
+###	default n
+###	help
+###	  e2fsck is used to check Linux second extended file systems (ext2fs).
+###	  e2fsck also supports ext2 filesystems countaining a journal (ext3).
+###	  The normal compat symlinks 'fsck.ext2' and 'fsck.ext3' are also
+###	  provided.
 
 config FSCK
 	bool "fsck"
@@ -35,33 +35,34 @@ config LSATTR
 	  lsattr lists the file attributes on a second extended file system.
 
 ### config MKE2FS
-### 	bool "mke2fs"
-### 	default n
-### 	help
-### 	  mke2fs is used to create an ext2/ext3 filesystem.  The normal compat
-### 	  symlinks 'mkfs.ext2' and 'mkfs.ext3' are also provided.
+###	bool "mke2fs"
+###	default n
+###	help
+###	  mke2fs is used to create an ext2/ext3 filesystem.  The normal compat
+###	  symlinks 'mkfs.ext2' and 'mkfs.ext3' are also provided.
 
 ### config TUNE2FS
-### 	bool "tune2fs"
-### 	default n
-### 	help
-### 	  tune2fs allows the system administrator to adjust various tunable
-### 	  filesystem parameters on Linux ext2/ext3 filesystems.
+###	bool "tune2fs"
+###	default n
+###	help
+###	  tune2fs allows the system administrator to adjust various tunable
+###	  filesystem parameters on Linux ext2/ext3 filesystems.
 
 ### config E2LABEL
-### 	bool "e2label"
-### 	default n
-### 	depends on TUNE2FS
-### 	help
-### 	  e2label will display or change the filesystem label on the ext2
-### 	  filesystem located on device.
+###	bool "e2label"
+###	default n
+###	depends on TUNE2FS
+###	help
+###	  e2label will display or change the filesystem label on the ext2
+###	  filesystem located on device.
 
+### NB: this one is now provided by util-linux/volume_id/*
 ### config FINDFS
-### 	bool "findfs"
-### 	default n
-### 	depends on TUNE2FS
-### 	help
-### 	  findfs will search the disks in the system looking for a filesystem
-### 	  which has a label matching label or a UUID equal to uuid.
+###	bool "findfs"
+###	default n
+###	depends on TUNE2FS
+###	help
+###	  findfs will search the disks in the system looking for a filesystem
+###	  which has a label matching label or a UUID equal to uuid.
 
 endmenu
diff --git a/scripts/defconfig b/scripts/defconfig
index 6dbe5d1..6d9997e 100644
--- a/scripts/defconfig
+++ b/scripts/defconfig
@@ -493,27 +493,16 @@ CONFIG_FEATURE_USE_TERMIOS=y
 # CONFIG_FEATURE_VOLUMEID_FAT is not set
 # CONFIG_FEATURE_VOLUMEID_HFS is not set
 # CONFIG_FEATURE_VOLUMEID_JFS is not set
-# CONFIG_FEATURE_VOLUMEID_UFS is not set
 # CONFIG_FEATURE_VOLUMEID_XFS is not set
 # CONFIG_FEATURE_VOLUMEID_NTFS is not set
 # CONFIG_FEATURE_VOLUMEID_ISO9660 is not set
 # CONFIG_FEATURE_VOLUMEID_UDF is not set
 # CONFIG_FEATURE_VOLUMEID_LUKS is not set
 # CONFIG_FEATURE_VOLUMEID_LINUXSWAP is not set
-# CONFIG_FEATURE_VOLUMEID_LVM is not set
 # CONFIG_FEATURE_VOLUMEID_CRAMFS is not set
-# CONFIG_FEATURE_VOLUMEID_HPFS is not set
 # CONFIG_FEATURE_VOLUMEID_ROMFS is not set
 # CONFIG_FEATURE_VOLUMEID_SYSV is not set
-# CONFIG_FEATURE_VOLUMEID_MINIX is not set
 # CONFIG_FEATURE_VOLUMEID_OCFS2 is not set
-# CONFIG_FEATURE_VOLUMEID_HIGHPOINTRAID is not set
-# CONFIG_FEATURE_VOLUMEID_ISWRAID is not set
-# CONFIG_FEATURE_VOLUMEID_LSIRAID is not set
-# CONFIG_FEATURE_VOLUMEID_VIARAID is not set
-# CONFIG_FEATURE_VOLUMEID_SILICONRAID is not set
-# CONFIG_FEATURE_VOLUMEID_NVIDIARAID is not set
-# CONFIG_FEATURE_VOLUMEID_PROMISERAID is not set
 # CONFIG_FEATURE_VOLUMEID_LINUXRAID is not set
 CONFIG_MOUNT=y
 CONFIG_FEATURE_MOUNT_FAKE=y
diff --git a/util-linux/Config.in b/util-linux/Config.in
index a1e843a..1c3fe88 100644
--- a/util-linux/Config.in
+++ b/util-linux/Config.in
@@ -159,7 +159,7 @@ config FINDFS
 	  package.  However, the e2fsprogs version only support ext2/3.  This
 	  version supports those in addition to FAT, swap, and ReiserFS.
 	  WARNING:
-	  With all submodules selected, it will add ~9k to busybox.
+	  With all submodules selected, it will add ~8k to busybox.
 
 config FREERAMDISK
 	bool "freeramdisk"
@@ -427,12 +427,12 @@ config FEATURE_VOLUMEID_JFS
 	help
 	  TODO
 
-config FEATURE_VOLUMEID_UFS
-	bool "ufs filesystem"
-	default n
-	depends on VOLUMEID
-	help
-	  TODO
+### config FEATURE_VOLUMEID_UFS
+###	bool "ufs filesystem"
+###	default n
+###	depends on VOLUMEID
+###	help
+###	  TODO
 
 config FEATURE_VOLUMEID_XFS
 	bool "xfs filesystem"
@@ -476,12 +476,12 @@ config FEATURE_VOLUMEID_LINUXSWAP
 	help
 	  TODO
 
-config FEATURE_VOLUMEID_LVM
-	bool "lvm"
-	default n
-	depends on VOLUMEID
-	help
-	  TODO
+### config FEATURE_VOLUMEID_LVM
+###	bool "lvm"
+###	default n
+###	depends on VOLUMEID
+###	help
+###	  TODO
 
 config FEATURE_VOLUMEID_CRAMFS
 	bool "cramfs filesystem"
@@ -490,12 +490,12 @@ config FEATURE_VOLUMEID_CRAMFS
 	help
 	  TODO
 
-config FEATURE_VOLUMEID_HPFS
-	bool "hpfs filesystem"
-	default n
-	depends on VOLUMEID
-	help
-	  TODO
+### config FEATURE_VOLUMEID_HPFS
+###	bool "hpfs filesystem"
+###	default n
+###	depends on VOLUMEID
+###	help
+###	  TODO
 
 config FEATURE_VOLUMEID_ROMFS
 	bool "romfs filesystem"
@@ -511,27 +511,27 @@ config FEATURE_VOLUMEID_SYSV
 	help
 	  TODO
 
-config FEATURE_VOLUMEID_MINIX
-	bool "minix filesystem"
-	default n
-	depends on VOLUMEID
-	help
-	  TODO
+### config FEATURE_VOLUMEID_MINIX
+###	bool "minix filesystem"
+###	default n
+###	depends on VOLUMEID
+###	help
+###	  TODO
 
 ### These only detect partition tables - not used (yet?)
 ### config FEATURE_VOLUMEID_MAC
-### 	bool "mac filesystem"
-### 	default n
-### 	depends on VOLUMEID
-### 	help
-### 	  TODO
+###	bool "mac filesystem"
+###	default n
+###	depends on VOLUMEID
+###	help
+###	  TODO
 ### 
 ### config FEATURE_VOLUMEID_MSDOS
-### 	bool "msdos filesystem"
-### 	default n
-### 	depends on VOLUMEID
-### 	help
-### 	  TODO
+###	bool "msdos filesystem"
+###	default n
+###	depends on VOLUMEID
+###	help
+###	  TODO
 
 config FEATURE_VOLUMEID_OCFS2
 	bool "ocfs2 filesystem"
@@ -540,54 +540,54 @@ config FEATURE_VOLUMEID_OCFS2
 	help
 	  TODO
 
-config FEATURE_VOLUMEID_HIGHPOINTRAID
-	bool "highpoint raid"
-	default n
-	depends on VOLUMEID
-	help
-	  TODO
-
-config FEATURE_VOLUMEID_ISWRAID
-	bool "intel raid"
-	default n
-	depends on VOLUMEID
-	help
-	  TODO
-
-config FEATURE_VOLUMEID_LSIRAID
-	bool "lsi raid"
-	default n
-	depends on VOLUMEID
-	help
-	  TODO
-
-config FEATURE_VOLUMEID_VIARAID
-	bool "via raid"
-	default n
-	depends on VOLUMEID
-	help
-	  TODO
-
-config FEATURE_VOLUMEID_SILICONRAID
-	bool "silicon raid"
-	default n
-	depends on VOLUMEID
-	help
-	  TODO
-
-config FEATURE_VOLUMEID_NVIDIARAID
-	bool "nvidia raid"
-	default n
-	depends on VOLUMEID
-	help
-	  TODO
-
-config FEATURE_VOLUMEID_PROMISERAID
-	bool "promise raid"
-	default n
-	depends on VOLUMEID
-	help
-	  TODO
+### config FEATURE_VOLUMEID_HIGHPOINTRAID
+###	bool "highpoint raid"
+###	default n
+###	depends on VOLUMEID
+###	help
+###	  TODO
+
+### config FEATURE_VOLUMEID_ISWRAID
+###	bool "intel raid"
+###	default n
+###	depends on VOLUMEID
+###	help
+###	  TODO
+
+### config FEATURE_VOLUMEID_LSIRAID
+###	bool "lsi raid"
+###	default n
+###	depends on VOLUMEID
+###	help
+###	  TODO
+
+### config FEATURE_VOLUMEID_VIARAID
+###	bool "via raid"
+###	default n
+###	depends on VOLUMEID
+###	help
+###	  TODO
+
+### config FEATURE_VOLUMEID_SILICONRAID
+###	bool "silicon raid"
+###	default n
+###	depends on VOLUMEID
+###	help
+###	  TODO
+
+### config FEATURE_VOLUMEID_NVIDIARAID
+###	bool "nvidia raid"
+###	default n
+###	depends on VOLUMEID
+###	help
+###	  TODO
+
+### config FEATURE_VOLUMEID_PROMISERAID
+###	bool "promise raid"
+###	default n
+###	depends on VOLUMEID
+###	help
+###	  TODO
 
 config FEATURE_VOLUMEID_LINUXRAID
 	bool "linuxraid"
diff --git a/util-linux/volume_id/Kbuild b/util-linux/volume_id/Kbuild
index 96cd880..54b95f0 100644
--- a/util-linux/volume_id/Kbuild
+++ b/util-linux/volume_id/Kbuild
@@ -13,30 +13,29 @@ lib-$(CONFIG_VOLUMEID)                          += volume_id.o util.o
 lib-$(CONFIG_FEATURE_VOLUMEID_EXT)              += ext.o
 lib-$(CONFIG_FEATURE_VOLUMEID_FAT)              += fat.o
 lib-$(CONFIG_FEATURE_VOLUMEID_HFS)              += hfs.o
-lib-$(CONFIG_FEATURE_VOLUMEID_HIGHPOINTRAID)    += highpoint.o
-lib-$(CONFIG_FEATURE_VOLUMEID_ISWRAID)          += isw_raid.o
-lib-$(CONFIG_FEATURE_VOLUMEID_LSIRAID)          += lsi_raid.o
-lib-$(CONFIG_FEATURE_VOLUMEID_VIARAID)          += via_raid.o
-lib-$(CONFIG_FEATURE_VOLUMEID_SILICONRAID)      += silicon_raid.o
-lib-$(CONFIG_FEATURE_VOLUMEID_NVIDIARAID)       += nvidia_raid.o
-lib-$(CONFIG_FEATURE_VOLUMEID_PROMISERAID)      += promise_raid.o
+### lib-$(CONFIG_FEATURE_VOLUMEID_HIGHPOINTRAID)    += highpoint.o
+### lib-$(CONFIG_FEATURE_VOLUMEID_ISWRAID)          += isw_raid.o
+### lib-$(CONFIG_FEATURE_VOLUMEID_LSIRAID)          += lsi_raid.o
+### lib-$(CONFIG_FEATURE_VOLUMEID_VIARAID)          += via_raid.o
+### lib-$(CONFIG_FEATURE_VOLUMEID_SILICONRAID)      += silicon_raid.o
+### lib-$(CONFIG_FEATURE_VOLUMEID_NVIDIARAID)       += nvidia_raid.o
+### lib-$(CONFIG_FEATURE_VOLUMEID_PROMISERAID)      += promise_raid.o
 lib-$(CONFIG_FEATURE_VOLUMEID_ISO9660)          += iso9660.o
 lib-$(CONFIG_FEATURE_VOLUMEID_JFS)              += jfs.o
 lib-$(CONFIG_FEATURE_VOLUMEID_LINUXRAID)        += linux_raid.o
 lib-$(CONFIG_FEATURE_VOLUMEID_LINUXSWAP)        += linux_swap.o
-lib-$(CONFIG_FEATURE_VOLUMEID_LVM)              += lvm.o
-### unused
+### lib-$(CONFIG_FEATURE_VOLUMEID_LVM)              += lvm.o
 ### lib-$(CONFIG_FEATURE_VOLUMEID_MAC)              += mac.o
 ### lib-$(CONFIG_FEATURE_VOLUMEID_MSDOS)            += msdos.o
 lib-$(CONFIG_FEATURE_VOLUMEID_NTFS)             += ntfs.o
 lib-$(CONFIG_FEATURE_VOLUMEID_REISERFS)         += reiserfs.o
 lib-$(CONFIG_FEATURE_VOLUMEID_UDF)              += udf.o
-lib-$(CONFIG_FEATURE_VOLUMEID_UFS)              += ufs.o
+### lib-$(CONFIG_FEATURE_VOLUMEID_UFS)              += ufs.o
 lib-$(CONFIG_FEATURE_VOLUMEID_XFS)              += xfs.o
 lib-$(CONFIG_FEATURE_VOLUMEID_CRAMFS)           += cramfs.o
-lib-$(CONFIG_FEATURE_VOLUMEID_HPFS)             += hpfs.o
+### lib-$(CONFIG_FEATURE_VOLUMEID_HPFS)             += hpfs.o
 lib-$(CONFIG_FEATURE_VOLUMEID_ROMFS)            += romfs.o
 lib-$(CONFIG_FEATURE_VOLUMEID_SYSV)             += sysv.o
-lib-$(CONFIG_FEATURE_VOLUMEID_MINIX)            += minix.o
+### lib-$(CONFIG_FEATURE_VOLUMEID_MINIX)            += minix.o
 lib-$(CONFIG_FEATURE_VOLUMEID_LUKS)             += luks.o
 lib-$(CONFIG_FEATURE_VOLUMEID_OCFS2)            += ocfs2.o
diff --git a/util-linux/volume_id/get_devname.c b/util-linux/volume_id/get_devname.c
index bb3043c..b46aad4 100644
--- a/util-linux/volume_id/get_devname.c
+++ b/util-linux/volume_id/get_devname.c
@@ -243,8 +243,8 @@ dev_get_major_minor(char *device_name, int *major, int *minor)
 	colon = strchr(dev, ':');
 	if (!colon)
 		goto ret;
-	*major = strtol(dev, NULL, 10);
-	*minor = strtol(colon + 1, NULL, 10);
+	*major = bb_strtou(dev, NULL, 10);
+	*minor = bb_strtou(colon + 1, NULL, 10);
 
  ret:
 	free(dev_path);
@@ -261,27 +261,28 @@ uuidcache_init_cdroms(void)
 
 	proccd = fopen(PROC_CDROMS, "r");
 	if (!proccd) {
-		static smallint warn = 0;
-		if (!warn) {
-			warn = 1;
-			bb_error_msg("mount: could not open %s, so UUID and LABEL "
-				"conversion cannot be done for CD-Roms.",
-				PROC_CDROMS);
-		}
+//		static smallint warn = 0;
+//		if (!warn) {
+//			warn = 1;
+//			bb_error_msg("can't open %s, UUID and LABEL "
+//				"conversion cannot be done for CD-Roms",
+//				PROC_CDROMS);
+//		}
 		return;
 	}
 
 	while (fgets(line, sizeof(line), proccd)) {
-		static const char drive_name_string[] ALIGN1 = "drive name:\t\t";
+		static const char drive_name_string[] ALIGN1 = "drive name:";
 
 		if (strncmp(line, drive_name_string, sizeof(drive_name_string) - 1) == 0) {
 			char *device_name;
-			device_name = strtok(line + sizeof(drive_name_string) - 1, "\t\n");
-			while (device_name) {
+
+			device_name = strtok(skip_whitespace(line + sizeof(drive_name_string) - 1), " \t\n");
+			while (device_name && device_name[0]) {
 				ma = mi = -1;
 				dev_get_major_minor(device_name, &ma, &mi);
 				uuidcache_check_device(device_name, ma, mi, 1);
-				device_name = strtok(NULL, "\t\n");
+				device_name = strtok(NULL, " \t\n");
 			}
 			break;
 		}
@@ -418,7 +419,8 @@ char *get_devname_from_uuid(const char *spec)
 	uuidcache_init();
 	uc = uuidCache;
 	while (uc) {
-		if (strcmp(spec, uc->uc_uuid) == 0) {
+		/* case of hex numbers doesn't matter */
+		if (strcasecmp(spec, uc->uc_uuid) == 0) {
 			return xstrdup(uc->device);
 		}
 		uc = uc->next;
diff --git a/util-linux/volume_id/highpoint.c b/util-linux/volume_id/highpoint.c
deleted file mode 100644
index 57c5cad..0000000
--- a/util-linux/volume_id/highpoint.c
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * volume_id - reads filesystem label and uuid
- *
- * Copyright (C) 2004 Kay Sievers <kay.sievers@vrfy.org>
- *
- *	This library is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	This library is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- *	Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with this library; if not, write to the Free Software
- *	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- */
-
-#include "volume_id_internal.h"
-
-struct hpt37x_meta {
-	uint8_t		filler1[32];
-	uint32_t	magic;
-} __attribute__((packed));
-
-struct hpt45x_meta {
-	uint32_t	magic;
-} __attribute__((packed));
-
-#define HPT37X_CONFIG_OFF		0x1200
-#define HPT37X_MAGIC_OK			0x5a7816f0
-#define HPT37X_MAGIC_BAD		0x5a7816fd
-
-#define HPT45X_MAGIC_OK			0x5a7816f3
-#define HPT45X_MAGIC_BAD		0x5a7816fd
-
-
-int volume_id_probe_highpoint_37x_raid(struct volume_id *id, uint64_t off)
-{
-	struct hpt37x_meta *hpt;
-	uint32_t magic;
-
-	dbg("probing at offset 0x%llx", (unsigned long long) off);
-
-	hpt = volume_id_get_buffer(id, off + HPT37X_CONFIG_OFF, 0x200);
-	if (hpt == NULL)
-		return -1;
-
-	magic = hpt->magic;
-	if (magic != cpu_to_le32(HPT37X_MAGIC_OK) && magic != cpu_to_le32(HPT37X_MAGIC_BAD))
-		return -1;
-
-//	volume_id_set_usage(id, VOLUME_ID_RAID);
-//	id->type = "highpoint_raid_member";
-
-	return 0;
-}
-
-int volume_id_probe_highpoint_45x_raid(struct volume_id *id, uint64_t off, uint64_t size)
-{
-	struct hpt45x_meta *hpt;
-	uint64_t meta_off;
-	uint32_t magic;
-
-	dbg("probing at offset 0x%llx, size 0x%llx",
-	    (unsigned long long) off, (unsigned long long) size);
-
-	if (size < 0x10000)
-		return -1;
-
-	meta_off = ((size / 0x200)-11) * 0x200;
-	hpt = volume_id_get_buffer(id, off + meta_off, 0x200);
-	if (hpt == NULL)
-		return -1;
-
-	magic = hpt->magic;
-	if (magic != cpu_to_le32(HPT45X_MAGIC_OK) && magic != cpu_to_le32(HPT45X_MAGIC_BAD))
-		return -1;
-
-//	volume_id_set_usage(id, VOLUME_ID_RAID);
-//	id->type = "highpoint_raid_member";
-
-	return 0;
-}
diff --git a/util-linux/volume_id/hpfs.c b/util-linux/volume_id/hpfs.c
deleted file mode 100644
index 8b51756..0000000
--- a/util-linux/volume_id/hpfs.c
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * volume_id - reads filesystem label and uuid
- *
- * Copyright (C) 2005 Kay Sievers <kay.sievers@vrfy.org>
- *
- *	This library is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	This library is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- *	Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with this library; if not, write to the Free Software
- *	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- */
-
-#include "volume_id_internal.h"
-
-struct hpfs_super
-{
-	uint8_t		magic[4];
-	uint8_t		version;
-} __attribute__((__packed__));
-
-#define HPFS_SUPERBLOCK_OFFSET			0x2000
-
-int volume_id_probe_hpfs(struct volume_id *id, uint64_t off)
-{
-	struct hpfs_super *hs;
-
-	dbg("probing at offset 0x%llx", (unsigned long long) off);
-
-	hs = volume_id_get_buffer(id, off + HPFS_SUPERBLOCK_OFFSET, 0x200);
-	if (hs == NULL)
-		return -1;
-
-	if (memcmp(hs->magic, "\x49\xe8\x95\xf9", 4) == 0) {
-//		sprintf(id->type_version, "%u", hs->version);
-//		volume_id_set_usage(id, VOLUME_ID_FILESYSTEM);
-//		id->type = "hpfs";
-		return 0;
-	}
-
-	return -1;
-}
diff --git a/util-linux/volume_id/isw_raid.c b/util-linux/volume_id/isw_raid.c
deleted file mode 100644
index d928245..0000000
--- a/util-linux/volume_id/isw_raid.c
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * volume_id - reads filesystem label and uuid
- *
- * Copyright (C) 2005 Kay Sievers <kay.sievers@vrfy.org>
- *
- *	This library is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	This library is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- *	Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with this library; if not, write to the Free Software
- *	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- */
-
-#include "volume_id_internal.h"
-
-struct isw_meta {
-	uint8_t		sig[32];
-	uint32_t	check_sum;
-	uint32_t	mpb_size;
-	uint32_t	family_num;
-	uint32_t	generation_num;
-} __attribute__((packed));
-
-#define ISW_SIGNATURE		"Intel Raid ISM Cfg Sig. "
-
-
-int volume_id_probe_intel_software_raid(struct volume_id *id, uint64_t off, uint64_t size)
-{
-	uint64_t meta_off;
-	struct isw_meta *isw;
-
-	dbg("probing at offset 0x%llx, size 0x%llx",
-	    (unsigned long long) off, (unsigned long long) size);
-
-	if (size < 0x10000)
-		return -1;
-
-	meta_off = ((size / 0x200)-2) * 0x200;
-	isw = volume_id_get_buffer(id, off + meta_off, 0x200);
-	if (isw == NULL)
-		return -1;
-
-	if (memcmp(isw->sig, ISW_SIGNATURE, sizeof(ISW_SIGNATURE)-1) != 0)
-		return -1;
-
-//	volume_id_set_usage(id, VOLUME_ID_RAID);
-//	memcpy(id->type_version, &isw->sig[sizeof(ISW_SIGNATURE)-1], 6);
-//	id->type = "isw_raid_member";
-
-	return 0;
-}
diff --git a/util-linux/volume_id/lsi_raid.c b/util-linux/volume_id/lsi_raid.c
deleted file mode 100644
index 730a313..0000000
--- a/util-linux/volume_id/lsi_raid.c
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * volume_id - reads filesystem label and uuid
- *
- * Copyright (C) 2005 Kay Sievers <kay.sievers@vrfy.org>
- *
- *	This library is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	This library is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- *	Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with this library; if not, write to the Free Software
- *	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- */
-
-#include "volume_id_internal.h"
-
-struct lsi_meta {
-	uint8_t		sig[6];
-} __attribute__((packed));
-
-#define LSI_SIGNATURE		"$XIDE$"
-
-int volume_id_probe_lsi_mega_raid(struct volume_id *id, uint64_t off, uint64_t size)
-{
-	uint64_t meta_off;
-	struct lsi_meta *lsi;
-
-	dbg("probing at offset 0x%llx, size 0x%llx",
-	    (unsigned long long) off, (unsigned long long) size);
-
-	if (size < 0x10000)
-		return -1;
-
-	meta_off = ((size / 0x200)-1) * 0x200;
-	lsi = volume_id_get_buffer(id, off + meta_off, 0x200);
-	if (lsi == NULL)
-		return -1;
-
-	if (memcmp(lsi->sig, LSI_SIGNATURE, sizeof(LSI_SIGNATURE)-1) != 0)
-		return -1;
-
-//	volume_id_set_usage(id, VOLUME_ID_RAID);
-//	id->type = "lsi_mega_raid_member";
-
-	return 0;
-}
diff --git a/util-linux/volume_id/lvm.c b/util-linux/volume_id/lvm.c
deleted file mode 100644
index f9f9395..0000000
--- a/util-linux/volume_id/lvm.c
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
- * volume_id - reads filesystem label and uuid
- *
- * Copyright (C) 2004 Kay Sievers <kay.sievers@vrfy.org>
- *
- *	This library is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	This library is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- *	Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with this library; if not, write to the Free Software
- *	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- */
-
-#include "volume_id_internal.h"
-
-struct lvm1_super_block {
-	uint8_t	id[2];
-} __attribute__((packed));
-
-struct lvm2_super_block {
-	uint8_t		id[8];
-	uint64_t	sector_xl;
-	uint32_t	crc_xl;
-	uint32_t	offset_xl;
-	uint8_t		type[8];
-} __attribute__((packed));
-
-#define LVM1_SB_OFF			0x400
-
-int volume_id_probe_lvm1(struct volume_id *id, uint64_t off)
-{
-	const uint8_t *buf;
-	struct lvm1_super_block *lvm;
-
-	dbg("probing at offset 0x%llx", (unsigned long long) off);
-
-	buf = volume_id_get_buffer(id, off + LVM1_SB_OFF, 0x800);
-	if (buf == NULL)
-		return -1;
-
-	lvm = (struct lvm1_super_block *) buf;
-
-	if (lvm->id[0] != 'H' || lvm->id[1] != 'M')
-		return -1;
-
-//	volume_id_set_usage(id, VOLUME_ID_RAID);
-//	id->type = "LVM1_member";
-
-	return 0;
-}
-
-#define LVM2_LABEL_ID			"LABELONE"
-#define LVM2LABEL_SCAN_SECTORS		4
-
-int volume_id_probe_lvm2(struct volume_id *id, uint64_t off)
-{
-	const uint8_t *buf;
-	unsigned soff;
-	struct lvm2_super_block *lvm;
-
-	dbg("probing at offset 0x%llx", (unsigned long long) off);
-
-	buf = volume_id_get_buffer(id, off, LVM2LABEL_SCAN_SECTORS * 0x200);
-	if (buf == NULL)
-		return -1;
-
-
-	for (soff = 0; soff < LVM2LABEL_SCAN_SECTORS * 0x200; soff += 0x200) {
-		lvm = (struct lvm2_super_block *) &buf[soff];
-
-		if (memcmp(lvm->id, LVM2_LABEL_ID, 8) == 0)
-			goto found;
-	}
-
-	return -1;
-
- found:
-//	memcpy(id->type_version, lvm->type, 8);
-//	volume_id_set_usage(id, VOLUME_ID_RAID);
-//	id->type = "LVM2_member";
-
-	return 0;
-}
diff --git a/util-linux/volume_id/mac.c b/util-linux/volume_id/mac.c
deleted file mode 100644
index 94a99be..0000000
--- a/util-linux/volume_id/mac.c
+++ /dev/null
@@ -1,125 +0,0 @@
-/*
- * volume_id - reads filesystem label and uuid
- *
- * Copyright (C) 2004 Kay Sievers <kay.sievers@vrfy.org>
- *
- *	This library is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	This library is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- *	Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with this library; if not, write to the Free Software
- *	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- */
-
-#include "volume_id_internal.h"
-
-struct mac_driver_desc {
-	uint8_t		signature[2];
-	uint16_t	block_size;
-	uint32_t	block_count;
-} __attribute__((__packed__));
-
-struct mac_partition {
-	uint8_t		signature[2];
-	uint16_t	res1;
-	uint32_t	map_count;
-	uint32_t	start_block;
-	uint32_t	block_count;
-	uint8_t		name[32];
-	uint8_t		type[32];
-} __attribute__((__packed__));
-
-int volume_id_probe_mac_partition_map(struct volume_id *id, uint64_t off)
-{
-	const uint8_t *buf;
-	struct mac_driver_desc *driver;
-	struct mac_partition *part;
-
-	dbg("probing at offset 0x%llx", (unsigned long long) off);
-
-	buf = volume_id_get_buffer(id, off, 0x200);
-	if (buf == NULL)
-		return -1;
-
-	part = (struct mac_partition *) buf;
-	if ((memcmp(part->signature, "PM", 2) == 0) &&
-	    (memcmp(part->type, "Apple_partition_map", 19) == 0)) {
-		/* linux creates an own subdevice for the map
-		 * just return the type if the drive header is missing */
-		volume_id_set_usage(id, VOLUME_ID_PARTITIONTABLE);
-		id->type = "mac_partition_map";
-		return 0;
-	}
-
-	driver = (struct mac_driver_desc *) buf;
-	if (memcmp(driver->signature, "ER", 2) == 0) {
-		/* we are on a main device, like a CD
-		 * just try to probe the first partition from the map */
-		unsigned bsize = be16_to_cpu(driver->block_size);
-		int part_count;
-		int i;
-
-		/* get first entry of partition table */
-		buf = volume_id_get_buffer(id, off +  bsize, 0x200);
-		if (buf == NULL)
-			return -1;
-
-		part = (struct mac_partition *) buf;
-		if (memcmp(part->signature, "PM", 2) != 0)
-			return -1;
-
-		part_count = be32_to_cpu(part->map_count);
-		dbg("expecting %d partition entries", part_count);
-
-		if (id->partitions != NULL)
-			free(id->partitions);
-		id->partitions =
-			malloc(part_count * sizeof(struct volume_id_partition));
-		if (id->partitions == NULL)
-			return -1;
-		memset(id->partitions, 0x00, sizeof(struct volume_id_partition));
-
-		id->partition_count = part_count;
-
-		for (i = 0; i < part_count; i++) {
-			uint64_t poff;
-			uint64_t plen;
-
-			buf = volume_id_get_buffer(id, off + ((i+1) * bsize), 0x200);
-			if (buf == NULL)
-				return -1;
-
-			part = (struct mac_partition *) buf;
-			if (memcmp(part->signature, "PM", 2) != 0)
-				return -1;
-
-			poff = be32_to_cpu(part->start_block) * bsize;
-			plen = be32_to_cpu(part->block_count) * bsize;
-			dbg("found '%s' partition entry at 0x%llx, len 0x%llx",
-			    part->type, (unsigned long long) poff, (unsigned long long) plen);
-
-			id->partitions[i].off = poff;
-			id->partitions[i].len = plen;
-
-			if (memcmp(part->type, "Apple_Free", 10) == 0) {
-				volume_id_set_usage_part(&id->partitions[i], VOLUME_ID_UNUSED);
-			} else if (memcmp(part->type, "Apple_partition_map", 19) == 0) {
-				volume_id_set_usage_part(&id->partitions[i], VOLUME_ID_PARTITIONTABLE);
-			} else {
-				volume_id_set_usage_part(&id->partitions[i], VOLUME_ID_UNPROBED);
-			}
-		}
-		volume_id_set_usage(id, VOLUME_ID_PARTITIONTABLE);
-		id->type = "mac_partition_map";
-		return 0;
-	}
-
-	return -1;
-}
diff --git a/util-linux/volume_id/minix.c b/util-linux/volume_id/minix.c
deleted file mode 100644
index 2f52093..0000000
--- a/util-linux/volume_id/minix.c
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * volume_id - reads filesystem label and uuid
- *
- * Copyright (C) 2005 Kay Sievers <kay.sievers@vrfy.org>
- *
- *	This library is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	This library is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- *	Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with this library; if not, write to the Free Software
- *	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- */
-
-#include "volume_id_internal.h"
-
-struct minix_super_block {
-	uint16_t	s_ninodes;
-	uint16_t	s_nzones;
-	uint16_t	s_imap_blocks;
-	uint16_t	s_zmap_blocks;
-	uint16_t	s_firstdatazone;
-	uint16_t	s_log_zone_size;
-	uint32_t	s_max_size;
-	uint16_t	s_magic;
-	uint16_t	s_state;
-	uint32_t	s_zones;
-} __attribute__((__packed__));
-
-#define MINIX_SUPERBLOCK_OFFSET			0x400
-
-int volume_id_probe_minix(struct volume_id *id, uint64_t off)
-{
-	struct minix_super_block *ms;
-
-	dbg("probing at offset 0x%llx", (unsigned long long) off);
-
-	ms = volume_id_get_buffer(id, off + MINIX_SUPERBLOCK_OFFSET, 0x200);
-	if (ms == NULL)
-		return -1;
-
-	if (ms->s_magic == cpu_to_le16(0x137f)) {
-//		id->type_version[0] = '1';
-		goto found;
-	}
-
-	if (ms->s_magic == cpu_to_le16(0x1387)) {
-//		id->type_version[0] = '1';
-		goto found;
-	}
-
-	if (ms->s_magic == cpu_to_le16(0x2468)) {
-//		id->type_version[0] = '2';
-		goto found;
-	}
-
-	if (ms->s_magic == cpu_to_le16(0x2478)) {
-//		id->type_version[0] = '2';
-		goto found;
-	}
-
-	return -1;
-
- found:
-//	id->type_version[1] = '\0';
-//	volume_id_set_usage(id, VOLUME_ID_FILESYSTEM);
-//	id->type = "minix";
-	return 0;
-}
diff --git a/util-linux/volume_id/msdos.c b/util-linux/volume_id/msdos.c
deleted file mode 100644
index b4b6711..0000000
--- a/util-linux/volume_id/msdos.c
+++ /dev/null
@@ -1,196 +0,0 @@
-/*
- * volume_id - reads filesystem label and uuid
- *
- * Copyright (C) 2004 Kay Sievers <kay.sievers@vrfy.org>
- *
- *	This library is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	This library is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- *	Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with this library; if not, write to the Free Software
- *	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- */
-
-#include "volume_id_internal.h"
-
-struct msdos_partition_entry {
-	uint8_t		boot_ind;
-	uint8_t		head;
-	uint8_t		sector;
-	uint8_t		cyl;
-	uint8_t		sys_ind;
-	uint8_t		end_head;
-	uint8_t		end_sector;
-	uint8_t		end_cyl;
-	uint32_t	start_sect;
-	uint32_t	nr_sects;
-} __attribute__((packed));
-
-#define MSDOS_MAGIC			"\x55\xaa"
-#define MSDOS_PARTTABLE_OFFSET		0x1be
-#define MSDOS_SIG_OFF			0x1fe
-#define BSIZE				0x200
-#define DOS_EXTENDED_PARTITION		0x05
-#define LINUX_EXTENDED_PARTITION	0x85
-#define WIN98_EXTENDED_PARTITION	0x0f
-#define LINUX_RAID_PARTITION		0xfd
-#define is_extended(type) \
-	(type == DOS_EXTENDED_PARTITION ||	\
-	 type == WIN98_EXTENDED_PARTITION ||	\
-	 type == LINUX_EXTENDED_PARTITION)
-#define is_raid(type) \
-	(type == LINUX_RAID_PARTITION)
-
-int volume_id_probe_msdos_part_table(struct volume_id *id, uint64_t off)
-{
-	const uint8_t *buf;
-	int i;
-	uint64_t poff;
-	uint64_t plen;
-	uint64_t extended = 0;
-	uint64_t current;
-	uint64_t next;
-	int limit;
-	int empty = 1;
-	struct msdos_partition_entry *part;
-	struct volume_id_partition *p;
-
-	dbg("probing at offset 0x%llx", (unsigned long long) off);
-
-	buf = volume_id_get_buffer(id, off, 0x200);
-	if (buf == NULL)
-		return -1;
-
-	if (memcmp(&buf[MSDOS_SIG_OFF], MSDOS_MAGIC, 2) != 0)
-		return -1;
-
-	/* check flags on all entries for a valid partition table */
-	part = (struct msdos_partition_entry*) &buf[MSDOS_PARTTABLE_OFFSET];
-	for (i = 0; i < 4; i++) {
-		if (part[i].boot_ind != 0 &&
-		    part[i].boot_ind != 0x80)
-			return -1;
-
-		if (part[i].nr_sects != 0)
-			empty = 0;
-	}
-	if (empty == 1)
-		return -1;
-
-	if (id->partitions != NULL)
-		free(id->partitions);
-	id->partitions = malloc(VOLUME_ID_PARTITIONS_MAX *
-				sizeof(struct volume_id_partition));
-	if (id->partitions == NULL)
-		return -1;
-	memset(id->partitions, 0x00,
-	       VOLUME_ID_PARTITIONS_MAX * sizeof(struct volume_id_partition));
-
-	for (i = 0; i < 4; i++) {
-		poff = (uint64_t) le32_to_cpu(part[i].start_sect) * BSIZE;
-		plen = (uint64_t) le32_to_cpu(part[i].nr_sects) * BSIZE;
-
-		if (plen == 0)
-			continue;
-
-		p = &id->partitions[i];
-
-		p->partition_type_raw = part[i].sys_ind;
-
-		if (is_extended(part[i].sys_ind)) {
-			dbg("found extended partition at 0x%llx", (unsigned long long) poff);
-			volume_id_set_usage_part(p, VOLUME_ID_PARTITIONTABLE);
-			p->type = "msdos_extended_partition";
-			if (extended == 0)
-				extended = off + poff;
-		} else {
-			dbg("found 0x%x data partition at 0x%llx, len 0x%llx",
-			    part[i].sys_ind, (unsigned long long) poff, (unsigned long long) plen);
-
-			if (is_raid(part[i].sys_ind))
-				volume_id_set_usage_part(p, VOLUME_ID_RAID);
-			else
-				volume_id_set_usage_part(p, VOLUME_ID_UNPROBED);
-		}
-
-		p->off = off + poff;
-		p->len = plen;
-		id->partition_count = i+1;
-	}
-
-	next = extended;
-	current = extended;
-	limit = 50;
-
-	/* follow extended partition chain and add data partitions */
-	while (next != 0) {
-		if (limit-- == 0) {
-			dbg("extended chain limit reached");
-			break;
-		}
-
-		buf = volume_id_get_buffer(id, current, 0x200);
-		if (buf == NULL)
-			break;
-
-		part = (struct msdos_partition_entry*) &buf[MSDOS_PARTTABLE_OFFSET];
-
-		if (memcmp(&buf[MSDOS_SIG_OFF], MSDOS_MAGIC, 2) != 0)
-			break;
-
-		next = 0;
-
-		for (i = 0; i < 4; i++) {
-			poff = (uint64_t) le32_to_cpu(part[i].start_sect) * BSIZE;
-			plen = (uint64_t) le32_to_cpu(part[i].nr_sects) * BSIZE;
-
-			if (plen == 0)
-				continue;
-
-			if (is_extended(part[i].sys_ind)) {
-				dbg("found extended partition at 0x%llx", (unsigned long long) poff);
-				if (next == 0)
-					next = extended + poff;
-			} else {
-				dbg("found 0x%x data partition at 0x%llx, len 0x%llx",
-					part[i].sys_ind, (unsigned long long) poff, (unsigned long long) plen);
-
-				/* we always start at the 5th entry */
-				while (id->partition_count < 4)
-					volume_id_set_usage_part(&id->partitions[id->partition_count++], VOLUME_ID_UNUSED);
-
-				p = &id->partitions[id->partition_count];
-
-				if (is_raid(part[i].sys_ind))
-					volume_id_set_usage_part(p, VOLUME_ID_RAID);
-				else
-					volume_id_set_usage_part(p, VOLUME_ID_UNPROBED);
-
-				p->off = current + poff;
-				p->len = plen;
-				id->partition_count++;
-
-				p->partition_type_raw = part[i].sys_ind;
-
-				if (id->partition_count >= VOLUME_ID_PARTITIONS_MAX) {
-					dbg("too many partitions");
-					next = 0;
-				}
-			}
-		}
-
-		current = next;
-	}
-
-	volume_id_set_usage(id, VOLUME_ID_PARTITIONTABLE);
-	id->type = "msdos_partition_table";
-
-	return 0;
-}
diff --git a/util-linux/volume_id/nvidia_raid.c b/util-linux/volume_id/nvidia_raid.c
deleted file mode 100644
index 692aad1..0000000
--- a/util-linux/volume_id/nvidia_raid.c
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * volume_id - reads filesystem label and uuid
- *
- * Copyright (C) 2005 Kay Sievers <kay.sievers@vrfy.org>
- *
- *	This library is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	This library is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- *	Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with this library; if not, write to the Free Software
- *	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- */
-
-#include "volume_id_internal.h"
-
-struct nvidia_meta {
-	uint8_t		vendor[8];
-	uint32_t	size;
-	uint32_t	chksum;
-	uint16_t	version;
-} __attribute__((packed));
-
-#define NVIDIA_SIGNATURE		"NVIDIA"
-
-int volume_id_probe_nvidia_raid(struct volume_id *id, uint64_t off, uint64_t size)
-{
-	uint64_t meta_off;
-	struct nvidia_meta *nv;
-
-	dbg("probing at offset 0x%llx, size 0x%llx",
-	    (unsigned long long) off, (unsigned long long) size);
-
-	if (size < 0x10000)
-		return -1;
-
-	meta_off = ((size / 0x200)-2) * 0x200;
-	nv = volume_id_get_buffer(id, off + meta_off, 0x200);
-	if (nv == NULL)
-		return -1;
-
-	if (memcmp(nv->vendor, NVIDIA_SIGNATURE, sizeof(NVIDIA_SIGNATURE)-1) != 0)
-		return -1;
-
-//	volume_id_set_usage(id, VOLUME_ID_RAID);
-//	snprintf(id->type_version, sizeof(id->type_version)-1, "%u", le16_to_cpu(nv->version));
-//	id->type = "nvidia_raid_member";
-
-	return 0;
-}
diff --git a/util-linux/volume_id/ocfs2.c b/util-linux/volume_id/ocfs2.c
index 9fd4565..8bcaac0 100644
--- a/util-linux/volume_id/ocfs2.c
+++ b/util-linux/volume_id/ocfs2.c
@@ -80,7 +80,7 @@ struct ocfs2_super_block {
 	uint8_t		s_uuid[OCFS2_VOL_UUID_LEN];	/* 128-bit uuid */
 } __attribute__((__packed__));
 
-int volume_id_probe_ocfs2(struct volume_id *id, uint64_t		off)
+int volume_id_probe_ocfs2(struct volume_id *id, uint64_t off)
 {
 	struct ocfs2_super_block *os;
 
diff --git a/util-linux/volume_id/promise_raid.c b/util-linux/volume_id/promise_raid.c
deleted file mode 100644
index 75c6f89..0000000
--- a/util-linux/volume_id/promise_raid.c
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * volume_id - reads filesystem label and uuid
- *
- * Copyright (C) 2005 Kay Sievers <kay.sievers@vrfy.org>
- *
- *	This library is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	This library is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- *	Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with this library; if not, write to the Free Software
- *	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- */
-
-#include "volume_id_internal.h"
-
-struct promise_meta {
-	uint8_t	sig[24];
-} __attribute__((packed));
-
-#define PDC_CONFIG_OFF		0x1200
-#define PDC_SIGNATURE		"Promise Technology, Inc."
-
-int volume_id_probe_promise_fasttrack_raid(struct volume_id *id, uint64_t off, uint64_t size)
-{
-	static const unsigned short sectors[] = {
-		63, 255, 256, 16, 399
-	};
-
-	struct promise_meta *pdc;
-	unsigned i;
-
-	dbg("probing at offset 0x%llx, size 0x%llx",
-	    (unsigned long long) off, (unsigned long long) size);
-
-	if (size < 0x40000)
-		return -1;
-
-	for (i = 0; i < ARRAY_SIZE(sectors); i++) {
-		uint64_t meta_off;
-
-		meta_off = ((size / 0x200) - sectors[i]) * 0x200;
-		pdc = volume_id_get_buffer(id, off + meta_off, 0x200);
-		if (pdc == NULL)
-			return -1;
-
-		if (memcmp(pdc->sig, PDC_SIGNATURE, sizeof(PDC_SIGNATURE)-1) == 0)
-			goto found;
-	}
-	return -1;
-
- found:
-//	volume_id_set_usage(id, VOLUME_ID_RAID);
-//	id->type = "promise_fasttrack_raid_member";
-
-	return 0;
-}
diff --git a/util-linux/volume_id/silicon_raid.c b/util-linux/volume_id/silicon_raid.c
deleted file mode 100644
index 5143112..0000000
--- a/util-linux/volume_id/silicon_raid.c
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * volume_id - reads filesystem label and uuid
- *
- * Copyright (C) 2005 Kay Sievers <kay.sievers@vrfy.org>
- *
- *	This library is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	This library is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- *	Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with this library; if not, write to the Free Software
- *	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- */
-
-#include "volume_id_internal.h"
-
-struct silicon_meta {
-	uint8_t		unknown0[0x2E];
-	uint8_t		ascii_version[0x36 - 0x2E];
-	uint8_t		diskname[0x56 - 0x36];
-	uint8_t		unknown1[0x60 - 0x56];
-	uint32_t	magic;
-	uint32_t	unknown1a[0x6C - 0x64];
-	uint32_t	array_sectors_low;
-	uint32_t	array_sectors_high;
-	uint8_t		unknown2[0x78 - 0x74];
-	uint32_t	thisdisk_sectors;
-	uint8_t		unknown3[0x100 - 0x7C];
-	uint8_t		unknown4[0x104 - 0x100];
-	uint16_t	product_id;
-	uint16_t	vendor_id;
-	uint16_t	minor_ver;
-	uint16_t	major_ver;
-} __attribute__((packed));
-
-#define SILICON_MAGIC		0x2F000000
-
-int volume_id_probe_silicon_medley_raid(struct volume_id *id, uint64_t off, uint64_t size)
-{
-	uint64_t meta_off;
-	struct silicon_meta *sil;
-
-	dbg("probing at offset 0x%llx, size 0x%llx",
-	    (unsigned long long) off, (unsigned long long) size);
-
-	if (size < 0x10000)
-		return -1;
-
-	meta_off = ((size / 0x200)-1) * 0x200;
-	sil = volume_id_get_buffer(id, off + meta_off, 0x200);
-	if (sil == NULL)
-		return -1;
-
-	if (sil->magic != cpu_to_le32(SILICON_MAGIC))
-		return -1;
-
-//	volume_id_set_usage(id, VOLUME_ID_RAID);
-//	snprintf(id->type_version, sizeof(id->type_version)-1, "%u.%u",
-//		 le16_to_cpu(sil->major_ver), le16_to_cpu(sil->minor_ver));
-//	id->type = "silicon_medley_raid_member";
-
-	return 0;
-}
diff --git a/util-linux/volume_id/ufs.c b/util-linux/volume_id/ufs.c
deleted file mode 100644
index ba76876..0000000
--- a/util-linux/volume_id/ufs.c
+++ /dev/null
@@ -1,206 +0,0 @@
-/*
- * volume_id - reads filesystem label and uuid
- *
- * Copyright (C) 2004 Kay Sievers <kay.sievers@vrfy.org>
- *
- *	This library is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	This library is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- *	Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with this library; if not, write to the Free Software
- *	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- */
-
-#include "volume_id_internal.h"
-
-struct ufs_super_block {
-	uint32_t	fs_link;
-	uint32_t	fs_rlink;
-	uint32_t	fs_sblkno;
-	uint32_t	fs_cblkno;
-	uint32_t	fs_iblkno;
-	uint32_t	fs_dblkno;
-	uint32_t	fs_cgoffset;
-	uint32_t	fs_cgmask;
-	uint32_t	fs_time;
-	uint32_t	fs_size;
-	uint32_t	fs_dsize;
-	uint32_t	fs_ncg;	
-	uint32_t	fs_bsize;
-	uint32_t	fs_fsize;
-	uint32_t	fs_frag;
-	uint32_t	fs_minfree;
-	uint32_t	fs_rotdelay;
-	uint32_t	fs_rps;	
-	uint32_t	fs_bmask;
-	uint32_t	fs_fmask;
-	uint32_t	fs_bshift;
-	uint32_t	fs_fshift;
-	uint32_t	fs_maxcontig;
-	uint32_t	fs_maxbpg;
-	uint32_t	fs_fragshift;
-	uint32_t	fs_fsbtodb;
-	uint32_t	fs_sbsize;
-	uint32_t	fs_csmask;
-	uint32_t	fs_csshift;
-	uint32_t	fs_nindir;
-	uint32_t	fs_inopb;
-	uint32_t	fs_nspf;
-	uint32_t	fs_optim;
-	uint32_t	fs_npsect_state;
-	uint32_t	fs_interleave;
-	uint32_t	fs_trackskew;
-	uint32_t	fs_id[2];
-	uint32_t	fs_csaddr;
-	uint32_t	fs_cssize;
-	uint32_t	fs_cgsize;
-	uint32_t	fs_ntrak;
-	uint32_t	fs_nsect;
-	uint32_t	fs_spc;	
-	uint32_t	fs_ncyl;
-	uint32_t	fs_cpg;
-	uint32_t	fs_ipg;
-	uint32_t	fs_fpg;
-	struct ufs_csum {
-		uint32_t	cs_ndir;
-		uint32_t	cs_nbfree;
-		uint32_t	cs_nifree;
-		uint32_t	cs_nffree;
-	} __attribute__((__packed__)) fs_cstotal;
-	int8_t		fs_fmod;
-	int8_t		fs_clean;
-	int8_t		fs_ronly;
-	int8_t		fs_flags;
-	union {
-		struct {
-			int8_t	fs_fsmnt[512];
-			uint32_t	fs_cgrotor;
-			uint32_t	fs_csp[31];
-			uint32_t	fs_maxcluster;
-			uint32_t	fs_cpc;
-			uint16_t	fs_opostbl[16][8];
-		} __attribute__((__packed__)) fs_u1;
-		struct {
-			int8_t		fs_fsmnt[468];
-			uint8_t		fs_volname[32];
-			uint64_t	fs_swuid;
-			int32_t		fs_pad;
-			uint32_t	fs_cgrotor;
-			uint32_t	fs_ocsp[28];
-			uint32_t	fs_contigdirs;
-			uint32_t	fs_csp;	
-			uint32_t	fs_maxcluster;
-			uint32_t	fs_active;
-			int32_t		fs_old_cpc;
-			int32_t		fs_maxbsize;
-			int64_t		fs_sparecon64[17];
-			int64_t		fs_sblockloc;
-			struct ufs2_csum_total {
-				uint64_t	cs_ndir;
-				uint64_t	cs_nbfree;
-				uint64_t	cs_nifree;
-				uint64_t	cs_nffree;
-				uint64_t	cs_numclusters;
-				uint64_t	cs_spare[3];
-			} __attribute__((__packed__)) fs_cstotal;
-			struct ufs_timeval {
-				int32_t		tv_sec;
-				int32_t		tv_usec;
-			} __attribute__((__packed__)) fs_time;
-			int64_t		fs_size;
-			int64_t		fs_dsize;
-			uint64_t	fs_csaddr;
-			int64_t		fs_pendingblocks;
-			int32_t		fs_pendinginodes;
-		} __attribute__((__packed__)) fs_u2;
-	}  fs_u11;
-	union {
-		struct {
-			int32_t		fs_sparecon[53];
-			int32_t		fs_reclaim;
-			int32_t		fs_sparecon2[1];
-			int32_t		fs_state;
-			uint32_t	fs_qbmask[2];
-			uint32_t	fs_qfmask[2];
-		} __attribute__((__packed__)) fs_sun;
-		struct {
-			int32_t		fs_sparecon[53];
-			int32_t		fs_reclaim;
-			int32_t		fs_sparecon2[1];
-			uint32_t	fs_npsect;
-			uint32_t	fs_qbmask[2];
-			uint32_t	fs_qfmask[2];
-		} __attribute__((__packed__)) fs_sunx86;
-		struct {
-			int32_t		fs_sparecon[50];
-			int32_t		fs_contigsumsize;
-			int32_t		fs_maxsymlinklen;
-			int32_t		fs_inodefmt;
-			uint32_t	fs_maxfilesize[2];
-			uint32_t	fs_qbmask[2];
-			uint32_t	fs_qfmask[2];
-			int32_t		fs_state;
-		} __attribute__((__packed__)) fs_44;
-	} fs_u2;
-	int32_t		fs_postblformat;
-	int32_t		fs_nrpos;
-	int32_t		fs_postbloff;
-	int32_t		fs_rotbloff;
-	uint32_t	fs_magic;
-	uint8_t		fs_space[1];
-} __attribute__((__packed__));
-
-#define UFS_MAGIC			0x00011954
-#define UFS2_MAGIC			0x19540119
-#define UFS_MAGIC_FEA			0x00195612
-#define UFS_MAGIC_LFN			0x00095014
-
-int volume_id_probe_ufs(struct volume_id *id, uint64_t off)
-{
-	static const short offsets[] = { 0, 8, 64, 256 };
-
-	uint32_t magic;
-	int i;
-	struct ufs_super_block *ufs;
-
-	dbg("probing at offset 0x%llx", (unsigned long long) off);
-
-	for (i = 0; i < ARRAY_SIZE(offsets); i++) {	
-		ufs = volume_id_get_buffer(id, off + (offsets[i] * 0x400), 0x800);
-		if (ufs == NULL)
-			return -1;
-
-		dbg("offset 0x%x", offsets[i] * 0x400);
-		magic = ufs->fs_magic;
-		if ((magic == cpu_to_be32(UFS_MAGIC))
-		 || (magic == cpu_to_be32(UFS2_MAGIC))
-		 || (magic == cpu_to_be32(UFS_MAGIC_FEA))
-		 || (magic == cpu_to_be32(UFS_MAGIC_LFN))
-		) {
-			dbg("magic 0x%08x(be)", magic);
-			goto found;
-		}
-		if ((magic == cpu_to_le32(UFS_MAGIC))
-		 || (magic == cpu_to_le32(UFS2_MAGIC))
-		 || (magic == cpu_to_le32(UFS_MAGIC_FEA))
-		 || (magic == cpu_to_le32(UFS_MAGIC_LFN))
-		) {
-			dbg("magic 0x%08x(le)", magic);
-			goto found;
-		}
-	}
-	return -1;
-
- found:
-//	volume_id_set_usage(id, VOLUME_ID_FILESYSTEM);
-//	id->type = "ufs";
-
-	return 0;
-}
diff --git a/util-linux/volume_id/unused_highpoint.c b/util-linux/volume_id/unused_highpoint.c
new file mode 100644
index 0000000..57c5cad
--- /dev/null
+++ b/util-linux/volume_id/unused_highpoint.c
@@ -0,0 +1,86 @@
+/*
+ * volume_id - reads filesystem label and uuid
+ *
+ * Copyright (C) 2004 Kay Sievers <kay.sievers@vrfy.org>
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation; either
+ *	version 2.1 of the License, or (at your option) any later version.
+ *
+ *	This library is distributed in the hope that it will be useful,
+ *	but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ *	Lesser General Public License for more details.
+ *
+ *	You should have received a copy of the GNU Lesser General Public
+ *	License along with this library; if not, write to the Free Software
+ *	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "volume_id_internal.h"
+
+struct hpt37x_meta {
+	uint8_t		filler1[32];
+	uint32_t	magic;
+} __attribute__((packed));
+
+struct hpt45x_meta {
+	uint32_t	magic;
+} __attribute__((packed));
+
+#define HPT37X_CONFIG_OFF		0x1200
+#define HPT37X_MAGIC_OK			0x5a7816f0
+#define HPT37X_MAGIC_BAD		0x5a7816fd
+
+#define HPT45X_MAGIC_OK			0x5a7816f3
+#define HPT45X_MAGIC_BAD		0x5a7816fd
+
+
+int volume_id_probe_highpoint_37x_raid(struct volume_id *id, uint64_t off)
+{
+	struct hpt37x_meta *hpt;
+	uint32_t magic;
+
+	dbg("probing at offset 0x%llx", (unsigned long long) off);
+
+	hpt = volume_id_get_buffer(id, off + HPT37X_CONFIG_OFF, 0x200);
+	if (hpt == NULL)
+		return -1;
+
+	magic = hpt->magic;
+	if (magic != cpu_to_le32(HPT37X_MAGIC_OK) && magic != cpu_to_le32(HPT37X_MAGIC_BAD))
+		return -1;
+
+//	volume_id_set_usage(id, VOLUME_ID_RAID);
+//	id->type = "highpoint_raid_member";
+
+	return 0;
+}
+
+int volume_id_probe_highpoint_45x_raid(struct volume_id *id, uint64_t off, uint64_t size)
+{
+	struct hpt45x_meta *hpt;
+	uint64_t meta_off;
+	uint32_t magic;
+
+	dbg("probing at offset 0x%llx, size 0x%llx",
+	    (unsigned long long) off, (unsigned long long) size);
+
+	if (size < 0x10000)
+		return -1;
+
+	meta_off = ((size / 0x200)-11) * 0x200;
+	hpt = volume_id_get_buffer(id, off + meta_off, 0x200);
+	if (hpt == NULL)
+		return -1;
+
+	magic = hpt->magic;
+	if (magic != cpu_to_le32(HPT45X_MAGIC_OK) && magic != cpu_to_le32(HPT45X_MAGIC_BAD))
+		return -1;
+
+//	volume_id_set_usage(id, VOLUME_ID_RAID);
+//	id->type = "highpoint_raid_member";
+
+	return 0;
+}
diff --git a/util-linux/volume_id/unused_hpfs.c b/util-linux/volume_id/unused_hpfs.c
new file mode 100644
index 0000000..8b51756
--- /dev/null
+++ b/util-linux/volume_id/unused_hpfs.c
@@ -0,0 +1,49 @@
+/*
+ * volume_id - reads filesystem label and uuid
+ *
+ * Copyright (C) 2005 Kay Sievers <kay.sievers@vrfy.org>
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation; either
+ *	version 2.1 of the License, or (at your option) any later version.
+ *
+ *	This library is distributed in the hope that it will be useful,
+ *	but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ *	Lesser General Public License for more details.
+ *
+ *	You should have received a copy of the GNU Lesser General Public
+ *	License along with this library; if not, write to the Free Software
+ *	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "volume_id_internal.h"
+
+struct hpfs_super
+{
+	uint8_t		magic[4];
+	uint8_t		version;
+} __attribute__((__packed__));
+
+#define HPFS_SUPERBLOCK_OFFSET			0x2000
+
+int volume_id_probe_hpfs(struct volume_id *id, uint64_t off)
+{
+	struct hpfs_super *hs;
+
+	dbg("probing at offset 0x%llx", (unsigned long long) off);
+
+	hs = volume_id_get_buffer(id, off + HPFS_SUPERBLOCK_OFFSET, 0x200);
+	if (hs == NULL)
+		return -1;
+
+	if (memcmp(hs->magic, "\x49\xe8\x95\xf9", 4) == 0) {
+//		sprintf(id->type_version, "%u", hs->version);
+//		volume_id_set_usage(id, VOLUME_ID_FILESYSTEM);
+//		id->type = "hpfs";
+		return 0;
+	}
+
+	return -1;
+}
diff --git a/util-linux/volume_id/unused_isw_raid.c b/util-linux/volume_id/unused_isw_raid.c
new file mode 100644
index 0000000..d928245
--- /dev/null
+++ b/util-linux/volume_id/unused_isw_raid.c
@@ -0,0 +1,58 @@
+/*
+ * volume_id - reads filesystem label and uuid
+ *
+ * Copyright (C) 2005 Kay Sievers <kay.sievers@vrfy.org>
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation; either
+ *	version 2.1 of the License, or (at your option) any later version.
+ *
+ *	This library is distributed in the hope that it will be useful,
+ *	but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ *	Lesser General Public License for more details.
+ *
+ *	You should have received a copy of the GNU Lesser General Public
+ *	License along with this library; if not, write to the Free Software
+ *	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "volume_id_internal.h"
+
+struct isw_meta {
+	uint8_t		sig[32];
+	uint32_t	check_sum;
+	uint32_t	mpb_size;
+	uint32_t	family_num;
+	uint32_t	generation_num;
+} __attribute__((packed));
+
+#define ISW_SIGNATURE		"Intel Raid ISM Cfg Sig. "
+
+
+int volume_id_probe_intel_software_raid(struct volume_id *id, uint64_t off, uint64_t size)
+{
+	uint64_t meta_off;
+	struct isw_meta *isw;
+
+	dbg("probing at offset 0x%llx, size 0x%llx",
+	    (unsigned long long) off, (unsigned long long) size);
+
+	if (size < 0x10000)
+		return -1;
+
+	meta_off = ((size / 0x200)-2) * 0x200;
+	isw = volume_id_get_buffer(id, off + meta_off, 0x200);
+	if (isw == NULL)
+		return -1;
+
+	if (memcmp(isw->sig, ISW_SIGNATURE, sizeof(ISW_SIGNATURE)-1) != 0)
+		return -1;
+
+//	volume_id_set_usage(id, VOLUME_ID_RAID);
+//	memcpy(id->type_version, &isw->sig[sizeof(ISW_SIGNATURE)-1], 6);
+//	id->type = "isw_raid_member";
+
+	return 0;
+}
diff --git a/util-linux/volume_id/unused_lsi_raid.c b/util-linux/volume_id/unused_lsi_raid.c
new file mode 100644
index 0000000..730a313
--- /dev/null
+++ b/util-linux/volume_id/unused_lsi_raid.c
@@ -0,0 +1,52 @@
+/*
+ * volume_id - reads filesystem label and uuid
+ *
+ * Copyright (C) 2005 Kay Sievers <kay.sievers@vrfy.org>
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation; either
+ *	version 2.1 of the License, or (at your option) any later version.
+ *
+ *	This library is distributed in the hope that it will be useful,
+ *	but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ *	Lesser General Public License for more details.
+ *
+ *	You should have received a copy of the GNU Lesser General Public
+ *	License along with this library; if not, write to the Free Software
+ *	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "volume_id_internal.h"
+
+struct lsi_meta {
+	uint8_t		sig[6];
+} __attribute__((packed));
+
+#define LSI_SIGNATURE		"$XIDE$"
+
+int volume_id_probe_lsi_mega_raid(struct volume_id *id, uint64_t off, uint64_t size)
+{
+	uint64_t meta_off;
+	struct lsi_meta *lsi;
+
+	dbg("probing at offset 0x%llx, size 0x%llx",
+	    (unsigned long long) off, (unsigned long long) size);
+
+	if (size < 0x10000)
+		return -1;
+
+	meta_off = ((size / 0x200)-1) * 0x200;
+	lsi = volume_id_get_buffer(id, off + meta_off, 0x200);
+	if (lsi == NULL)
+		return -1;
+
+	if (memcmp(lsi->sig, LSI_SIGNATURE, sizeof(LSI_SIGNATURE)-1) != 0)
+		return -1;
+
+//	volume_id_set_usage(id, VOLUME_ID_RAID);
+//	id->type = "lsi_mega_raid_member";
+
+	return 0;
+}
diff --git a/util-linux/volume_id/unused_lvm.c b/util-linux/volume_id/unused_lvm.c
new file mode 100644
index 0000000..caee04b
--- /dev/null
+++ b/util-linux/volume_id/unused_lvm.c
@@ -0,0 +1,87 @@
+/*
+ * volume_id - reads filesystem label and uuid
+ *
+ * Copyright (C) 2004 Kay Sievers <kay.sievers@vrfy.org>
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation; either
+ *	version 2.1 of the License, or (at your option) any later version.
+ *
+ *	This library is distributed in the hope that it will be useful,
+ *	but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ *	Lesser General Public License for more details.
+ *
+ *	You should have received a copy of the GNU Lesser General Public
+ *	License along with this library; if not, write to the Free Software
+ *	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "volume_id_internal.h"
+
+struct lvm1_super_block {
+	uint8_t	id[2];
+} __attribute__((packed));
+
+struct lvm2_super_block {
+	uint8_t		id[8];
+	uint64_t	sector_xl;
+	uint32_t	crc_xl;
+	uint32_t	offset_xl;
+	uint8_t		type[8];
+} __attribute__((packed));
+
+#define LVM1_SB_OFF			0x400
+
+int volume_id_probe_lvm1(struct volume_id *id, uint64_t off)
+{
+	struct lvm1_super_block *lvm;
+
+	dbg("probing at offset 0x%llx", (unsigned long long) off);
+
+	lvm = volume_id_get_buffer(id, off + LVM1_SB_OFF, 0x800);
+	if (lvm == NULL)
+		return -1;
+
+	if (lvm->id[0] != 'H' || lvm->id[1] != 'M')
+		return -1;
+
+//	volume_id_set_usage(id, VOLUME_ID_RAID);
+//	id->type = "LVM1_member";
+
+	return 0;
+}
+
+#define LVM2_LABEL_ID			"LABELONE"
+#define LVM2LABEL_SCAN_SECTORS		4
+
+int volume_id_probe_lvm2(struct volume_id *id, uint64_t off)
+{
+	const uint8_t *buf;
+	unsigned soff;
+	struct lvm2_super_block *lvm;
+
+	dbg("probing at offset 0x%llx", (unsigned long long) off);
+
+	buf = volume_id_get_buffer(id, off, LVM2LABEL_SCAN_SECTORS * 0x200);
+	if (buf == NULL)
+		return -1;
+
+
+	for (soff = 0; soff < LVM2LABEL_SCAN_SECTORS * 0x200; soff += 0x200) {
+		lvm = (struct lvm2_super_block *) &buf[soff];
+
+		if (memcmp(lvm->id, LVM2_LABEL_ID, 8) == 0)
+			goto found;
+	}
+
+	return -1;
+
+ found:
+//	memcpy(id->type_version, lvm->type, 8);
+//	volume_id_set_usage(id, VOLUME_ID_RAID);
+//	id->type = "LVM2_member";
+
+	return 0;
+}
diff --git a/util-linux/volume_id/unused_mac.c b/util-linux/volume_id/unused_mac.c
new file mode 100644
index 0000000..8eaa173
--- /dev/null
+++ b/util-linux/volume_id/unused_mac.c
@@ -0,0 +1,123 @@
+/*
+ * volume_id - reads filesystem label and uuid
+ *
+ * Copyright (C) 2004 Kay Sievers <kay.sievers@vrfy.org>
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation; either
+ *	version 2.1 of the License, or (at your option) any later version.
+ *
+ *	This library is distributed in the hope that it will be useful,
+ *	but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ *	Lesser General Public License for more details.
+ *
+ *	You should have received a copy of the GNU Lesser General Public
+ *	License along with this library; if not, write to the Free Software
+ *	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "volume_id_internal.h"
+
+struct mac_driver_desc {
+	uint8_t		signature[2];
+	uint16_t	block_size;
+	uint32_t	block_count;
+} __attribute__((__packed__));
+
+struct mac_partition {
+	uint8_t		signature[2];
+	uint16_t	res1;
+	uint32_t	map_count;
+	uint32_t	start_block;
+	uint32_t	block_count;
+	uint8_t		name[32];
+	uint8_t		type[32];
+} __attribute__((__packed__));
+
+int volume_id_probe_mac_partition_map(struct volume_id *id, uint64_t off)
+{
+	const uint8_t *buf;
+	struct mac_driver_desc *driver;
+	struct mac_partition *part;
+
+	dbg("probing at offset 0x%llx", (unsigned long long) off);
+
+	buf = volume_id_get_buffer(id, off, 0x200);
+	if (buf == NULL)
+		return -1;
+
+	part = (struct mac_partition *) buf;
+	if (part->signature[0] == 'P' && part->signature[1] == 'M' /* "PM" */
+	 && (memcmp(part->type, "Apple_partition_map", 19) == 0)
+	) {
+		/* linux creates an own subdevice for the map
+		 * just return the type if the drive header is missing */
+//		volume_id_set_usage(id, VOLUME_ID_PARTITIONTABLE);
+//		id->type = "mac_partition_map";
+		return 0;
+	}
+
+	driver = (struct mac_driver_desc *) buf;
+	if (driver->signature[0] == 'E' && driver->signature[1] == 'R') { /* "ER" */
+		/* we are on a main device, like a CD
+		 * just try to probe the first partition from the map */
+		unsigned bsize = be16_to_cpu(driver->block_size);
+		int part_count;
+		int i;
+
+		/* get first entry of partition table */
+		buf = volume_id_get_buffer(id, off +  bsize, 0x200);
+		if (buf == NULL)
+			return -1;
+
+		part = (struct mac_partition *) buf;
+		if (part->signature[0] != 'P' || part->signature[1] != 'M') /* not "PM" */
+			return -1;
+
+		part_count = be32_to_cpu(part->map_count);
+		dbg("expecting %d partition entries", part_count);
+
+		if (id->partitions != NULL)
+			free(id->partitions);
+		id->partitions = xzalloc(part_count * sizeof(struct volume_id_partition));
+
+		id->partition_count = part_count;
+
+		for (i = 0; i < part_count; i++) {
+			uint64_t poff;
+			uint64_t plen;
+
+			buf = volume_id_get_buffer(id, off + ((i+1) * bsize), 0x200);
+			if (buf == NULL)
+				return -1;
+
+			part = (struct mac_partition *) buf;
+			if (part->signature[0] != 'P' || part->signature[1] != 'M') /* not "PM" */
+				return -1;
+
+			poff = be32_to_cpu(part->start_block) * bsize;
+			plen = be32_to_cpu(part->block_count) * bsize;
+			dbg("found '%s' partition entry at 0x%llx, len 0x%llx",
+					part->type, (unsigned long long) poff,
+					(unsigned long long) plen);
+
+//			id->partitions[i].pt_off = poff;
+//			id->partitions[i].pt_len = plen;
+
+//			if (memcmp(part->type, "Apple_Free", 10) == 0) {
+//				volume_id_set_usage_part(&id->partitions[i], VOLUME_ID_UNUSED);
+//			} else if (memcmp(part->type, "Apple_partition_map", 19) == 0) {
+//				volume_id_set_usage_part(&id->partitions[i], VOLUME_ID_PARTITIONTABLE);
+//			} else {
+//				volume_id_set_usage_part(&id->partitions[i], VOLUME_ID_UNPROBED);
+//			}
+		}
+//		volume_id_set_usage(id, VOLUME_ID_PARTITIONTABLE);
+//		id->type = "mac_partition_map";
+		return 0;
+	}
+
+	return -1;
+}
diff --git a/util-linux/volume_id/unused_minix.c b/util-linux/volume_id/unused_minix.c
new file mode 100644
index 0000000..2f52093
--- /dev/null
+++ b/util-linux/volume_id/unused_minix.c
@@ -0,0 +1,75 @@
+/*
+ * volume_id - reads filesystem label and uuid
+ *
+ * Copyright (C) 2005 Kay Sievers <kay.sievers@vrfy.org>
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation; either
+ *	version 2.1 of the License, or (at your option) any later version.
+ *
+ *	This library is distributed in the hope that it will be useful,
+ *	but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ *	Lesser General Public License for more details.
+ *
+ *	You should have received a copy of the GNU Lesser General Public
+ *	License along with this library; if not, write to the Free Software
+ *	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "volume_id_internal.h"
+
+struct minix_super_block {
+	uint16_t	s_ninodes;
+	uint16_t	s_nzones;
+	uint16_t	s_imap_blocks;
+	uint16_t	s_zmap_blocks;
+	uint16_t	s_firstdatazone;
+	uint16_t	s_log_zone_size;
+	uint32_t	s_max_size;
+	uint16_t	s_magic;
+	uint16_t	s_state;
+	uint32_t	s_zones;
+} __attribute__((__packed__));
+
+#define MINIX_SUPERBLOCK_OFFSET			0x400
+
+int volume_id_probe_minix(struct volume_id *id, uint64_t off)
+{
+	struct minix_super_block *ms;
+
+	dbg("probing at offset 0x%llx", (unsigned long long) off);
+
+	ms = volume_id_get_buffer(id, off + MINIX_SUPERBLOCK_OFFSET, 0x200);
+	if (ms == NULL)
+		return -1;
+
+	if (ms->s_magic == cpu_to_le16(0x137f)) {
+//		id->type_version[0] = '1';
+		goto found;
+	}
+
+	if (ms->s_magic == cpu_to_le16(0x1387)) {
+//		id->type_version[0] = '1';
+		goto found;
+	}
+
+	if (ms->s_magic == cpu_to_le16(0x2468)) {
+//		id->type_version[0] = '2';
+		goto found;
+	}
+
+	if (ms->s_magic == cpu_to_le16(0x2478)) {
+//		id->type_version[0] = '2';
+		goto found;
+	}
+
+	return -1;
+
+ found:
+//	id->type_version[1] = '\0';
+//	volume_id_set_usage(id, VOLUME_ID_FILESYSTEM);
+//	id->type = "minix";
+	return 0;
+}
diff --git a/util-linux/volume_id/unused_msdos.c b/util-linux/volume_id/unused_msdos.c
new file mode 100644
index 0000000..097ee67
--- /dev/null
+++ b/util-linux/volume_id/unused_msdos.c
@@ -0,0 +1,193 @@
+/*
+ * volume_id - reads filesystem label and uuid
+ *
+ * Copyright (C) 2004 Kay Sievers <kay.sievers@vrfy.org>
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation; either
+ *	version 2.1 of the License, or (at your option) any later version.
+ *
+ *	This library is distributed in the hope that it will be useful,
+ *	but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ *	Lesser General Public License for more details.
+ *
+ *	You should have received a copy of the GNU Lesser General Public
+ *	License along with this library; if not, write to the Free Software
+ *	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "volume_id_internal.h"
+
+struct msdos_partition_entry {
+	uint8_t		boot_ind;
+	uint8_t		head;
+	uint8_t		sector;
+	uint8_t		cyl;
+	uint8_t		sys_ind;
+	uint8_t		end_head;
+	uint8_t		end_sector;
+	uint8_t		end_cyl;
+	uint32_t	start_sect;
+	uint32_t	nr_sects;
+} __attribute__((packed));
+
+#define MSDOS_PARTTABLE_OFFSET		0x1be
+#define MSDOS_SIG_OFF			0x1fe
+#define BSIZE				0x200
+#define DOS_EXTENDED_PARTITION		0x05
+#define LINUX_EXTENDED_PARTITION	0x85
+#define WIN98_EXTENDED_PARTITION	0x0f
+#define LINUX_RAID_PARTITION		0xfd
+#define is_extended(type) \
+	(type == DOS_EXTENDED_PARTITION ||	\
+	 type == WIN98_EXTENDED_PARTITION ||	\
+	 type == LINUX_EXTENDED_PARTITION)
+#define is_raid(type) \
+	(type == LINUX_RAID_PARTITION)
+
+int volume_id_probe_msdos_part_table(struct volume_id *id, uint64_t off)
+{
+	const uint8_t *buf;
+	int i;
+	uint64_t poff;
+	uint64_t plen;
+	uint64_t extended = 0;
+	uint64_t current;
+	uint64_t next;
+	int limit;
+	int empty = 1;
+	struct msdos_partition_entry *part;
+	struct volume_id_partition *p;
+
+	dbg("probing at offset 0x%llx", (unsigned long long) off);
+
+	buf = volume_id_get_buffer(id, off, 0x200);
+	if (buf == NULL)
+		return -1;
+
+	if (buf[MSDOS_SIG_OFF] != 0x55 || buf[MSDOS_SIG_OFF + 1] != 0xaa)
+		return -1;
+
+	/* check flags on all entries for a valid partition table */
+	part = (struct msdos_partition_entry*) &buf[MSDOS_PARTTABLE_OFFSET];
+	for (i = 0; i < 4; i++) {
+		if (part[i].boot_ind != 0 &&
+		    part[i].boot_ind != 0x80)
+			return -1;
+
+		if (part[i].nr_sects != 0)
+			empty = 0;
+	}
+	if (empty == 1)
+		return -1;
+
+	if (id->partitions != NULL)
+		free(id->partitions);
+	id->partitions = xzalloc(VOLUME_ID_PARTITIONS_MAX *
+				sizeof(struct volume_id_partition));
+
+	for (i = 0; i < 4; i++) {
+		poff = (uint64_t) le32_to_cpu(part[i].start_sect) * BSIZE;
+		plen = (uint64_t) le32_to_cpu(part[i].nr_sects) * BSIZE;
+
+		if (plen == 0)
+			continue;
+
+		p = &id->partitions[i];
+
+//		p->pt_type_raw = part[i].sys_ind;
+
+		if (is_extended(part[i].sys_ind)) {
+			dbg("found extended partition at 0x%llx", (unsigned long long) poff);
+//			volume_id_set_usage_part(p, VOLUME_ID_PARTITIONTABLE);
+//			p->type = "msdos_extended_partition";
+			if (extended == 0)
+				extended = off + poff;
+		} else {
+			dbg("found 0x%x data partition at 0x%llx, len 0x%llx",
+			    part[i].sys_ind, (unsigned long long) poff, (unsigned long long) plen);
+
+//			if (is_raid(part[i].sys_ind))
+//				volume_id_set_usage_part(p, VOLUME_ID_RAID);
+//			else
+//				volume_id_set_usage_part(p, VOLUME_ID_UNPROBED);
+		}
+
+//		p->pt_off = off + poff;
+//		p->pt_len = plen;
+		id->partition_count = i+1;
+	}
+
+	next = extended;
+	current = extended;
+	limit = 50;
+
+	/* follow extended partition chain and add data partitions */
+	while (next != 0) {
+		if (limit-- == 0) {
+			dbg("extended chain limit reached");
+			break;
+		}
+
+		buf = volume_id_get_buffer(id, current, 0x200);
+		if (buf == NULL)
+			break;
+
+		part = (struct msdos_partition_entry*) &buf[MSDOS_PARTTABLE_OFFSET];
+
+		if (buf[MSDOS_SIG_OFF] != 0x55 || buf[MSDOS_SIG_OFF + 1] != 0xaa)
+			break;
+
+		next = 0;
+
+		for (i = 0; i < 4; i++) {
+			poff = (uint64_t) le32_to_cpu(part[i].start_sect) * BSIZE;
+			plen = (uint64_t) le32_to_cpu(part[i].nr_sects) * BSIZE;
+
+			if (plen == 0)
+				continue;
+
+			if (is_extended(part[i].sys_ind)) {
+				dbg("found extended partition at 0x%llx", (unsigned long long) poff);
+				if (next == 0)
+					next = extended + poff;
+			} else {
+				dbg("found 0x%x data partition at 0x%llx, len 0x%llx",
+					part[i].sys_ind, (unsigned long long) poff, (unsigned long long) plen);
+
+				/* we always start at the 5th entry */
+//				while (id->partition_count < 4)
+//					volume_id_set_usage_part(&id->partitions[id->partition_count++], VOLUME_ID_UNUSED);
+				if (id->partition_count < 4)
+					id->partition_count = 4;
+
+				p = &id->partitions[id->partition_count];
+
+//				if (is_raid(part[i].sys_ind))
+//					volume_id_set_usage_part(p, VOLUME_ID_RAID);
+//				else
+//					volume_id_set_usage_part(p, VOLUME_ID_UNPROBED);
+
+//				p->pt_off = current + poff;
+//				p->pt_len = plen;
+				id->partition_count++;
+
+//				p->pt_type_raw = part[i].sys_ind;
+
+				if (id->partition_count >= VOLUME_ID_PARTITIONS_MAX) {
+					dbg("too many partitions");
+					next = 0;
+				}
+			}
+		}
+
+		current = next;
+	}
+
+//	volume_id_set_usage(id, VOLUME_ID_PARTITIONTABLE);
+//	id->type = "msdos_partition_table";
+
+	return 0;
+}
diff --git a/util-linux/volume_id/unused_nvidia_raid.c b/util-linux/volume_id/unused_nvidia_raid.c
new file mode 100644
index 0000000..692aad1
--- /dev/null
+++ b/util-linux/volume_id/unused_nvidia_raid.c
@@ -0,0 +1,56 @@
+/*
+ * volume_id - reads filesystem label and uuid
+ *
+ * Copyright (C) 2005 Kay Sievers <kay.sievers@vrfy.org>
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation; either
+ *	version 2.1 of the License, or (at your option) any later version.
+ *
+ *	This library is distributed in the hope that it will be useful,
+ *	but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ *	Lesser General Public License for more details.
+ *
+ *	You should have received a copy of the GNU Lesser General Public
+ *	License along with this library; if not, write to the Free Software
+ *	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "volume_id_internal.h"
+
+struct nvidia_meta {
+	uint8_t		vendor[8];
+	uint32_t	size;
+	uint32_t	chksum;
+	uint16_t	version;
+} __attribute__((packed));
+
+#define NVIDIA_SIGNATURE		"NVIDIA"
+
+int volume_id_probe_nvidia_raid(struct volume_id *id, uint64_t off, uint64_t size)
+{
+	uint64_t meta_off;
+	struct nvidia_meta *nv;
+
+	dbg("probing at offset 0x%llx, size 0x%llx",
+	    (unsigned long long) off, (unsigned long long) size);
+
+	if (size < 0x10000)
+		return -1;
+
+	meta_off = ((size / 0x200)-2) * 0x200;
+	nv = volume_id_get_buffer(id, off + meta_off, 0x200);
+	if (nv == NULL)
+		return -1;
+
+	if (memcmp(nv->vendor, NVIDIA_SIGNATURE, sizeof(NVIDIA_SIGNATURE)-1) != 0)
+		return -1;
+
+//	volume_id_set_usage(id, VOLUME_ID_RAID);
+//	snprintf(id->type_version, sizeof(id->type_version)-1, "%u", le16_to_cpu(nv->version));
+//	id->type = "nvidia_raid_member";
+
+	return 0;
+}
diff --git a/util-linux/volume_id/unused_promise_raid.c b/util-linux/volume_id/unused_promise_raid.c
new file mode 100644
index 0000000..75c6f89
--- /dev/null
+++ b/util-linux/volume_id/unused_promise_raid.c
@@ -0,0 +1,63 @@
+/*
+ * volume_id - reads filesystem label and uuid
+ *
+ * Copyright (C) 2005 Kay Sievers <kay.sievers@vrfy.org>
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation; either
+ *	version 2.1 of the License, or (at your option) any later version.
+ *
+ *	This library is distributed in the hope that it will be useful,
+ *	but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ *	Lesser General Public License for more details.
+ *
+ *	You should have received a copy of the GNU Lesser General Public
+ *	License along with this library; if not, write to the Free Software
+ *	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "volume_id_internal.h"
+
+struct promise_meta {
+	uint8_t	sig[24];
+} __attribute__((packed));
+
+#define PDC_CONFIG_OFF		0x1200
+#define PDC_SIGNATURE		"Promise Technology, Inc."
+
+int volume_id_probe_promise_fasttrack_raid(struct volume_id *id, uint64_t off, uint64_t size)
+{
+	static const unsigned short sectors[] = {
+		63, 255, 256, 16, 399
+	};
+
+	struct promise_meta *pdc;
+	unsigned i;
+
+	dbg("probing at offset 0x%llx, size 0x%llx",
+	    (unsigned long long) off, (unsigned long long) size);
+
+	if (size < 0x40000)
+		return -1;
+
+	for (i = 0; i < ARRAY_SIZE(sectors); i++) {
+		uint64_t meta_off;
+
+		meta_off = ((size / 0x200) - sectors[i]) * 0x200;
+		pdc = volume_id_get_buffer(id, off + meta_off, 0x200);
+		if (pdc == NULL)
+			return -1;
+
+		if (memcmp(pdc->sig, PDC_SIGNATURE, sizeof(PDC_SIGNATURE)-1) == 0)
+			goto found;
+	}
+	return -1;
+
+ found:
+//	volume_id_set_usage(id, VOLUME_ID_RAID);
+//	id->type = "promise_fasttrack_raid_member";
+
+	return 0;
+}
diff --git a/util-linux/volume_id/unused_silicon_raid.c b/util-linux/volume_id/unused_silicon_raid.c
new file mode 100644
index 0000000..5143112
--- /dev/null
+++ b/util-linux/volume_id/unused_silicon_raid.c
@@ -0,0 +1,69 @@
+/*
+ * volume_id - reads filesystem label and uuid
+ *
+ * Copyright (C) 2005 Kay Sievers <kay.sievers@vrfy.org>
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation; either
+ *	version 2.1 of the License, or (at your option) any later version.
+ *
+ *	This library is distributed in the hope that it will be useful,
+ *	but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ *	Lesser General Public License for more details.
+ *
+ *	You should have received a copy of the GNU Lesser General Public
+ *	License along with this library; if not, write to the Free Software
+ *	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "volume_id_internal.h"
+
+struct silicon_meta {
+	uint8_t		unknown0[0x2E];
+	uint8_t		ascii_version[0x36 - 0x2E];
+	uint8_t		diskname[0x56 - 0x36];
+	uint8_t		unknown1[0x60 - 0x56];
+	uint32_t	magic;
+	uint32_t	unknown1a[0x6C - 0x64];
+	uint32_t	array_sectors_low;
+	uint32_t	array_sectors_high;
+	uint8_t		unknown2[0x78 - 0x74];
+	uint32_t	thisdisk_sectors;
+	uint8_t		unknown3[0x100 - 0x7C];
+	uint8_t		unknown4[0x104 - 0x100];
+	uint16_t	product_id;
+	uint16_t	vendor_id;
+	uint16_t	minor_ver;
+	uint16_t	major_ver;
+} __attribute__((packed));
+
+#define SILICON_MAGIC		0x2F000000
+
+int volume_id_probe_silicon_medley_raid(struct volume_id *id, uint64_t off, uint64_t size)
+{
+	uint64_t meta_off;
+	struct silicon_meta *sil;
+
+	dbg("probing at offset 0x%llx, size 0x%llx",
+	    (unsigned long long) off, (unsigned long long) size);
+
+	if (size < 0x10000)
+		return -1;
+
+	meta_off = ((size / 0x200)-1) * 0x200;
+	sil = volume_id_get_buffer(id, off + meta_off, 0x200);
+	if (sil == NULL)
+		return -1;
+
+	if (sil->magic != cpu_to_le32(SILICON_MAGIC))
+		return -1;
+
+//	volume_id_set_usage(id, VOLUME_ID_RAID);
+//	snprintf(id->type_version, sizeof(id->type_version)-1, "%u.%u",
+//		 le16_to_cpu(sil->major_ver), le16_to_cpu(sil->minor_ver));
+//	id->type = "silicon_medley_raid_member";
+
+	return 0;
+}
diff --git a/util-linux/volume_id/unused_ufs.c b/util-linux/volume_id/unused_ufs.c
new file mode 100644
index 0000000..ba76876
--- /dev/null
+++ b/util-linux/volume_id/unused_ufs.c
@@ -0,0 +1,206 @@
+/*
+ * volume_id - reads filesystem label and uuid
+ *
+ * Copyright (C) 2004 Kay Sievers <kay.sievers@vrfy.org>
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation; either
+ *	version 2.1 of the License, or (at your option) any later version.
+ *
+ *	This library is distributed in the hope that it will be useful,
+ *	but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ *	Lesser General Public License for more details.
+ *
+ *	You should have received a copy of the GNU Lesser General Public
+ *	License along with this library; if not, write to the Free Software
+ *	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "volume_id_internal.h"
+
+struct ufs_super_block {
+	uint32_t	fs_link;
+	uint32_t	fs_rlink;
+	uint32_t	fs_sblkno;
+	uint32_t	fs_cblkno;
+	uint32_t	fs_iblkno;
+	uint32_t	fs_dblkno;
+	uint32_t	fs_cgoffset;
+	uint32_t	fs_cgmask;
+	uint32_t	fs_time;
+	uint32_t	fs_size;
+	uint32_t	fs_dsize;
+	uint32_t	fs_ncg;	
+	uint32_t	fs_bsize;
+	uint32_t	fs_fsize;
+	uint32_t	fs_frag;
+	uint32_t	fs_minfree;
+	uint32_t	fs_rotdelay;
+	uint32_t	fs_rps;	
+	uint32_t	fs_bmask;
+	uint32_t	fs_fmask;
+	uint32_t	fs_bshift;
+	uint32_t	fs_fshift;
+	uint32_t	fs_maxcontig;
+	uint32_t	fs_maxbpg;
+	uint32_t	fs_fragshift;
+	uint32_t	fs_fsbtodb;
+	uint32_t	fs_sbsize;
+	uint32_t	fs_csmask;
+	uint32_t	fs_csshift;
+	uint32_t	fs_nindir;
+	uint32_t	fs_inopb;
+	uint32_t	fs_nspf;
+	uint32_t	fs_optim;
+	uint32_t	fs_npsect_state;
+	uint32_t	fs_interleave;
+	uint32_t	fs_trackskew;
+	uint32_t	fs_id[2];
+	uint32_t	fs_csaddr;
+	uint32_t	fs_cssize;
+	uint32_t	fs_cgsize;
+	uint32_t	fs_ntrak;
+	uint32_t	fs_nsect;
+	uint32_t	fs_spc;	
+	uint32_t	fs_ncyl;
+	uint32_t	fs_cpg;
+	uint32_t	fs_ipg;
+	uint32_t	fs_fpg;
+	struct ufs_csum {
+		uint32_t	cs_ndir;
+		uint32_t	cs_nbfree;
+		uint32_t	cs_nifree;
+		uint32_t	cs_nffree;
+	} __attribute__((__packed__)) fs_cstotal;
+	int8_t		fs_fmod;
+	int8_t		fs_clean;
+	int8_t		fs_ronly;
+	int8_t		fs_flags;
+	union {
+		struct {
+			int8_t	fs_fsmnt[512];
+			uint32_t	fs_cgrotor;
+			uint32_t	fs_csp[31];
+			uint32_t	fs_maxcluster;
+			uint32_t	fs_cpc;
+			uint16_t	fs_opostbl[16][8];
+		} __attribute__((__packed__)) fs_u1;
+		struct {
+			int8_t		fs_fsmnt[468];
+			uint8_t		fs_volname[32];
+			uint64_t	fs_swuid;
+			int32_t		fs_pad;
+			uint32_t	fs_cgrotor;
+			uint32_t	fs_ocsp[28];
+			uint32_t	fs_contigdirs;
+			uint32_t	fs_csp;	
+			uint32_t	fs_maxcluster;
+			uint32_t	fs_active;
+			int32_t		fs_old_cpc;
+			int32_t		fs_maxbsize;
+			int64_t		fs_sparecon64[17];
+			int64_t		fs_sblockloc;
+			struct ufs2_csum_total {
+				uint64_t	cs_ndir;
+				uint64_t	cs_nbfree;
+				uint64_t	cs_nifree;
+				uint64_t	cs_nffree;
+				uint64_t	cs_numclusters;
+				uint64_t	cs_spare[3];
+			} __attribute__((__packed__)) fs_cstotal;
+			struct ufs_timeval {
+				int32_t		tv_sec;
+				int32_t		tv_usec;
+			} __attribute__((__packed__)) fs_time;
+			int64_t		fs_size;
+			int64_t		fs_dsize;
+			uint64_t	fs_csaddr;
+			int64_t		fs_pendingblocks;
+			int32_t		fs_pendinginodes;
+		} __attribute__((__packed__)) fs_u2;
+	}  fs_u11;
+	union {
+		struct {
+			int32_t		fs_sparecon[53];
+			int32_t		fs_reclaim;
+			int32_t		fs_sparecon2[1];
+			int32_t		fs_state;
+			uint32_t	fs_qbmask[2];
+			uint32_t	fs_qfmask[2];
+		} __attribute__((__packed__)) fs_sun;
+		struct {
+			int32_t		fs_sparecon[53];
+			int32_t		fs_reclaim;
+			int32_t		fs_sparecon2[1];
+			uint32_t	fs_npsect;
+			uint32_t	fs_qbmask[2];
+			uint32_t	fs_qfmask[2];
+		} __attribute__((__packed__)) fs_sunx86;
+		struct {
+			int32_t		fs_sparecon[50];
+			int32_t		fs_contigsumsize;
+			int32_t		fs_maxsymlinklen;
+			int32_t		fs_inodefmt;
+			uint32_t	fs_maxfilesize[2];
+			uint32_t	fs_qbmask[2];
+			uint32_t	fs_qfmask[2];
+			int32_t		fs_state;
+		} __attribute__((__packed__)) fs_44;
+	} fs_u2;
+	int32_t		fs_postblformat;
+	int32_t		fs_nrpos;
+	int32_t		fs_postbloff;
+	int32_t		fs_rotbloff;
+	uint32_t	fs_magic;
+	uint8_t		fs_space[1];
+} __attribute__((__packed__));
+
+#define UFS_MAGIC			0x00011954
+#define UFS2_MAGIC			0x19540119
+#define UFS_MAGIC_FEA			0x00195612
+#define UFS_MAGIC_LFN			0x00095014
+
+int volume_id_probe_ufs(struct volume_id *id, uint64_t off)
+{
+	static const short offsets[] = { 0, 8, 64, 256 };
+
+	uint32_t magic;
+	int i;
+	struct ufs_super_block *ufs;
+
+	dbg("probing at offset 0x%llx", (unsigned long long) off);
+
+	for (i = 0; i < ARRAY_SIZE(offsets); i++) {	
+		ufs = volume_id_get_buffer(id, off + (offsets[i] * 0x400), 0x800);
+		if (ufs == NULL)
+			return -1;
+
+		dbg("offset 0x%x", offsets[i] * 0x400);
+		magic = ufs->fs_magic;
+		if ((magic == cpu_to_be32(UFS_MAGIC))
+		 || (magic == cpu_to_be32(UFS2_MAGIC))
+		 || (magic == cpu_to_be32(UFS_MAGIC_FEA))
+		 || (magic == cpu_to_be32(UFS_MAGIC_LFN))
+		) {
+			dbg("magic 0x%08x(be)", magic);
+			goto found;
+		}
+		if ((magic == cpu_to_le32(UFS_MAGIC))
+		 || (magic == cpu_to_le32(UFS2_MAGIC))
+		 || (magic == cpu_to_le32(UFS_MAGIC_FEA))
+		 || (magic == cpu_to_le32(UFS_MAGIC_LFN))
+		) {
+			dbg("magic 0x%08x(le)", magic);
+			goto found;
+		}
+	}
+	return -1;
+
+ found:
+//	volume_id_set_usage(id, VOLUME_ID_FILESYSTEM);
+//	id->type = "ufs";
+
+	return 0;
+}
diff --git a/util-linux/volume_id/unused_via_raid.c b/util-linux/volume_id/unused_via_raid.c
new file mode 100644
index 0000000..4332946
--- /dev/null
+++ b/util-linux/volume_id/unused_via_raid.c
@@ -0,0 +1,68 @@
+/*
+ * volume_id - reads filesystem label and uuid
+ *
+ * Copyright (C) 2005 Kay Sievers <kay.sievers@vrfy.org>
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation; either
+ *	version 2.1 of the License, or (at your option) any later version.
+ *
+ *	This library is distributed in the hope that it will be useful,
+ *	but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ *	Lesser General Public License for more details.
+ *
+ *	You should have received a copy of the GNU Lesser General Public
+ *	License along with this library; if not, write to the Free Software
+ *	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "volume_id_internal.h"
+
+struct via_meta {
+	uint16_t	signature;
+	uint8_t		version_number;
+	struct via_array {
+		uint16_t	disk_bits;
+		uint8_t		disk_array_ex;
+		uint32_t	capacity_low;
+		uint32_t	capacity_high;
+		uint32_t	serial_checksum;
+	} __attribute((packed)) array;
+	uint32_t	serial_checksum[8];
+	uint8_t		checksum;
+} __attribute__((packed));
+
+#define VIA_SIGNATURE		0xAA55
+
+int volume_id_probe_via_raid(struct volume_id *id, uint64_t off, uint64_t size)
+{
+	uint64_t meta_off;
+	struct via_meta *via;
+
+	dbg("probing at offset 0x%llx, size 0x%llx",
+	    (unsigned long long) off, (unsigned long long) size);
+
+	if (size < 0x10000)
+		return -1;
+
+	meta_off = ((size / 0x200)-1) * 0x200;
+
+	via = volume_id_get_buffer(id, off + meta_off, 0x200);
+	if (via == NULL)
+		return -1;
+
+	if (via->signature != cpu_to_le16(VIA_SIGNATURE))
+		return -1;
+
+	if (via->version_number > 1)
+		return -1;
+
+//	volume_id_set_usage(id, VOLUME_ID_RAID);
+//	id->type_version[0] = '0' + via->version_number;
+//	id->type_version[1] = '\0';
+//	id->type = "via_raid_member";
+
+	return 0;
+}
diff --git a/util-linux/volume_id/via_raid.c b/util-linux/volume_id/via_raid.c
deleted file mode 100644
index a3e94e0..0000000
--- a/util-linux/volume_id/via_raid.c
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * volume_id - reads filesystem label and uuid
- *
- * Copyright (C) 2005 Kay Sievers <kay.sievers@vrfy.org>
- *
- *	This library is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	This library is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- *	Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with this library; if not, write to the Free Software
- *	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- */
-
-#include "volume_id_internal.h"
-
-struct via_meta {
-	uint16_t	signature;
-	uint8_t		version_number;
-	struct via_array {
-		uint16_t	disk_bits;
-		uint8_t		disk_array_ex;
-		uint32_t	capacity_low;
-		uint32_t	capacity_high;
-		uint32_t	serial_checksum;
-	} __attribute((packed)) array;
-	uint32_t	serial_checksum[8];
-	uint8_t		checksum;
-} __attribute__((packed));
-
-#define VIA_SIGNATURE		0xAA55
-
-int volume_id_probe_via_raid(struct volume_id *id, uint64_t off, uint64_t size)
-{
-	uint64_t meta_off;
-	struct via_meta *via;
-
-	dbg("probing at offset 0x%llx, size 0x%llx",
-	    (unsigned long long) off, (unsigned long long) size);
-
-	if (size < 0x10000)
-		return -1;
-
-	meta_off = ((size / 0x200)-1) * 0x200;
-
-	via = volume_id_get_buffer(id, off + meta_off, 0x200);
-	if (via == NULL)
-		return -1;
-
-	if (via->signature !=  cpu_to_le16(VIA_SIGNATURE))
-		return -1;
-
-	if (via->version_number > 1)
-		return -1;
-
-//	volume_id_set_usage(id, VOLUME_ID_RAID);
-//	id->type_version[0] = '0' + via->version_number;
-//	id->type_version[1] = '\0';
-//	id->type = "via_raid_member";
-
-	return 0;
-}
diff --git a/util-linux/volume_id/volume_id.c b/util-linux/volume_id/volume_id.c
index a26e2bc..de9aae2 100644
--- a/util-linux/volume_id/volume_id.c
+++ b/util-linux/volume_id/volume_id.c
@@ -20,6 +20,31 @@
 
 #include "volume_id_internal.h"
 
+
+/* Some detection routines do not set label or uuid anyway,
+ * so they are disabled. */
+
+/* Looks for partitions, we don't use it: */
+#define ENABLE_FEATURE_VOLUMEID_MAC           0
+/* #define ENABLE_FEATURE_VOLUMEID_MSDOS      0 - NB: this one
+ * was not properly added to probe table anyway - ??! */
+
+/* None of RAIDs have label or uuid, except LinuxRAID: */
+#define ENABLE_FEATURE_VOLUMEID_HIGHPOINTRAID 0
+#define ENABLE_FEATURE_VOLUMEID_ISWRAID       0
+#define ENABLE_FEATURE_VOLUMEID_LSIRAID       0
+#define ENABLE_FEATURE_VOLUMEID_LVM           0
+#define ENABLE_FEATURE_VOLUMEID_NVIDIARAID    0
+#define ENABLE_FEATURE_VOLUMEID_PROMISERAID   0
+#define ENABLE_FEATURE_VOLUMEID_SILICONRAID   0
+#define ENABLE_FEATURE_VOLUMEID_VIARAID       0
+
+/* These filesystems also have no label or uuid: */
+#define ENABLE_FEATURE_VOLUMEID_MINIX         0
+#define ENABLE_FEATURE_VOLUMEID_HPFS          0
+#define ENABLE_FEATURE_VOLUMEID_UFS           0
+
+
 typedef int (*raid_probe_fptr)(struct volume_id *id, uint64_t off, uint64_t size);
 typedef int (*probe_fptr)(struct volume_id *id, uint64_t off);
 
@@ -68,10 +93,9 @@ static const probe_fptr fs1[] = {
 #if ENABLE_FEATURE_VOLUMEID_FAT
 	volume_id_probe_vfat,
 #endif
-// This one only looks for partitions, we don't use it
-//#if ENABLE_FEATURE_VOLUMEID_MAC
-//	volume_id_probe_mac_partition_map,
-//#endif
+#if ENABLE_FEATURE_VOLUMEID_MAC
+	volume_id_probe_mac_partition_map,
+#endif
 #if ENABLE_FEATURE_VOLUMEID_XFS
 	volume_id_probe_xfs,
 #endif
diff --git a/util-linux/volume_id/volume_id_internal.h b/util-linux/volume_id/volume_id_internal.h
index 8c7ca03..78b4a7b 100644
--- a/util-linux/volume_id/volume_id_internal.h
+++ b/util-linux/volume_id/volume_id_internal.h
@@ -163,25 +163,25 @@ void volume_id_free_buffer(struct volume_id *id);
 
 /* RAID */
 
-int volume_id_probe_highpoint_37x_raid(struct volume_id *id, uint64_t off);
-int volume_id_probe_highpoint_45x_raid(struct volume_id *id, uint64_t off, uint64_t size);
+//int volume_id_probe_highpoint_37x_raid(struct volume_id *id, uint64_t off);
+//int volume_id_probe_highpoint_45x_raid(struct volume_id *id, uint64_t off, uint64_t size);
 
-int volume_id_probe_intel_software_raid(struct volume_id *id, uint64_t off, uint64_t size);
+//int volume_id_probe_intel_software_raid(struct volume_id *id, uint64_t off, uint64_t size);
 
 int volume_id_probe_linux_raid(struct volume_id *id, uint64_t off, uint64_t size);
 
-int volume_id_probe_lsi_mega_raid(struct volume_id *id, uint64_t off, uint64_t size);
+//int volume_id_probe_lsi_mega_raid(struct volume_id *id, uint64_t off, uint64_t size);
 
-int volume_id_probe_nvidia_raid(struct volume_id *id, uint64_t off, uint64_t size);
+//int volume_id_probe_nvidia_raid(struct volume_id *id, uint64_t off, uint64_t size);
 
-int volume_id_probe_promise_fasttrack_raid(struct volume_id *id, uint64_t off, uint64_t size);
+//int volume_id_probe_promise_fasttrack_raid(struct volume_id *id, uint64_t off, uint64_t size);
 
-int volume_id_probe_silicon_medley_raid(struct volume_id *id, uint64_t off, uint64_t size);
+//int volume_id_probe_silicon_medley_raid(struct volume_id *id, uint64_t off, uint64_t size);
 
-int volume_id_probe_via_raid(struct volume_id *id, uint64_t off, uint64_t size);
+//int volume_id_probe_via_raid(struct volume_id *id, uint64_t off, uint64_t size);
 
-int volume_id_probe_lvm1(struct volume_id *id, uint64_t off);
-int volume_id_probe_lvm2(struct volume_id *id, uint64_t off);
+//int volume_id_probe_lvm1(struct volume_id *id, uint64_t off);
+//int volume_id_probe_lvm2(struct volume_id *id, uint64_t off);
 
 /* FS */
 
@@ -193,7 +193,7 @@ int volume_id_probe_vfat(struct volume_id *id, uint64_t off);
 
 int volume_id_probe_hfs_hfsplus(struct volume_id *id, uint64_t off);
 
-int volume_id_probe_hpfs(struct volume_id *id, uint64_t off);
+//int volume_id_probe_hpfs(struct volume_id *id, uint64_t off);
 
 int volume_id_probe_iso9660(struct volume_id *id, uint64_t off);
 
@@ -205,7 +205,7 @@ int volume_id_probe_luks(struct volume_id *id, uint64_t off);
 
 //int volume_id_probe_mac_partition_map(struct volume_id *id, uint64_t off);
 
-int volume_id_probe_minix(struct volume_id *id, uint64_t off);
+//int volume_id_probe_minix(struct volume_id *id, uint64_t off);
 
 //int volume_id_probe_msdos_part_table(struct volume_id *id, uint64_t off);
 
@@ -221,6 +221,6 @@ int volume_id_probe_sysv(struct volume_id *id, uint64_t off);
 
 int volume_id_probe_udf(struct volume_id *id, uint64_t off);
 
-int volume_id_probe_ufs(struct volume_id *id, uint64_t off);
+//int volume_id_probe_ufs(struct volume_id *id, uint64_t off);
 
 int volume_id_probe_xfs(struct volume_id *id, uint64_t off);
